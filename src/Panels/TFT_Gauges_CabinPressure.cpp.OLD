// CockpitOS — Cabin Pressure Gauge (LovyanGFX, ST77916/61, Double-buffered, PSRAM)

#define CABIN_PRESSURE_USE_DOUBLE_BUFFER 1  // Set to 0 for single-buffered (legacy) mode
#define CABIN_PRESSURE_GAUGE_DRAW_MIN_INTERVAL_MS 13
#define RUN_CABIN_PRESSURE_GAUGE_AS_TASK 1
#define BACKLIGHT_LABEL "INST_PNL_DIMMER"

#include "../Globals.h"
#include "../TFT_Gauges_CabPress.h"
#include "../HIDManager.h"
#include "../DCSBIOSBridge.h"
#include <LovyanGFX.hpp>
#include <cstring>

// Pins (S2 device)
#define CABIN_PRESSURE_MOSI_PIN  8
#define CABIN_PRESSURE_SCLK_PIN  9
#define CABIN_PRESSURE_DC_PIN   13
#define CABIN_PRESSURE_RST_PIN  -1
#define CABIN_PRESSURE_MISO_PIN -1

// Assets (360x360 bg, 23x238 needle)
#include "Assets/CabinPressure/cabinPressBackground.h"
#include "Assets/CabinPressure/cabinPressBackgroundNVG.h"
#include "Assets/CabinPressure/cabinPressNeedle.h"
#include "Assets/CabinPressure/cabinPressNeedleNVG.h"

// Bus flags
static constexpr bool shared_bus = false;
static constexpr bool use_lock = false;

// --- Panel binding ---
class LGFX_CabPress final : public lgfx::LGFX_Device {
    lgfx::Bus_SPI _bus;
    lgfx::Panel_ST77961 _panel;
public:
    LGFX_CabPress() {
        {
            auto cfg = _bus.config();
            cfg.spi_host = SPI2_HOST;
            cfg.spi_mode = 0;
            cfg.freq_write = 80000000;
            cfg.freq_read = 0;
            cfg.spi_3wire = false;
            cfg.use_lock = use_lock;
            cfg.dma_channel = 1;
            cfg.pin_mosi = CABIN_PRESSURE_MOSI_PIN;
            cfg.pin_miso = CABIN_PRESSURE_MISO_PIN;
            cfg.pin_sclk = CABIN_PRESSURE_SCLK_PIN;
            cfg.pin_dc = CABIN_PRESSURE_DC_PIN;
            _bus.config(cfg);
            _panel.setBus(&_bus);
        }
        {
            auto pcfg = _panel.config();
            pcfg.pin_cs = CABIN_PRESSURE_CS_PIN;
            pcfg.pin_rst = CABIN_PRESSURE_RST_PIN;
            pcfg.pin_busy = -1;
            pcfg.memory_width = 360;
            pcfg.memory_height = 360;
            pcfg.panel_width = 360;
            pcfg.panel_height = 360;
            pcfg.offset_x = 0;
            pcfg.offset_y = 0;
            pcfg.offset_rotation = 0;
            pcfg.bus_shared = shared_bus;
            pcfg.invert = true;
            pcfg.rgb_order = true;
            _panel.config(pcfg);
        }
        setPanel(&_panel);
    }
};

// --- State ---
static LGFX_CabPress tft;
static lgfx::LGFX_Sprite needleU(&tft);

static constexpr uint8_t  COLOR_DEPTH = 16;
static constexpr int16_t  CENTER_X = 180;
static constexpr int16_t  CENTER_Y = 180;

#if CABIN_PRESSURE_USE_DOUBLE_BUFFER
static constexpr uint16_t TRANSPARENT_KEY = 0x2001;
#else
static constexpr uint16_t TRANSPARENT_KEY = 0x0120;
#endif

static constexpr uint16_t NVG_THRESHOLD = 6553;
static volatile int16_t   angleU = -181;
static volatile int16_t   lastDrawnAngleU = INT16_MIN;
static volatile bool      gaugeDirty = false;
static volatile uint8_t   currentLightingMode = 0;   // 0=Day, 2=NVG
static uint8_t            lastNeedleMode = 0xFF;
static unsigned long      lastDrawTime = 0;
static TaskHandle_t       tftTaskHandle = nullptr;

// --- PSRAM framebuffer ---
static uint16_t* cabPressFrame = nullptr;   // PSRAM buffer

// --- Build needle sprite (swap = true) ---
static void buildNeedle(lgfx::LGFX_Sprite& spr, const uint16_t* img) {
    spr.fillScreen(TRANSPARENT_KEY);

#if CABIN_PRESSURE_USE_DOUBLE_BUFFER
    spr.setSwapBytes(true);
#else
	spr.setSwapBytes(false);
#endif

    spr.pushImage(0, 0, 23, 238, img);
}

// --- DCS-BIOS callback ---
static void onPressureAltChange(const char*, uint16_t value, uint16_t) {
    int16_t a = map(value, 0, 65535, -181, 125);
    if (a != angleU) { angleU = a; gaugeDirty = true; }
}

static void CabinPressureGauge_draw(bool force = false)
{
    if (!force && !isMissionRunning()) return;

    static float avg_bg = 0, avg_needle = 0, avg_memcpy = 0, avg_dma = 0;
    static int frameCounter = 0;
    const float alpha = 0.15f;

    unsigned long t_start, t_bg, t_needle, t_memcpy, t_dma;

    const unsigned long now = millis();
    int16_t u = angleU; if (u < -181) u = -181; else if (u > 125) u = 125;

    const bool shouldDraw = force || gaugeDirty || (u != lastDrawnAngleU);
    if (!shouldDraw) return;
    if (!force && (now - lastDrawTime < CABIN_PRESSURE_GAUGE_DRAW_MIN_INTERVAL_MS)) return;

    lastDrawTime = now;
    lastDrawnAngleU = u;
    gaugeDirty = false;

    const uint16_t* bg = (currentLightingMode == 0) ? cabinPressBackground : cabinPressBackgroundNVG;
    const uint16_t* needleImg = (currentLightingMode == 0) ? cabinPressNeedle : cabinPressNeedleNVG;

    if (lastNeedleMode != currentLightingMode) {
        buildNeedle(needleU, needleImg);
        lastNeedleMode = currentLightingMode;
    }

#if CABIN_PRESSURE_USE_DOUBLE_BUFFER

    // --- Double buffering (PSRAM) ---
    static lgfx::LGFX_Sprite frameSpr(&tft);
    if (frameSpr.width() != 360 || frameSpr.height() != 360) {
        frameSpr.deleteSprite();
        frameSpr.setColorDepth(COLOR_DEPTH);
        frameSpr.setPsram(true);
        frameSpr.createSprite(360, 360);
    }

    t_start = micros();
    frameSpr.setSwapBytes(false);
    frameSpr.pushImage(0, 0, 360, 360, bg);
    t_bg = micros();

    needleU.pushRotateZoom(&frameSpr, CENTER_X, CENTER_Y, (float)u, 1.0f, 1.0f, TRANSPARENT_KEY);
    t_needle = micros();

    if (cabPressFrame) {
        std::memcpy(cabPressFrame, frameSpr.getBuffer(), 360 * 360 * 2);
        t_memcpy = micros();

        tft.startWrite();
        tft.pushImageDMA(0, 0, 360, 360, cabPressFrame);
        tft.endWrite();
        t_dma = micros();
    }
    else {
        t_memcpy = t_dma = t_needle;
    }

#else

    // --- Single-buffered (legacy) ---
    t_start = micros();
    tft.startWrite();
    tft.setSwapBytes(true);  
    tft.pushImage(0, 0, 360, 360, bg);
    t_bg = micros();

    needleU.pushRotateZoom(&tft, CENTER_X, CENTER_Y, (float)u, 1.0f, 1.0f, TRANSPARENT_KEY);
    t_needle = t_memcpy = t_dma = micros();

    tft.endWrite();

#endif

    float bg_ms = (t_bg - t_start) / 1000.0f;
    float needle_ms = (t_needle - t_bg) / 1000.0f;
    float memcpy_ms = (t_memcpy - t_needle) / 1000.0f;
    float dma_ms = (t_dma - t_memcpy) / 1000.0f;

    avg_bg = (1.0f - alpha) * avg_bg + alpha * bg_ms;
    avg_needle = (1.0f - alpha) * avg_needle + alpha * needle_ms;
    avg_memcpy = (1.0f - alpha) * avg_memcpy + alpha * memcpy_ms;
    avg_dma = (1.0f - alpha) * avg_dma + alpha * dma_ms;

    frameCounter++;
    if (frameCounter % 10 == 0) {
        debugPrintf("[TFT CABIN PRESSURE] BG: %.2f ms, Needle: %.2f ms, MemCpy: %.2f ms, DMA: %.2f ms\n",
            avg_bg, avg_needle, avg_memcpy, avg_dma);
    }
}

// --- Task ---
static void CabinPressureGauge_task(void*) {
    for (;;) { CabinPressureGauge_draw(false); vTaskDelay(pdMS_TO_TICKS(5)); }
}

// --- Lighting control ---
static void onInstPanelDimmerChange(const char*, uint16_t v, uint16_t) {
    const uint8_t mode = (v > NVG_THRESHOLD) ? 2u : 0u;   // 0=DAY, 2=NVG
    if (mode == currentLightingMode) return;
    currentLightingMode = mode;
    gaugeDirty = true;
}

// --- API ---
void CabinPressureGauge_init()
{
    if (!initPSRAM()) {
        debugPrintln("❌ No PSRAM detected! Cabin Pressure Gauge double-buffering disabled.");
        while (1) vTaskDelay(1000);
    }
    // PSRAM frame allocation
    if (!cabPressFrame) {
        cabPressFrame = (uint16_t*)PS_MALLOC(360 * 360 * 2);
        if (!cabPressFrame) {
            debugPrintln("❌ PSRAM framebuffer alloc failed!");
            while (1) vTaskDelay(1000);
        }
    }

    tft.init();
    tft.setColorDepth(COLOR_DEPTH);
    tft.setRotation(0);
    tft.setSwapBytes(true); // *** SWAPPED! ***
    tft.fillScreen(TFT_BLACK);

    needleU.setColorDepth(COLOR_DEPTH);
    needleU.createSprite(23, 238);
    needleU.setPivot(12, 165);
    buildNeedle(needleU, cabinPressNeedle);

    subscribeToLedChange("PRESSURE_ALT", onPressureAltChange);
    subscribeToLedChange(BACKLIGHT_LABEL, onInstPanelDimmerChange);

    CabinPressureGauge_bitTest();

#if RUN_CABIN_PRESSURE_GAUGE_AS_TASK
#if defined(IS_S3_PINS)
    xTaskCreatePinnedToCore(CabinPressureGauge_task, "CabinPressureGaugeTask", 4096, nullptr, 2, &tftTaskHandle, 1);
#else
    xTaskCreatePinnedToCore(CabinPressureGauge_task, "CabinPressureGaugeTask", 4096, nullptr, 2, &tftTaskHandle, 0);
#endif
#endif

    debugPrintln("✅ Cabin Pressure Gauge (LovyanGFX, PSRAM double-buffered) initialized");
}

void CabinPressureGauge_loop() {
#if !RUN_CABIN_PRESSURE_GAUGE_AS_TASK
    CabinPressureGauge_draw(false);
#endif
}

void CabinPressureGauge_notifyMissionStart() { gaugeDirty = true; }

void CabinPressureGauge_bitTest()
{
    int16_t originalU = angleU;
    const int STEP = 25, DELAY = 2;

    for (int i = 0; i <= 306; i += STEP) {
        angleU = map(i, 0, 306, -181, 125);
        gaugeDirty = true; CabinPressureGauge_draw(true);
        vTaskDelay(pdMS_TO_TICKS(DELAY));
    }
    for (int i = 306; i >= 0; i -= STEP) {
        angleU = map(i, 0, 306, -181, 125);
        gaugeDirty = true; CabinPressureGauge_draw(true);
        vTaskDelay(pdMS_TO_TICKS(DELAY));
    }

    angleU = originalU;
    gaugeDirty = true; CabinPressureGauge_draw(true);
}

void CabinPressureGauge_deinit()
{
    needleU.deleteSprite();
    if (tftTaskHandle) { vTaskDelete(tftTaskHandle); tftTaskHandle = nullptr; }
    if (cabPressFrame) { PS_FREE(cabPressFrame); cabPressFrame = nullptr; }
}