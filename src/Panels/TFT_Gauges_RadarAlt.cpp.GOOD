// TFT_Gauges_RadarAlt.cpp - CockpitOS Radar Altimeter (LovyanGFX, ST77916/61 @ 360×360) - Double-buffered PSRAM, Flickerless

#define RADARALT_DRAW_MIN_INTERVAL_MS 100
#define RUN_RADARALT_AS_TASK 1
#define BACKLIGHT_LABEL "INST_PNL_DIMMER"
#define COLOR_DEPTH_RADARALT 16

#include "../Globals.h"
#include "../TFT_Gauges_RadarAlt.h"
#include "../HIDManager.h"
#include "../DCSBIOSBridge.h"
#include <LovyanGFX.hpp>
#include <cstring>

// --- Pins ---
#define RADARALT_MOSI_PIN   8
#define RADARALT_SCLK_PIN   9
#define RADARALT_DC_PIN    13
#define RADARALT_RST_PIN   -1
#define RADARALT_MISO_PIN  -1

// --- Assets ---
#include "Assets/RadarAltimeter/radarAltBackground.h"
#include "Assets/RadarAltimeter/radarAltNeedle.h"
#include "Assets/RadarAltimeter/radarAltMinHeightPointer.h"
#include "Assets/RadarAltimeter/radarAltMinHeightPointerNVG.h"
#include "Assets/RadarAltimeter/radarAltGreenLamp.h"
#include "Assets/RadarAltimeter/radarAltLowAltWarning.h"
#include "Assets/RadarAltimeter/radarAltOffFlag.h"
#include "Assets/RadarAltimeter/radarAltOffFlagNVG.h"
#include "Assets/RadarAltimeter/radarAltBackgroundNVG.h"
#include "Assets/RadarAltimeter/radarAltNeedleNVG.h"

// --- Misc ---
static constexpr bool shared_bus = false;
static constexpr bool use_lock = false;
static constexpr uint16_t TRANSPARENT_KEY = 0x2001;  // Use a color that is not in the gauge images
static constexpr uint16_t NVG_THRESHOLD = 6553;
static constexpr int16_t SCREEN_W = 360, SCREEN_H = 360;
static constexpr int16_t LOWALT_X = 95, LOWALT_Y = 158;
static constexpr int16_t GREEN_X = 229, GREEN_Y = 158;
static constexpr int16_t OFF_X = 152, OFF_Y = 254;
static constexpr int16_t CENTER_X = 180, CENTER_Y = 180;

// Radar Altimeter angles
static constexpr int16_t RA_ANGLE_MIN = -17;   // actual min angle, corresponds to "rest"
static constexpr int16_t RA_ANGLE_MAX = 325;   // actual max angle, corresponds to full scale

// Min Height Pointer angles
static constexpr int16_t MHP_ANGLE_MIN = -10;   // actual min angle, corresponds to "rest"
static constexpr int16_t MHP_ANGLE_MAX = 325;   // actual max angle, corresponds to full scale

// --- Panel binding ---
class LGFX_RadarAlt : public lgfx::LGFX_Device {
    lgfx::Bus_SPI     _bus;
    lgfx::Panel_ST77961 _panel;
public:
    LGFX_RadarAlt() {
        {
            auto cfg = _bus.config();
            cfg.spi_host = SPI2_HOST;
            cfg.spi_mode = 0;
            cfg.freq_write = 80000000;
            cfg.freq_read = 0;
            cfg.spi_3wire = false;
            cfg.use_lock = use_lock;
            cfg.dma_channel = 1;
            cfg.pin_mosi = RADARALT_MOSI_PIN;
            cfg.pin_miso = RADARALT_MISO_PIN;
            cfg.pin_sclk = RADARALT_SCLK_PIN;
            cfg.pin_dc = RADARALT_DC_PIN;
            _bus.config(cfg);
            _panel.setBus(&_bus);
        }
        {
            auto pcfg = _panel.config();
            pcfg.pin_cs = RADARALT_CS_PIN;
            pcfg.pin_rst = RADARALT_RST_PIN;
            pcfg.pin_busy = -1;
            pcfg.memory_width = SCREEN_W;
            pcfg.memory_height = SCREEN_H;
            pcfg.panel_width = SCREEN_W;
            pcfg.panel_height = SCREEN_H;
            pcfg.offset_x = 0;
            pcfg.offset_y = 0;
            pcfg.offset_rotation = 0;
            pcfg.bus_shared = shared_bus;
            pcfg.invert = true;
            pcfg.rgb_order = true;
            _panel.config(pcfg);
        }
        setPanel(&_panel);
    }
};

// --- State ---
static LGFX_RadarAlt tft;
static lgfx::LGFX_Sprite needle(&tft);
static lgfx::LGFX_Sprite pointerSpr(&tft);
static lgfx::LGFX_Sprite lowAltSpr(&tft);
static lgfx::LGFX_Sprite greenLampSpr(&tft);
static lgfx::LGFX_Sprite offFlagSpr(&tft);

static volatile int16_t angleRA = 0;   // 0..320
static volatile int16_t angleMHP = 0;  // 0..320
static volatile bool    lowAltOn = false;
static volatile bool    greenOn = false;
static volatile bool    offFlag = false;

static volatile int16_t lastDrawnRA = INT16_MIN;
static volatile int16_t lastDrawnMHP = INT16_MIN;
static volatile bool    gaugeDirty = false;
static volatile uint8_t currentLightingMode = 0;   // 0=Day, 2=NVG
static uint8_t          lastNeedleMode = 0xFF;
static uint8_t          lastPointerMode = 0xFF;
static uint8_t          lastOffFlagMode = 0xFF;
static unsigned long    lastDrawTime = 0;
static TaskHandle_t     tftTaskHandle = nullptr;

// --- PSRAM framebuffer ---
static uint16_t* radarAltFrame = nullptr;   // PSRAM buffer for whole gauge

// --- Sprite builder helpers ---
static void buildNeedle(lgfx::LGFX_Sprite & spr, const uint16_t * img) {
    spr.fillScreen(TRANSPARENT_KEY);
    spr.setSwapBytes(true);
    spr.pushImage(0, 0, 76, 173, img);
}

static void buildPointer(lgfx::LGFX_Sprite & spr, const uint16_t * img) {
    spr.fillScreen(TRANSPARENT_KEY);
    spr.setSwapBytes(true);
    spr.pushImage(0, 0, 23, 180, img);
}


static void buildLamp(lgfx::LGFX_Sprite & spr, const uint16_t * img, int w, int h) {
    spr.fillScreen(TRANSPARENT_KEY);
    spr.setSwapBytes(true);
    spr.pushImage(0, 0, w, h, img);
}

// --- DCS-BIOS callbacks ---
static void onRadarAltAngle(const char*, uint16_t v, uint16_t) {
    int16_t a = map(v, 0, 65535, RA_ANGLE_MIN, RA_ANGLE_MAX);
    if (a != angleRA) { angleRA = a; gaugeDirty = true; }
}
static void onMinHeightAngle(const char*, uint16_t v, uint16_t) {
    int16_t a = map(v, 0, 65535, MHP_ANGLE_MIN, MHP_ANGLE_MAX);
    if (a != angleMHP) { angleMHP = a; gaugeDirty = true; }
}
static void onLowAltLamp(const char*, uint16_t v, uint16_t) {
    bool on = (v != 0);
    if (on != lowAltOn) { lowAltOn = on; gaugeDirty = true; }
}
static void onGreenLamp(const char*, uint16_t v, uint16_t) {
    bool on = (v != 0);
    if (on != greenOn) { greenOn = on; gaugeDirty = true; }
}
static void onOffFlag(const char*, uint16_t v, uint16_t) {
    bool on = (v != 0);
    if (on != offFlag) { offFlag = on; gaugeDirty = true; }
}
static void onDimmerChange(const char*, uint16_t v, uint16_t) {
    uint8_t mode = (v > NVG_THRESHOLD) ? 2u : 0u;
    if (mode != currentLightingMode) { currentLightingMode = mode; gaugeDirty = true; }
}

// --- Double-buffered draw (zero flicker/tearing) ---
static void RadarAlt_draw(bool force = false) {
    if (!force && !isMissionRunning()) return;
    const unsigned long now = millis();

    int16_t ra = angleRA;
    if (ra < RA_ANGLE_MIN) ra = RA_ANGLE_MIN;
    else if (ra > RA_ANGLE_MAX) ra = RA_ANGLE_MAX;

    int16_t mhp = angleMHP;
    if (mhp < MHP_ANGLE_MIN) mhp = MHP_ANGLE_MIN;
    else if (mhp > MHP_ANGLE_MAX) mhp = MHP_ANGLE_MAX;

    const bool shouldDraw = force || gaugeDirty || (ra != lastDrawnRA) || (mhp != lastDrawnMHP);
    if (!shouldDraw) return;
    if (!force && (now - lastDrawTime < RADARALT_DRAW_MIN_INTERVAL_MS)) return;

    lastDrawTime = now;
    lastDrawnRA = ra; lastDrawnMHP = mhp;
    gaugeDirty = false;

    // assets
    const uint16_t* bg = (currentLightingMode == 0) ? radarAltBackground : radarAltBackgroundNVG;
    const uint16_t* nImg = (currentLightingMode == 0) ? radarAltNeedle : radarAltNeedleNVG;
    const uint16_t* ptrImg = (currentLightingMode == 0) ? radarAltMinHeightPointer : radarAltMinHeightPointerNVG;
    const uint16_t* flagImg = (currentLightingMode == 0) ? radarAltOffFlag : radarAltOffFlagNVG;

    if (lastNeedleMode != currentLightingMode) {
        buildNeedle(needle, nImg);
        lastNeedleMode = currentLightingMode;
    }

    if (lastPointerMode != currentLightingMode) {
        buildPointer(pointerSpr, ptrImg);
        lastPointerMode = currentLightingMode;
    }

    if (lastOffFlagMode != currentLightingMode) {
        buildLamp(offFlagSpr, flagImg, 51, 19);
        lastOffFlagMode = currentLightingMode;
    }

    // --- Compose full gauge into offscreen PSRAM buffer ---
    static lgfx::LGFX_Sprite frameSpr(&tft);
    if (frameSpr.width() != SCREEN_W || frameSpr.height() != SCREEN_H) {
        frameSpr.deleteSprite();
        frameSpr.setColorDepth(COLOR_DEPTH_RADARALT);
        frameSpr.setPsram(true);
        frameSpr.createSprite(SCREEN_W, SCREEN_H);
    }
    frameSpr.fillScreen(TFT_BLACK);
    frameSpr.setSwapBytes(false);
    frameSpr.pushImage(0, 0, SCREEN_W, SCREEN_H, bg);

    // Overlays (lamps, flag)
    if (greenOn)  greenLampSpr.pushRotateZoom(&frameSpr, GREEN_X, GREEN_Y, 0.0f, 1.0f, 1.0f, TRANSPARENT_KEY);
    if (lowAltOn) lowAltSpr.pushRotateZoom(&frameSpr, LOWALT_X, LOWALT_Y, 0.0f, 1.0f, 1.0f, TRANSPARENT_KEY);
    if (offFlag)  offFlagSpr.pushRotateZoom(&frameSpr, OFF_X, OFF_Y, 0.0f, 1.0f, 1.0f, TRANSPARENT_KEY);

    // Pointer then main needle
    pointerSpr.pushRotateZoom(&frameSpr, CENTER_X, CENTER_Y, (float)mhp, 1.0f, 1.0f, TRANSPARENT_KEY);
    needle.pushRotateZoom(&frameSpr, CENTER_X, CENTER_Y, (float)ra, 1.0f, 1.0f, TRANSPARENT_KEY);

    // Copy to PSRAM buffer, then push to screen (atomic DMA)
    if (radarAltFrame) {
        std::memcpy(radarAltFrame, frameSpr.getBuffer(), SCREEN_W * SCREEN_H * 2);

#if DEBUG_PERFORMANCE
        beginProfiling(PERF_TFT_RADARALT_DRAW);
#endif

        tft.startWrite();
        tft.pushImageDMA(0, 0, SCREEN_W, SCREEN_H, radarAltFrame);
        tft.endWrite();

#if DEBUG_PERFORMANCE
        endProfiling(PERF_TFT_RADARALT_DRAW);
#endif

    }

    // (Optional: keep frameSpr if RAM allows; otherwise, delete/recreate as above)
}

// --- Task ---
static void RadarAlt_task(void*) {
    for (;;) { RadarAlt_draw(false); vTaskDelay(pdMS_TO_TICKS(5)); }
}

// --- API ---
void RadarAlt_init() {
    if (!initPSRAM()) {
        debugPrintln("❌ No PSRAM detected! RadarAlt double-buffering disabled.");
        while (1) vTaskDelay(1000);  // or fallback to original routine
    }
    // PSRAM frame allocation
    if (!radarAltFrame) {
        radarAltFrame = (uint16_t*)PS_MALLOC(SCREEN_W * SCREEN_H * 2);
        if (!radarAltFrame) {
            debugPrintln("❌ PSRAM framebuffer alloc failed!");
            while (1) vTaskDelay(1000);
        }
    }

    tft.init();
    tft.setColorDepth(COLOR_DEPTH_RADARALT);
    tft.setRotation(0);
    tft.setSwapBytes(true);
    tft.fillScreen(TFT_BLACK);

    needle.setColorDepth(COLOR_DEPTH_RADARALT);
    needle.createSprite(76, 173);
    needle.setPivot(38, 134);
    buildNeedle(needle, radarAltNeedle);

    pointerSpr.setColorDepth(COLOR_DEPTH_RADARALT);
    pointerSpr.createSprite(23, 180);
    pointerSpr.setPivot(12, 180);
    buildPointer(pointerSpr, radarAltMinHeightPointer);

    lowAltSpr.setColorDepth(COLOR_DEPTH_RADARALT);
    lowAltSpr.createSprite(34, 34);
    lowAltSpr.setPivot(0, 0);
    buildLamp(lowAltSpr, radarAltLowAltWarning, 34, 34);

    greenLampSpr.setColorDepth(COLOR_DEPTH_RADARALT);
    greenLampSpr.createSprite(34, 34);
    greenLampSpr.setPivot(0, 0);
    buildLamp(greenLampSpr, radarAltGreenLamp, 34, 34);

    offFlagSpr.setColorDepth(COLOR_DEPTH_RADARALT);
    offFlagSpr.createSprite(51, 19);
    offFlagSpr.setPivot(0, 0);
    buildLamp(offFlagSpr, radarAltOffFlag, 51, 19);

    subscribeToLedChange("RADALT_ALT_PTR", onRadarAltAngle);
    subscribeToLedChange("RADALT_MIN_HEIGHT_PTR", onMinHeightAngle);
    subscribeToLedChange("LOW_ALT_WARN_LT", onLowAltLamp);
    subscribeToLedChange("RADALT_GREEN_LAMP", onGreenLamp);
    subscribeToLedChange("RADALT_OFF_FLAG", onOffFlag);
    subscribeToLedChange(BACKLIGHT_LABEL, onDimmerChange);

    RadarAlt_bitTest();

#if RUN_RADARALT_AS_TASK
#if defined(IS_S3_PINS)
    xTaskCreatePinnedToCore(RadarAlt_task, "RadarAltTask", 4096, nullptr, 2, &tftTaskHandle, 1);
#else
    xTaskCreatePinnedToCore(RadarAlt_task, "RadarAltTask", 4096, nullptr, 2, &tftTaskHandle, 0);
#endif
#endif

    debugPrintln("✅ Radar Altimeter (LovyanGFX, PSRAM double-buffered) initialized");
}

void RadarAlt_loop() {
#if !RUN_RADARALT_AS_TASK
    RadarAlt_draw(false);
#endif
}

void RadarAlt_notifyMissionStart() { gaugeDirty = true; }

void RadarAlt_bitTest() {
    int16_t savRA = angleRA, savMHP = angleMHP;
    bool savLow = lowAltOn, savGreen = greenOn, savOff = offFlag;

    const int STEP = 50, DELAY = 2;

    // Sweep up
    for (int i = 0; i <= 320; i += STEP) {
        angleRA = i;
        angleMHP = i;
        gaugeDirty = true; RadarAlt_draw(true);
        vTaskDelay(pdMS_TO_TICKS(DELAY));
    }
    // Sweep down
    for (int i = 320; i >= 0; i -= STEP) {
        angleRA = i;
        angleMHP = i;
        gaugeDirty = true; RadarAlt_draw(true);
        vTaskDelay(pdMS_TO_TICKS(DELAY));
    }

    lowAltOn = true;  greenOn = false; offFlag = false;
    gaugeDirty = true; RadarAlt_draw(true); vTaskDelay(pdMS_TO_TICKS(200));

    lowAltOn = false; greenOn = true;  offFlag = false;
    gaugeDirty = true; RadarAlt_draw(true); vTaskDelay(pdMS_TO_TICKS(200));

    lowAltOn = false; greenOn = false; offFlag = true;
    gaugeDirty = true; RadarAlt_draw(true); vTaskDelay(pdMS_TO_TICKS(200));

    lowAltOn = true;  greenOn = true;  offFlag = true;
    gaugeDirty = true; RadarAlt_draw(true); vTaskDelay(pdMS_TO_TICKS(400));

    // Restore
    angleRA = savRA; angleMHP = savMHP;
    lowAltOn = savLow; greenOn = savGreen; offFlag = savOff;
    gaugeDirty = true; RadarAlt_draw(true);
}

void RadarAlt_deinit() {
    needle.deleteSprite();
    pointerSpr.deleteSprite();
    lowAltSpr.deleteSprite();
    greenLampSpr.deleteSprite();
    offFlagSpr.deleteSprite();
    if (tftTaskHandle) { vTaskDelete(tftTaskHandle); tftTaskHandle = nullptr; }
    if (radarAltFrame) { PS_FREE(radarAltFrame); radarAltFrame = nullptr; }
}