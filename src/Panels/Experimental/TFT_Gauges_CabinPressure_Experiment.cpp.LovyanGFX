// CockpitOS ‚Äî Battery Gauge (LovyanGFX)
// Drop-in replacement for the TFT_eSPI version you shared.
// - GC9A01 @ ESP32-S2 (SPI, your pins)
// - Day/NVG backgrounds, dual needles
// - 30 Hz min draw interval; FreeRTOS optional
// - Same DCS-BIOS labels ("VOLT_U", "VOLT_E"), same lighting handling

#define GAUGE_DRAW_MIN_INTERVAL_MS 30   // 30Hz
#define RUN_GAUGE_AS_TASK 1

#include "../Globals.h"
#include "../TFT_Gauges.h"
#include "../HIDManager.h"
#include "../DCSBIOSBridge.h"

#include <Arduino.h>
#include <LovyanGFX.hpp>

// NVG TFT images
#include "Assets/BatteryGauge/batBackgroundNVG.h"
#include "Assets/BatteryGauge/batNeedleNVG.h"
// Day TFT images
#include "Assets/BatteryGauge/batBackground.h"
#include "Assets/BatteryGauge/batNeedle.h"

// ---------------------- Panel binding (LovyanGFX, ST77916/61) ----------------------
class LGFX : public lgfx::LGFX_Device {
    lgfx::Bus_SPI _bus;
    lgfx::Panel_ST77961 _panel;          // <-- Use the built-in driver
public:
    LGFX() {
        { // Bus config
            auto cfg = _bus.config();
            cfg.spi_host = SPI2_HOST;
            cfg.spi_mode = 0;
            cfg.freq_write = 80000000;
            cfg.freq_read = 16000000;
            cfg.spi_3wire = false;
            cfg.use_lock = true;
            cfg.dma_channel = 1;
            // --- PIN DEFINES (ST77916 panel) ---
            cfg.pin_mosi = 11;
            cfg.pin_miso = -1;
            cfg.pin_sclk = 12;
            cfg.pin_dc = 13;
            _bus.config(cfg);
            _panel.setBus(&_bus);
        }
        { // Panel config
            auto pcfg = _panel.config();
            pcfg.pin_cs = 10;
            pcfg.pin_rst = 14;      // Use -1 if not connected
            pcfg.pin_busy = -1;
            pcfg.memory_width = 360;
            pcfg.memory_height = 360;
            pcfg.panel_width = 360;
            pcfg.panel_height = 360;
            pcfg.offset_x = 0;
            pcfg.offset_y = 0;
            pcfg.offset_rotation = 0;
            pcfg.invert = true;         // <-- ESSENTIAL!
            pcfg.rgb_order = true;      // <-- ESSENTIAL!
            _panel.config(pcfg);
        }
        setPanel(&_panel);
    }
};

// ----------------------------------------------------------------------
// State (mirrors your original module)  // :contentReference[oaicite:5]{index=5}
static LGFX tft;
static lgfx::LGFX_Sprite needleU(&tft);
static lgfx::LGFX_Sprite needleE(&tft);

static constexpr uint8_t  COLOR_DEPTH = 16;

// static constexpr int16_t  CENTER_X = 120;
// static constexpr int16_t  CENTER_Y = 120;

static constexpr int16_t  CENTER_X = 180;
static constexpr int16_t  CENTER_Y = 180;

static constexpr uint16_t TRANSPARENT_KEY = 0x0120;

// Optional PSRAM copies of the backgrounds (kept to match your file; not strictly required)
static uint16_t* psramBackgroundDay = nullptr;
static uint16_t* psramBackgroundNVG = nullptr;

static volatile int16_t angleU = 0, angleE = 0;
static volatile int16_t lastDrawnAngleU = INT16_MIN, lastDrawnAngleE = INT16_MIN;
static volatile bool    gaugeDirty = false;
static uint8_t          currentLightingMode = 0;  // 0=Day, 2=NVG (your code normalizes 1->2)
static unsigned long    lastDrawTime = 0;

static TaskHandle_t tftTaskHandle = nullptr;

// Chip-select gating (your board-level CS for shared bus)
static inline void BatteryGauge_CS_ON() { digitalWrite(BATTERY_CS_PIN, LOW); }
static inline void BatteryGauge_CS_OFF() { digitalWrite(BATTERY_CS_PIN, HIGH); }

static void BatteryGauge_draw(bool force = false);
static void BatteryGauge_task(void*);

// ----------- Helpers: build masked needle sprite then rotate/blit -----------
// We treat the needle image's (0,0) color as "background" to be masked out.
static void buildNeedle(lgfx::LGFX_Sprite& spr, const uint16_t* img)
{
    spr.fillScreen(TRANSPARENT_KEY);
    spr.setSwapBytes(false);           // <‚Äî keep needle values as-is (0x0120 stays 0x0120)
    spr.pushImage(0, 0, 15, 88, img);  // white (0xFFFF) and key (0x0120) copied verbatim
}

// ------------------------------ DCS-BIOS hooks ------------------------------
static void onBatVoltUChange(const char*, uint16_t value, uint16_t)
{
    int16_t newAngleU = map(value, 0, 65535, -150, -30);
    if (newAngleU != angleU) { angleU = newAngleU; gaugeDirty = true; }
}
static void onBatVoltEChange(const char*, uint16_t value, uint16_t)
{
    int16_t newAngleE = map(value, 0, 65535, 150, 30);
    if (newAngleE != angleE) { angleE = newAngleE; gaugeDirty = true; }
}

// ------------------------------ Core drawing -------------------------------
// Background is pushed directly to the panel; needles rotate+overlay with colorkey.
static void BatteryGauge_draw(bool force)
{
    // Mission gating / init checks
    if (!force && !isMissionRunning()) return;

    const unsigned long now = millis();

    // Snapshot angles once for atomicity (like your original)
    const int16_t u = angleU;
    const int16_t e = angleE;

    const bool shouldDraw = force
        || gaugeDirty
        || (u != lastDrawnAngleU || e != lastDrawnAngleE);

    if (!shouldDraw) return;
    if (!force && (now - lastDrawTime < GAUGE_DRAW_MIN_INTERVAL_MS)) return;

    lastDrawTime = now;
    lastDrawnAngleU = u;
    lastDrawnAngleE = e;
    gaugeDirty = false;

#if DEBUG_PERFORMANCE
    beginProfiling(PERF_TFT_DRAW);
#endif

#if DEBUG_ENABLED
    debugPrintf("üîã LGFX draw: U=%d, E=%d, mode=%d\n", u, e, currentLightingMode);
#endif

    // Select assets by lighting
    const uint16_t* bg = (currentLightingMode == 0) ? (psramBackgroundDay ? psramBackgroundDay : batBackground)
        : (psramBackgroundNVG ? psramBackgroundNVG : batBackgroundNVG);
    const uint16_t* activeNeedle = (currentLightingMode == 0) ? batNeedle : batNeedleNVG;

    // Derive "mask" color from pixel (0,0) of the needle image (typical sprite background color)
    const uint16_t maskColor = activeNeedle[0];

    // Build needle sprites with transparency
    needleU.setSwapBytes(false);
    needleE.setSwapBytes(false);

    buildNeedle(needleU, activeNeedle);
    buildNeedle(needleE, activeNeedle);

    // Draw
    BatteryGauge_CS_ON();
    tft.startWrite();
    tft.setSwapBytes(true);                        // images are in RGB565 little-endian
    // tft.pushImage(0, 0, 240, 240, bg);            // draw static background first
    tft.pushImage(60, 60, 240, 240, bg);


    // Rotate + overlay needles (center at gauge center)
    // transparent blend when rotating:
    needleU.pushRotateZoom(&tft, CENTER_X, CENTER_Y, (float)u, 1.0f, 1.0f, TRANSPARENT_KEY);
    needleE.pushRotateZoom(&tft, CENTER_X, CENTER_Y, (float)e, 1.0f, 1.0f, TRANSPARENT_KEY);

    tft.endWrite();
    BatteryGauge_CS_OFF();

#if DEBUG_PERFORMANCE
    endProfiling(PERF_TFT_DRAW);
#endif
}

// ----------------------------- FreeRTOS task -------------------------------
static void BatteryGauge_task(void*)
{
    for (;;) {
        BatteryGauge_draw(false);
        vTaskDelay(pdMS_TO_TICKS(5));
    }
}

// ----------------------------- Lighting control ----------------------------
static void onBatteryGaugeLightingChange(const char*, uint16_t value)
{
    // Normalize like your original: 0=Day, 1/2 => NVG
    const uint8_t normalized = (value == 0) ? 0 : 2;
    if (normalized == currentLightingMode) return;
    currentLightingMode = normalized;
#if DEBUG_ENABLED
    debugPrintf("‚öôÔ∏è LGFX lighting=%s\n", currentLightingMode == 0 ? "DAY" : "NVG");
#endif
    gaugeDirty = true;
    BatteryGauge_draw(true);
}

// --------------------------------- API -------------------------------------
void BatteryGauge_setLightingMode(uint8_t mode)
{
    onBatteryGaugeLightingChange(nullptr, mode);
}

void BatteryGauge_init()
{
#if DEBUG_PERFORMANCE
    beginProfiling(PERF_TFT_INIT);
#endif

    pinMode(BATTERY_CS_PIN, OUTPUT);
    BatteryGauge_CS_OFF();

    // Optional: keep your PSRAM background copy (fast DMA-friendly pointer if you prefer)
    psramBackgroundDay = (uint16_t*)PS_MALLOC(batBackgroundLen * sizeof(uint16_t));
    psramBackgroundNVG = (uint16_t*)PS_MALLOC(batBackgroundLen * sizeof(uint16_t));
    if (psramBackgroundDay && psramBackgroundNVG) {
        memcpy(psramBackgroundDay, batBackground, batBackgroundLen * sizeof(uint16_t));
        memcpy(psramBackgroundNVG, batBackgroundNVG, batBackgroundLen * sizeof(uint16_t));
        debugPrintln("[PSRAM] ‚úÖ Day/NVG backgrounds copied to PSRAM");
    }
    else {
        debugPrintln("[PSRAM] ‚ö†Ô∏è Using PROGMEM backgrounds (copy failed or not desired)");
    }

    // Panel init
    tft.init();
    
    tft.setColorDepth(16);             // explicit
    needleU.setColorDepth(16);
    needleE.setColorDepth(16);
    
    // If you prefer, you can also set a built-in chroma key:
    // needleU.setColorKey(TRANSPARENT_KEY);
    // needleE.setColorKey(TRANSPARENT_KEY);


    tft.setRotation(0);
    tft.setSwapBytes(true);
    tft.fillScreen(TFT_BLACK);

    // Small needle sprites only (stack/heap footprint tiny; 15x88x2 bytes ‚âà 2.6 KB each)
    needleU.setColorDepth(COLOR_DEPTH);
    needleU.createSprite(15, 88);
    needleU.setPivot(7, 84);

    needleE.setColorDepth(COLOR_DEPTH);
    needleE.createSprite(15, 88);
    needleE.setPivot(7, 84);

    // DCS-BIOS subscriptions preserved  // :contentReference[oaicite:7]{index=7}
    subscribeToLedChange("VOLT_U", onBatVoltUChange);
    subscribeToLedChange("VOLT_E", onBatVoltEChange);
    subscribeToSelectorChange("COCKKPIT_LIGHT_MODE_SW", onBatteryGaugeLightingChange);

#if RUN_GAUGE_AS_TASK
    // Same core pinning approach as your file (S2 vs S3)
#if defined(IS_S3_PINS)
    xTaskCreatePinnedToCore(BatteryGauge_task, "BatteryGaugeTask", 4096, nullptr, 2, &tftTaskHandle, 1);
#else
    xTaskCreatePinnedToCore(BatteryGauge_task, "BatteryGaugeTask", 4096, nullptr, 2, &tftTaskHandle, 0);
#endif
#endif

    // Optional BIT sweep identical to your original  // :contentReference[oaicite:8]{index=8}
    BatteryGauge_bitTest();
    debugPrintln("‚úÖ BatteryGauge (LovyanGFX) initialized");
#if DEBUG_PERFORMANCE
    endProfiling(PERF_TFT_INIT);
#endif
}

void BatteryGauge_loop()
{
#if !RUN_GAUGE_AS_TASK
    BatteryGauge_draw(false);
#endif
}

void BatteryGauge_notifyMissionStart()
{
    gaugeDirty = true;
    BatteryGauge_draw(true);
}

void BatteryGauge_bitTest()
{
#if DEBUG_PERFORMANCE
    beginProfiling(PERF_TFT_BITTEST);
#endif

    int16_t originalU = angleU;
    int16_t originalE = angleE;

    // Sweep inward
    for (int i = 0; i <= 120; i += 5) {
        angleU = map(i, 0, 120, -150, -30);
        angleE = map(i, 0, 120, 150, 30);
        gaugeDirty = true; BatteryGauge_draw(true);
        vTaskDelay(pdMS_TO_TICKS(10));
    }
    // Sweep outward
    for (int i = 120; i >= 0; i -= 5) {
        angleU = map(i, 0, 120, -150, -30);
        angleE = map(i, 0, 120, 150, 30);
        gaugeDirty = true; BatteryGauge_draw(true);
        vTaskDelay(pdMS_TO_TICKS(10));
    }

    // parked state
    angleU = -150; angleE = 150;
    gaugeDirty = true; BatteryGauge_draw(true);

#if DEBUG_PERFORMANCE
    endProfiling(PERF_TFT_BITTEST);
#endif
}

void BatteryGauge_deinit()
{
    needleU.deleteSprite();
    needleE.deleteSprite();

    if (tftTaskHandle) {
        vTaskDelete(tftTaskHandle);
        tftTaskHandle = nullptr;
    }

    if (psramBackgroundDay) { PS_FREE(psramBackgroundDay);  psramBackgroundDay = nullptr; }
    if (psramBackgroundNVG) { PS_FREE(psramBackgroundNVG);  psramBackgroundNVG = nullptr; }
}
