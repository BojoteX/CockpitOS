// Main CockpitOS.ino

/*

    DO NOT EDIT THIS FILE!!!
    Check the README.md and Tutorials inside the corresponding directories

*/

/*
#include "esp_log.h"
extern "C" int _sink_vprintf(const char*, va_list) { return 0; }
__attribute__((constructor)) static void silence_logs(void) {
  esp_log_level_set("*", ESP_LOG_NONE);     // kill ESP-IDF logs
  esp_log_set_vprintf(&_sink_vprintf);      // swallow any printf-backed logging
}
*/

#include "src/Globals.h" // Common header used by everyone
#include "src/HIDManager.h" // Needed for _init and _loop for HIDManager
#include "src/DCSBIOSBridge.h" // Needed for _init and _loop for DCSBIOSBridge
#include "src/HIDManager.h" // Needed for MAX_GROUPS check
#include "src/LEDControl.h" // Needed to initialize LEDs from our main .ino file

#if DEBUG_USE_WIFI || USE_DCSBIOS_WIFI
#include "src/WiFiDebug.h" // Only WiFi
#endif

#if USE_DCSBIOS_BLUETOOTH
#include "src/BLEManager.h" // Only BLE (Bluetooth)
#endif

// Keep track when the main loop starts
volatile bool mainLoopStarted = false;

// Force compilation of all CUtils internals (Arduino IDE won't compile .cpps in lib automatically)
#include "lib/CUtils/src/CUtils.cpp"

// Checks mode selector state
bool isModeSelectorDCS() {
  #if defined(HAS_HID_MODE_SELECTOR) && (HAS_HID_MODE_SELECTOR == 1)
    return digitalRead(MODE_SWITCH_PIN) == LOW;
  #else
    #if MODE_DEFAULT_IS_HID
        return false;
    #else
        return true;
    #endif
  #endif
}

void checkHealth() {
  // --- Internal SRAM (on-chip) ---
  size_t free_int    = heap_caps_get_free_size         (MALLOC_CAP_INTERNAL);
  size_t largest_int = heap_caps_get_largest_free_block(MALLOC_CAP_INTERNAL);
  float  frag_int    = free_int
                     ? 100.0f * (1.0f - (float)largest_int / (float)free_int)
                     : 0.0f;

  // --- External PSRAM (if present) ---
  size_t free_psram    = heap_caps_get_free_size         (MALLOC_CAP_SPIRAM);
  size_t largest_psram = heap_caps_get_largest_free_block(MALLOC_CAP_SPIRAM);
  float  frag_psram    = free_psram
                       ? 100.0f * (1.0f - (float)largest_psram / (float)free_psram)
                       : 0.0f;

  // --- Print it all out ---
  debugPrintf(
    "SRAM free: %6u KB, largest: %6u KB, frag: %5.1f%%\n",
    (unsigned)(free_int    / 1024),
    (unsigned)(largest_int / 1024),
    frag_int
  );

  debugPrintf(
    "PSRAM free: %6u KB, largest: %6u KB, frag: %5.1f%%\n",
    (unsigned)(free_psram    / 1024),
    (unsigned)(largest_psram / 1024),
    frag_psram
  );

  if (getMaxUsedGroup() >= MAX_GROUPS) {
      debugPrintln("❌ Too many unique selector groups — increase MAX_GROUPS in Config.h");
      while (true); // or handle as needed
  }

}

void setup() {

    // Only do this if we have a selector
    #if defined(HAS_HID_MODE_SELECTOR) && (HAS_HID_MODE_SELECTOR == 1)
    pinMode(MODE_SWITCH_PIN, INPUT_PULLUP); // GPIO Setup
    #endif

    // First parameter is output to Serial, second one is output to UDP (only use this for overriding output)
    debugInit();
    debugSetOutput(debugToSerial, debugToUDP);   

    // Sets standard read resolution and attenuation
    analogReadResolution(12); // (0-4095)
    analogSetAttenuation(ADC_11db);  
    
    // Init our CDC + HID Interfaces
    HIDManager_setup();     // We get HID started here 
    DCSBIOSBridge_setup();  // We get CDC started here    

    // Start USB (After Serial.begin and USBSerial.begin)
    if (loadUSBevents || loadCDCevents)
        HIDManager_startUSB();

    // Let USB enumerate and Serial start
    delay(3000);

    // WiFi needs to load AFTER HIDManager and DCSBIOSBridge setup. If you need to debug messages during that stage, enable WIFI_DEBUG_USE_RINGBUFFER in Config.h 
    #if DEBUG_USE_WIFI || USE_DCSBIOS_WIFI
    wifi_setup();
    #endif  

    #if USE_DCSBIOS_BLUETOOTH
    BLE_setup();
    #endif

    // Display Buffer registrations, Register tracked selectors and command history sync from inputmappings
    DCSBIOSBridge_postSetup();

    #if USE_DCSBIOS_WIFI
      if (!isModeSelectorDCS()) {
        debugPrintln("❌ FATAL: Invalid configuration! USE_DCSBIOS_WIFI requires DCS-BIOS mode, not HID");
        while (true) {}  // halt
      }
    #endif

    // Shows available mem/heap frag etc.
    checkHealth();   
    debugPrintln();

    // Init PCA + Detect PCA Panels (Automatic PCA detection)   
    #if ENABLE_PCA9555 
    PCA9555_init();
    #else
    debugPrintln("[PCA9555] ⚠️ PCA Functionality is currently DISABLED, to ENABLE please set ENABLE_PCA9555 to 1 in Config.h");
    #endif   

    initMappings(); // PCA Init Mappings (Aircraft specific) this should ALWAYS run first before all other inits

    // If you set DEBUG_ENABLED or DEBUG_ENABLED_FOR_PCA_ONLY you get PCA9555 logging
  #if DEBUG_ENABLED_FOR_PCA_ONLY 
    enablePCA9555Logging(1);
  #else  
    enablePCA9555Logging(DEBUG); // If you set DEBUG_ENABLED only it will also log PCA, otherwise no PCA logging.
  #endif

    // Initialize PCA9555 Inputs + Cached Port States explicitly to OFF (active-low LEDs)
    #if ENABLE_PCA9555 
    PCA9555_initCache(); 
    #endif  

    // Initializes your Displays etc. 
    debugPrintln("Initializing Displays");
    initializeDisplays();

    // Initializes your LEDs
    debugPrintln("Initializing LEDs");
    initializeLEDs();

    // Initializes you panel buttons (forced)
    initializePanels(1); // Force panel init (they only sync in the main loop unless we pass 1/true)
    
    // When TEST_LEDS is active device enters a menu selection to test LEDs individually. You activate them via Serial Console
    #if TEST_LEDS
        printLEDMenu();
        handleLEDSelection();
        debugPrintln("Exiting LED selection menu. Continuing execution...");
    #endif 
    
    // A loopback stream test that feeds the parser with simulated DCS data while leaving the Serial console available for debugging
    #if IS_REPLAY
    replayData();
    #endif

    #if DEBUG_PERFORMANCE
    initPerfMonitor(); // this is used for profiling, see PerfMonitor.h for details, format and how to add LABELS for profiling blocks
    #endif     

    if(DEBUG) {
        debugPrintf("Device \"%s\" is ready and DEBUG is active\n", USB_SERIAL);
        if (!isModeSelectorDCS()) {
            debugPrintln("(HID mode selected)");
        }
        else {
            debugPrintln("(DCS-BIOS mode selected)");
        }          
    }
    else {
        debugPrintf("Device \"%s\" is ready\n", USB_SERIAL);
        if (!isModeSelectorDCS()) {
            debugPrintln("(HID mode selected)");
        }
        else {
            debugPrintln("(DCS-BIOS mode selected)");
        }  
    }    

    // What Arduino ESP32 was this compiled with?
    debugPrintf("ESP32 Arduino core v%d.%d.%d  |  IDF v%d.%d.%d\n", 
      ESP_ARDUINO_VERSION_MAJOR, ESP_ARDUINO_VERSION_MINOR, ESP_ARDUINO_VERSION_PATCH, 
      ESP_IDF_VERSION_MAJOR, ESP_IDF_VERSION_MINOR, ESP_IDF_VERSION_PATCH);

  #if SOC_USB_OTG_SUPPORTED
    debugPrint("(USB OTG Supported)\n");
  #else
    debugPrint("(USB OTG NOT Supported)\n");
  #endif

    #if USE_DCSBIOS_USB
      debugPrintln("[USB] USB mode enabled. Run CockpitOS_HID_Manager.py inside HID Controller directory");
      #if (USE_DCSBIOS_SERIAL || VERBOSE_MODE_SERIAL_ONLY || VERBOSE_MODE) 
        debugPrintln("[WARNING] ⚠️ Serial is also enabled! do NOT use USB + Serial concurrently as its completely unstable");
      #endif
    #elif USE_DCSBIOS_BLUETOOTH
      debugPrintln("[BLUETOOTH] BLE (Bluetooth) enabled. Run CockpitOS_HID_Manager.py inside HID Controller directory");
    #elif USE_DCSBIOS_WIFI
      debugPrintf("[WiFi] WiFi mode enabled. Connected to %s\n", WIFI_SSID);
    #elif USE_DCSBIOS_SERIAL
      debugPrintln("[Serial] Serial CDC enabled. Run 'connect-serial-port.cmd' (socat) to connect.");
    #endif

    #if ARDUINO_USB_MODE
      debugPrintf("CDC Mode is 'Hardware CDC / JTAG' | ARDUINO_USB_MODE=%d, ARDUINO_USB_CDC_ON_BOOT=%d\n", ARDUINO_USB_MODE, ARDUINO_USB_CDC_ON_BOOT);
    #else
      debugPrintf("CDC Mode is 'USB-OTG (TinyUSB)' | ARDUINO_USB_MODE=%d, ARDUINO_USB_CDC_ON_BOOT=%d\n", ARDUINO_USB_MODE, ARDUINO_USB_CDC_ON_BOOT);
    #endif
}

void loop() {

    if(!mainLoopStarted) {
      debugPrintln("🔌 Main Loop started");
      // This is a dummy report, it will only run ONCE (when loop starts) to trigger a Feature request to our device when USE_DCSBIOS_USB is active to do an initial drain of our ring buffer to allow the USB handshake to happen
      HIDManager_dispatchReport(true);
    }    
    mainLoopStarted = true;

    // Performance Profiling using beginProfiling("name") -> endProfiling("name") but only when DEBUG_PERFORMANCE  
    #if DEBUG_PERFORMANCE
    beginProfiling(PERF_MAIN_LOOP);
    #endif

    // Loop logic/order
    panelLoop();           // read inputs, update mappings
    CoverGate_loop();      // resolve cover/armed actions
    DCSBIOSBridge_loop();  // flush DCS (sees freshly queued actions)
    HIDManager_loop();     // HID flush, keep-alive, pulses

    #if USE_DCSBIOS_BLUETOOTH
    BLE_loop();
    #endif

    // All profiling blocks REQUIRE we close them
    #if DEBUG_PERFORMANCE
    endProfiling(PERF_MAIN_LOOP);
    #endif

    // If you are profiling in a self contained block outside of the main loop, use perfMonitorUpdate() to simulate iterations.
    #if DEBUG_PERFORMANCE
    perfMonitorUpdate();
    #endif   
}