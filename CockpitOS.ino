// Main CockpitOS.ino

/*

    DO NOT EDIT THIS FILE!!!
    Check the README.md and Tutorials inside the corresponding directories

*/

#include "src/Globals.h" // Common header used by everyone
#include "src/HIDManager.h" // Needed for _init and _loop for HIDManager
#include "src/DCSBIOSBridge.h" // Needed for _init and _loop for DCSBIOSBridge
#include "src/HIDManager.h" // Needed for MAX_GROUPS check
#include "src/LEDControl.h" // Needed to initialize LEDs from our main .ino file

#if DEBUG_USE_WIFI || USE_DCSBIOS_WIFI
#include "src/WiFiDebug.h" // Only WiFi
#endif

// Keep track when the main loop starts
volatile bool mainLoopStarted = false;

// Force compilation of all CUtils internals (Arduino IDE won't compile .cpps in lib automatically)
#include "lib/CUtils/src/CUtils.cpp"

// Checks mode selector state
bool isModeSelectorDCS() {
  #if defined(HAS_HID_MODE_SELECTOR) && (HAS_HID_MODE_SELECTOR == 1)
    return digitalRead(MODE_SWITCH_PIN) == LOW;
  #else
    #if MODE_DEFAULT_IS_HID
        return false;
    #else
        return true;
    #endif
  #endif
}

void checkHealth() {
  // --- Internal SRAM (on-chip) ---
  size_t free_int    = heap_caps_get_free_size         (MALLOC_CAP_INTERNAL);
  size_t largest_int = heap_caps_get_largest_free_block(MALLOC_CAP_INTERNAL);
  float  frag_int    = free_int
                     ? 100.0f * (1.0f - (float)largest_int / (float)free_int)
                     : 0.0f;

  // --- External PSRAM (if present) ---
  size_t free_psram    = heap_caps_get_free_size         (MALLOC_CAP_SPIRAM);
  size_t largest_psram = heap_caps_get_largest_free_block(MALLOC_CAP_SPIRAM);
  float  frag_psram    = free_psram
                       ? 100.0f * (1.0f - (float)largest_psram / (float)free_psram)
                       : 0.0f;

  // --- Print it all out ---
  debugPrintf(
    "SRAM free: %6u KB, largest: %6u KB, frag: %5.1f%%\n",
    (unsigned)(free_int    / 1024),
    (unsigned)(largest_int / 1024),
    frag_int
  );

  debugPrintf(
    "PSRAM free: %6u KB, largest: %6u KB, frag: %5.1f%%\n",
    (unsigned)(free_psram    / 1024),
    (unsigned)(largest_psram / 1024),
    frag_psram
  );

  if (getMaxUsedGroup() >= MAX_GROUPS) {
      debugPrintln("❌ Too many unique selector groups — increase MAX_GROUPS in Config.h");
      while (true); // or handle as needed
  }

}

void setup() {

    // Only do this if we have a selector
    #if defined(HAS_HID_MODE_SELECTOR) && (HAS_HID_MODE_SELECTOR == 1)
    pinMode(MODE_SWITCH_PIN, INPUT_PULLUP); // GPIO Setup
    #endif

    // First parameter is output to Serial, second one is output to UDP (only use this for overriding output)
    debugInit();
    debugSetOutput(debugToSerial, debugToUDP);  

    // Sets standard read resolution and attenuation
    analogReadResolution(13); // Only value consistent across Arduino Core installs 2.0+ / 3.0+ (0-8191)
    analogSetAttenuation(ADC_11db);      

    // Init our CDC + HID Interfaces
    DCSBIOSBridge_setup();  // We get CDC started here    
    HIDManager_setup();     // We get HID started here 

    #if DEBUG_USE_WIFI || USE_DCSBIOS_WIFI
    wifi_setup();
    #endif

    debugPrintln("\n=================== [STARTING DEVICE] ===================");

    // Shows available mem/heap frag etc.
    checkHealth();   
    debugPrintln();

    // Init PCA + Detect PCA Panels (Automatic PCA detection)    
    PCA9555_init();
    
    // Init Mappings (Aircraft specific) this should ALWAYS run first before all other inits
    initMappings();   

    // If you set DEBUG_ENABLED or DEBUG_ENABLED_FOR_PCA_ONLY you get PCA9555 logging
  #if DEBUG_ENABLED_FOR_PCA_ONLY
    enablePCA9555Logging(1);
  #else  
    enablePCA9555Logging(DEBUG); // If you set DEBUG_ENABLED only it will also log PCA, otherwise no PCA logging.
  #endif

    // Initialize PCA9555 Inputs + Cached Port States explicitly to OFF (active-low LEDs)
    PCA9555_initCache();   

    // Initializes your Displays etc. 
    debugPrintln("Initializing Displays");
    initializeDisplays();

    // Initializes your LEDs
    debugPrintln("Initializing LEDs");
    initializeLEDs();

    // Initializes you panel buttons (forced)
    initializePanels(1); // Force panel init (they only sync in the main loop unless we pass 1/true)
    
    // When TEST_LEDS is active device enters a menu selection to test LEDs individually. You activate them via Serial Console
    #if TEST_LEDS
        printLEDMenu();
        handleLEDSelection();
        debugPrintln("Exiting LED selection menu. Continuing execution...");
    #endif 
    
    // A loopback stream test that feeds the parser with simulated DCS data while leaving the Serial console available for debugging
    #if IS_REPLAY
    replayData();
    #endif

    #if DEBUG_PERFORMANCE
    initPerfMonitor(); // this is used for profiling, see PerfMonitor.h for details, format and how to add LABELS for profiling blocks
    #endif     

    if(DEBUG) {
        debugPrintf("Device \"%s\" is ready and DEBUG is active ", USB_SERIAL);
        if (!isModeSelectorDCS()) {
            debugPrintln("(HID mode selected)");
        }
        else {
            debugPrintln("(DCS-BIOS mode selected)");
        }          
    }
    else {
        debugPrintf("Device \"%s\" is ready ", USB_SERIAL);
        if (!isModeSelectorDCS()) {
            debugPrintln("(HID mode selected)");
        }
        else {
            debugPrintln("(DCS-BIOS mode selected)");
        }  
    }    

    // What Arduino ESP32 was this compiled with?
    debugPrintf("ESP32 Arduino core v%d.%d.%d  |  IDF v%d.%d.%d  |  ", 
      ESP_ARDUINO_VERSION_MAJOR, ESP_ARDUINO_VERSION_MINOR, ESP_ARDUINO_VERSION_PATCH, 
      ESP_IDF_VERSION_MAJOR, ESP_IDF_VERSION_MINOR, ESP_IDF_VERSION_PATCH);

  // Works across all boards of the same chip family
  #if defined(CONFIG_IDF_TARGET_ESP32C3)
    #define ESP_FAMILY_C3 1
    debugPrint("ESP32 Variant is C3 ");
  #elif defined(CONFIG_IDF_TARGET_ESP32S2)
    #define ESP_FAMILY_S2 1
    debugPrint("ESP32 Variant is S2 ");
  #elif defined(CONFIG_IDF_TARGET_ESP32S3)
    #define ESP_FAMILY_S3 1
    debugPrint("ESP32 Variant is S3 ");
  #elif defined(CONFIG_IDF_TARGET_ESP32)
    #define ESP_FAMILY_CLASSIC 1
    debugPrint("ESP32 Classic Variant ");
  #else
    debugPrint("ESP32 Variant is Unknown ");
  #endif

  #if SOC_USB_OTG_SUPPORTED
    debugPrintln("(USB OTG Supported)");
  #else
    debugPrintln("(USB OTG NOT Supported)\n");
  #endif

    #if USE_DCSBIOS_USB
    debugPrintln("ATTENTION: USB mode ENABLED. Run CockpitOS_HID_Controller.py on the computer where your devices are connected.");
    #endif
}

void loop() {

    if(!mainLoopStarted) {
      debugPrintln("🔌 Main Loop started");
      // This is a dummy report, it will only run ONCE (when loop starts) to trigger a Feature request to our device when USE_DCSBIOS_USB is active to do an initial drain of our ring buffer to allow the USB handshake to happen
      HIDManager_dispatchReport(true);
    }
    mainLoopStarted = true;

    // Performance Profiling using beginProfiling("name") -> endProfiling("name") but only when DEBUG_PERFORMANCE  
    #if DEBUG_PERFORMANCE
    beginProfiling(PERF_MAIN_LOOP);
    #endif

    // Call our panels loop logic (Mappings.cpp is where this function lives)
    panelLoop(); // Main Panels loop
    DCSBIOSBridge_loop(); // DCSBios Logic loop
    HIDManager_loop();  // HIDManager Logic loop

    // All profiling blocks REQUIRE we close them
    #if DEBUG_PERFORMANCE
    endProfiling(PERF_MAIN_LOOP);
    #endif

    // If you are profiling in a self contained block outside of the main loop, use perfMonitorUpdate() to simulate iterations.
    #if DEBUG_PERFORMANCE
    perfMonitorUpdate();
    #endif   
}