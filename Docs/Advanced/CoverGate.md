# CoverGate System

Deep dive into CockpitOS guarded switch covers. This document explains the CoverGate state machine that sequences open-cover, activate-switch, close-cover operations with configurable timing, reentry protection, and DCS-BIOS command-history integration.

---

## 1. What CoverGate Does

In military aircraft, many critical switches (fire handles, jettison buttons, master arm toggles) sit behind spring-loaded protective covers. The pilot must lift the cover, flip the switch, then close the cover -- three distinct physical actions.

In a home cockpit with momentary buttons, performing this three-step sequence is awkward. The CoverGate system automates it: when you press a single physical button, CockpitOS opens the virtual cover, waits for DCS to register the cover-open, fires the switch, then closes the cover -- all with configurable timing.

### Key Properties

- **Single-button activation** -- one physical press triggers the entire cover/switch/cover sequence.
- **Deferred execution** -- actions are time-staged through a state machine, not blocking delays.
- **Reentry protection** -- internal HID calls during the sequence cannot recursively trigger another CoverGate intercept.
- **Command-history awareness** -- for latched momentary buttons, the system checks current state before toggling to avoid double-fires.

---

## 2. CoverGateKind Enum

CoverGate supports three kinds of guarded switches:

```cpp
enum class CoverGateKind : uint8_t {
    Selector,          // 2-position selector (arm/safe positions)
    ButtonMomentary,   // Latched momentary button under a cover (e.g., fire handle)
    ButtonLatched,     // Reserved for future use
};
```

### Selector

A two-position switch (e.g., Master Arm) where one position means "safe" and the other means "armed." The cover must open before moving to the armed position, and closes after returning to safe.

- **Armed press** -- open cover, then (after `delay_ms`) send the armed-position command.
- **Safe press** -- send the safe-position command immediately, then (after `close_delay_ms`) close the cover.

### ButtonMomentary

A latched button behind a cover (e.g., fire extinguisher, emergency jettison). The button toggles between ON and OFF, but each toggle requires the cover to be open.

- **Press when cover closed** -- open cover, then (after `delay_ms`) toggle the button ON (only if currently OFF per command history).
- **Press when cover open** -- toggle the button immediately, then (after `close_delay_ms`) close the cover.
- **Release** -- always intercepted and blocked to prevent double-send from the HID path.

---

## 3. CoverGateDef Structure

Each guarded switch is defined by a `CoverGateDef` entry in the `kCoverGates[]` array:

```cpp
struct CoverGateDef {
    const char* action_label;      // DCS-BIOS label for the armed/ON action
    const char* release_label;     // DCS-BIOS label for the safe/OFF action (Selector only)
    const char* cover_label;       // DCS-BIOS label for the cover open/close
    CoverGateKind kind;            // Selector, ButtonMomentary, or ButtonLatched
    uint16_t delay_ms;             // Time between cover-open and action (ms)
    uint16_t close_delay_ms;       // Time between action and cover-close (ms)
};
```

### Field Details

| Field | Purpose |
|-------|---------|
| `action_label` | The switch position or button that requires the cover to be open first. Matched against the input label during intercept. |
| `release_label` | The opposite switch position (Selector only). For ButtonMomentary, set to `nullptr`. |
| `cover_label` | The cover itself. CoverGate opens/closes this automatically. |
| `kind` | Determines the sequencing behavior (see Section 2). |
| `delay_ms` | How long to wait after opening the cover before sending the action. Gives DCS time to animate the cover opening. Typical: 100-300 ms. |
| `close_delay_ms` | How long to wait after the action before closing the cover. Typical: 100-500 ms. |

### Configuration Limits

```cpp
#define MAX_COVER_GATES 16
```

The system supports up to 16 simultaneous CoverGate definitions. The `kCoverGates[]` array and `kCoverGateCount` are generated by the Label Creator and declared as externs in `Mappings.h`.

---

## 4. State Machine

### GateState Structure

Each CoverGate entry maintains its own state:

```cpp
enum Pending : uint8_t { P_NONE = 0u, P_SEND_ON = 1u, P_CLOSE_COVER = 2u };

struct GateState {
    Pending p;          // Current pending action
    uint32_t due_ms;    // When to execute the pending action (millis timestamp)
};

static GateState s_state[MAX_COVER_GATES];
```

### State Transitions

**Selector -- Armed Press:**
```
P_NONE
  |-- CoverGate_intercept(action_label, pressed=true)
  |     Open cover immediately (HIDManager_setNamedButton)
  |     Set P_SEND_ON, due_ms = now + delay_ms
  v
P_SEND_ON
  |-- CoverGate_loop() fires when millis() >= due_ms
  |     Send armed-position command (HIDManager_setNamedButton)
  v
P_NONE
```

**Selector -- Safe Press:**
```
P_NONE
  |-- CoverGate_intercept(release_label, pressed=true)
  |     Send safe-position immediately (HIDManager_setNamedButton)
  |     Set P_CLOSE_COVER, due_ms = now + close_delay_ms
  v
P_CLOSE_COVER
  |-- CoverGate_loop() fires when millis() >= due_ms
  |     Close cover (HIDManager_setNamedButton)
  v
P_NONE
```

**ButtonMomentary -- Press (cover closed):**
```
P_NONE
  |-- CoverGate_intercept(action_label, pressed=true)
  |     Check cover state via getLastKnownState(cover_label)
  |     Cover closed (state == 0): open cover immediately
  |     Set P_SEND_ON, due_ms = now + delay_ms
  v
P_SEND_ON
  |-- CoverGate_loop() fires when millis() >= due_ms
  |     Check cg_isLatchedOn(action_label):
  |       If OFF: toggle ON (HIDManager_setToggleNamedButton)
  |       If already ON: skip (prevent double-fire)
  v
P_NONE
```

**ButtonMomentary -- Press (cover open):**
```
P_NONE
  |-- CoverGate_intercept(action_label, pressed=true)
  |     Cover open (state > 0): toggle immediately
  |     Set P_CLOSE_COVER, due_ms = now + close_delay_ms
  v
P_CLOSE_COVER
  |-- CoverGate_loop() fires when millis() >= due_ms
  |     Close cover (HIDManager_setNamedButton)
  v
P_NONE
```

---

## 5. API

### CoverGate_init()

```cpp
void CoverGate_init(void);
```

Called at startup. Validates that `kCoverGateCount` does not exceed `MAX_COVER_GATES` and zeroes all `GateState` entries to `P_NONE`.

### CoverGate_intercept()

```cpp
bool CoverGate_intercept(const char* label, bool pressed);
```

Called from HIDManager when a button event occurs. Scans all `kCoverGates[]` entries to see if the label matches any `action_label` or `release_label`.

**Returns:**
- `true` -- the event was handled by CoverGate. The caller (HIDManager) should NOT process it further.
- `false` -- the event is not a CoverGate-guarded switch. Normal HID processing continues.

This intercept design means CoverGate is transparent to non-guarded switches. Only labels that match a `CoverGateDef` entry are affected.

### CoverGate_loop()

```cpp
void CoverGate_loop(void);
```

Called every main loop iteration. Scans all `GateState` entries for pending actions whose `due_ms` has elapsed. Executes the deferred action and resets the state to `P_NONE`.

The loop uses a signed comparison for timer wrap-safety:

```cpp
if ((int32_t)(now - s_state[i].due_ms) < 0) continue;  // not yet due
```

---

## 6. Reentry Protection

CoverGate internally calls `HIDManager_setNamedButton()` and `HIDManager_setToggleNamedButton()` to operate the cover and switch. These HID functions would normally trigger another `CoverGate_intercept()` call, creating infinite recursion.

The `s_reentry` flag prevents this:

```cpp
static bool s_reentry = false;

// Inside CoverGate_intercept():
if (s_reentry) return false;   // Skip if we're already inside CoverGate

// Before internal HID calls:
s_reentry = true;
HIDManager_setNamedButton(g.cover_label, false, true);   // open cover
s_reentry = false;
```

When `s_reentry` is true, any nested `CoverGate_intercept()` call returns `false` immediately, allowing the HID call to proceed without triggering another CoverGate sequence.

---

## 7. Command History Integration

The `ButtonMomentary` kind uses DCS-BIOS command history to avoid toggling a switch that is already in the desired state.

```cpp
static inline bool cg_isLatchedOn(const char* inputLabel) {
    CommandHistoryEntry* e = findCmdEntry(inputLabel);
    return (e && (e->lastValue > 0));
}
```

When `P_SEND_ON` fires for a `ButtonMomentary`:

1. Check `cg_isLatchedOn(action_label)`.
2. If the button is already ON (lastValue > 0), skip the toggle -- the cover-open already achieved the desired state (or a previous rapid press already toggled it).
3. If the button is OFF, toggle it ON.

This prevents the common scenario where rapid button presses queue multiple `P_SEND_ON` events, each of which would toggle the switch back and forth.

For `getLastKnownState()` (cover state check), the function queries the DCS-BIOS output table to determine whether the cover is currently open (value > 0) or closed (value == 0).

---

## 8. Example Configurations

### Master Arm Selector (2-position switch with cover)

```cpp
const CoverGateDef kCoverGates[] = {
    {
        "MASTER_ARM_SW",          // action_label: armed position
        "MASTER_ARM_SW",          // release_label: safe position (same label, different value)
        "MASTER_ARM_COVER",       // cover_label
        CoverGateKind::Selector,
        200,                      // delay_ms: 200ms after cover opens
        300                       // close_delay_ms: 300ms after going safe
    },
};
```

### Fire Extinguisher Button (latched momentary with cover)

```cpp
const CoverGateDef kCoverGates[] = {
    {
        "FIRE_EXT_BTN",           // action_label: fire extinguisher toggle
        nullptr,                  // release_label: not used for ButtonMomentary
        "FIRE_EXT_COVER",         // cover_label
        CoverGateKind::ButtonMomentary,
        250,                      // delay_ms: 250ms after cover opens
        500                       // close_delay_ms: 500ms after toggle
    },
};
```

### Timing Guidelines

| Scenario | `delay_ms` | `close_delay_ms` |
|----------|-----------|------------------|
| Fast switch (Master Arm) | 100-200 | 200-300 |
| Safety-critical (Fire) | 200-300 | 400-500 |
| Animation-heavy (Jettison) | 300-500 | 500-800 |

If the delays are too short, DCS may not have finished processing the cover animation and will reject the switch command. If they are too long, the cockpit feels sluggish. Start with 200/300 and adjust based on testing.

---

## 9. Integration Flow

```
Physical Button Press
   |
   v
HIDManager_setNamedButton(label, pressed)
   |
   +-- CoverGate_intercept(label, pressed)
   |     |
   |     +-- Match found? YES:
   |     |     Open cover / schedule deferred action
   |     |     return true (handled)
   |     |
   |     +-- Match found? NO:
   |           return false (not handled)
   |
   +-- If intercept returned false:
         Normal HID processing continues
         (sendCommand, HID report, etc.)

Main Loop
   |
   v
CoverGate_loop()
   |
   +-- Check all GateState entries
   |     If pending action is due:
   |       Execute deferred action (P_SEND_ON or P_CLOSE_COVER)
   |       Reset state to P_NONE
```

---

## See Also

- [Advanced/Custom-Panels.md](Custom-Panels.md) -- Panel architecture and HIDManager API
- [Advanced/Latched-Buttons.md](Latched-Buttons.md) -- Latched button toggle system (used by ButtonMomentary kind)
- [Reference/Config.md](../Reference/Config.md) -- Configuration constants
