# ST77916 QSPI Integration — Technical Summary & Next Steps

**Project:** CockpitOS TFT Gauge Pipeline  
**Target Hardware:** Waveshare ESP32-S3-LCD-1.85 (360×360, ST77916, QSPI)  
**Date:** February 2026  
**Status:** Standalone test sketch ready for hardware validation

---

## 1. Problem Statement

CockpitOS TFT gauges use LovyanGFX for both rendering (sprites) and transport (SPI bus). The ST77916 controller on the Waveshare ESP32-S3-LCD-1.85 uses a **QSPI interface** with proprietary command framing — 32-bit command words embedding opcodes (`0x02` for commands, `0x32` for pixel data) that LovyanGFX's `Bus_SPI` and `Bus_QSPI` classes cannot produce. LovyanGFX has no `Panel_ST77916` driver and its QSPI bus implementation targets different opcode conventions (Sitronix-style), making it incompatible with this controller.

**Root cause:** The ST77916 wraps standard MIPI DCS commands inside QSPI opcode frames. LovyanGFX sends raw commands on the SPI bus without this framing layer, so the controller ignores all traffic.

---

## 2. Solution Architecture

A hybrid approach that preserves 100% of the existing CockpitOS rendering pipeline while replacing only the hardware transport layer.

```
┌────────────────────────────────────────────────────────────────┐
│  RENDERING  (LovyanGFX sprites — unchanged)                    │
│                                                                 │
│  bgCache[] ───memcpy──────► frameSpr  (PSRAM, 360×360)         │
│  needleSpr ──pushRotateZoom──► frameSpr                         │
│  Dirty-rect math, clipping, BG restore — all identical         │
│                                                                 │
│  Zero hardware interaction. Pure memory operations.             │
└───────────────────────┬────────────────────────────────────────┘
                        │ getBuffer()
                        ▼
┌────────────────────────────────────────────────────────────────┐
│  TRANSPORT  (esp_lcd — native QSPI)                             │
│                                                                 │
│  Stripe copy with byte-swap (LE→BE) into DMA bounce buffer     │
│  esp_lcd_panel_draw_bitmap(panel, x1, y1, x2, y2, bounce)     │
│                                                                 │
│  Handles: CASET/RASET/RAMWR + QSPI opcode framing internally   │
│  Clock: 80 MHz QSPI, SPI_DMA_CH_AUTO                           │
└────────────────────────────────────────────────────────────────┘
```

**Key design decision:** `frameSpr(nullptr)` — the frame sprite has no parent device. It is a pure memory canvas. This decouples rendering from transport entirely, so the same sprite code works regardless of whether pixels are pushed via LovyanGFX `Bus_SPI`, `esp_lcd` QSPI, or any future transport.

---

## 3. Component Acquisition

The ST77916 driver was sourced from Espressif's official **esp-iot-solution** repository (v2.0.3, Apache 2.0 license).

| File | Size | Purpose |
|------|------|---------|
| `esp_lcd_st77916_spi.c` | 21 KB | QSPI driver: vendor init sequence, opcode framing, draw_bitmap |
| `esp_lcd_st77916.c` | 1.2 KB | Dispatcher (routes to SPI or MIPI implementation) |
| `esp_lcd_st77916.h` | 10 KB | Public API, bus config macros, patched with version defines |
| `esp_lcd_st77916_interface.h` | 1.3 KB | Internal interface declarations |

**Arduino compatibility patch applied:** Added `ESP_LCD_ST77916_VER_MAJOR/MINOR/PATCH` defines to the header, normally generated by CMake at build time but absent in Arduino IDE builds.

The MIPI-DSI code path (`esp_lcd_st77916_mipi.c`) is excluded automatically — guarded by `#if SOC_MIPI_DSI_SUPPORTED` which is `false` on ESP32-S3.

---

## 4. What Changed vs. CockpitOS Production Code

Only the transport layer is affected. The following table maps every function in `TFT_Gauges_CabinPressure.cpp` to its status:

| Function / Block | Status | Notes |
|-----------------|--------|-------|
| `LGFX_CabPress` class | **REMOVED** | Replaced by `esp_lcd` init sequence |
| `frameSpr(&tft)` | **CHANGED** | Now `frameSpr(nullptr)` — no device parent |
| `tft.init()` / `tft.fillScreen()` | **REPLACED** | `esp_lcd_panel_init()` + `esp_lcd_panel_draw_bitmap()` |
| `tft.setSwapBytes(true)` | **REPLACED** | Byte-swap done manually in stripe copy loop |
| `flushRectToDisplay()` | **REWRITTEN** | ~25 lines: stripe copy + swap → `esp_lcd_panel_draw_bitmap()` |
| `blitBGRectToFrame()` | Unchanged | Pure `memcpy` on PSRAM buffer |
| `rotatedAABB()` | Unchanged | Float math for dirty-rect bounds |
| `rectClamp/Union/Pad` | Unchanged | Integer geometry helpers |
| `needleSpr.pushRotateZoom()` | Unchanged | LovyanGFX sprite-to-sprite composition |
| DCS-BIOS callbacks | Unchanged | `onPressureAltChange`, `onDimmerChange` |
| BIT test sweep | Unchanged | Blocking sequential draw calls |
| FreeRTOS task | Unchanged | `vTaskDelay(pdMS_TO_TICKS(5))` render loop |

---

## 5. Byte-Swap Detail

LovyanGFX sprites store RGB565 pixels in **little-endian** byte order (native ESP32). The ST77916 expects **big-endian** RGB565 over the QSPI bus. In the LovyanGFX pipeline, `tft.setSwapBytes(true)` handled this transparently. With `esp_lcd`, the swap is performed explicitly during the stripe copy into the DMA bounce buffer:

```cpp
for (int col = 0; col < r.w; ++col) {
    const uint16_t px = src_row[col];
    dst_row[col] = (px >> 8) | (px << 8);   // LE → BE
}
```

This adds negligible overhead (~0.1 ms per full-screen stripe pass) and could be further optimized with SIMD-style 32-bit word processing if needed.

---

## 6. Deliverables Produced

### 6.1 Standalone QSPI Pixel Test (`ST77916_QSPI_Test/`)

Minimal sketch proving `esp_lcd` can push pixels to the ST77916. Fills the screen solid red. No LovyanGFX dependency.

### 6.2 Cabin Pressure Altimeter Test (`ST77916_CabPress_Test/`)

Full hybrid architecture proof: LovyanGFX sprites for rendering + `esp_lcd` for QSPI transport. Includes procedurally generated gauge face and needle, dirty-rect updates, BIT test sweep, and continuous sinusoidal animation. Self-contained — all 6 files in one Arduino sketch folder.

**Sketch folder contents:**

```
ST77916_CabPress_Test/
├── ST77916_CabPress_Test.ino          27 KB   Main sketch
├── esp_lcd_st77916.c                   1.2 KB  Driver dispatcher
├── esp_lcd_st77916_spi.c             21 KB   QSPI driver
├── esp_lcd_st77916.h                  10 KB   Public API (patched)
├── esp_lcd_st77916_interface.h         1.3 KB  Internal interface
└── esp_lcd_st77916_LICENSE.txt        11 KB   Apache 2.0 license
```

---

## 7. Next Steps

### Phase 1 — Hardware Validation (Immediate)

1. **Flash `ST77916_QSPI_Test`** to the Waveshare board. Expected: solid red 360×360 screen. This confirms the QSPI bus, opcode framing, and vendor init sequence are correct.

2. **Flash `ST77916_CabPress_Test`**. Expected: synthetic gauge face with animated needle. This confirms the full pipeline — PSRAM sprite rendering, dirty-rect tracking, byte-swap, and QSPI flush all working together.

3. **Observe Serial output** for timing data and allocation confirmations. Watch for any `esp_lcd` error codes (especially `ESP_ERR_TIMEOUT` which would indicate clock speed issues).

### Phase 2 — Real Asset Swap (Quick Win)

4. **Replace synthetic assets** with real CockpitOS cabin pressure art. Drop in the PROGMEM headers (`cabinPressBackground.h`, `cabinPressNeedle.h`, etc.) and switch from `generateBackground()` to `memcpy(bgCache, cabinPressBackground, FRAME_BYTES)`. The rendering is identical — only the pixel source data changes.

5. **Verify NVG mode** by adding the second background cache and dimmer callback, exactly as production code does.

### Phase 3 — CockpitOS Integration (Surgical)

6. **Create a transport abstraction** in CockpitOS. Two approaches, in order of preference:

   **Option A — Compile-time dispatch (recommended):**
   ```cpp
   #if defined(USE_ESPLCD_QSPI_TRANSPORT)
       // esp_lcd flush path
       void flushRectToDisplay(const uint16_t* src, const Rect& r, bool blocking) { ... }
   #else
       // LovyanGFX Bus_SPI flush path (existing code)
       void flushRectToDisplay(const uint16_t* src, const Rect& r, bool blocking) { ... }
   #endif
   ```
   A single `#define` in `Config.h` or the label set's `CustomPins.h` selects the transport. Zero runtime overhead. Each gauge file gets the correct flush path at compile time.

   **Option B — Shared transport header:**
   Create `src/TFT_Transport_ST77916.h` containing the `esp_lcd` init function and `flushRectToDisplay()` implementation. Each gauge `.cpp` that targets ST77916 QSPI boards includes this header instead of defining the LovyanGFX device class.

7. **Add `esp_lcd_st77916` files to `lib/`** in the CockpitOS repo. Place them under `lib/esp_lcd_st77916/` with proper include paths so they compile for any sketch that needs them, without polluting builds that don't.

8. **Wire up the Waveshare pinout** in a new label set or `CustomPins.h` entry:
   ```cpp
   #define CABIN_PRESSURE_SCLK_PIN  40
   #define CABIN_PRESSURE_D0_PIN    46
   #define CABIN_PRESSURE_D1_PIN    45
   #define CABIN_PRESSURE_D2_PIN    42
   #define CABIN_PRESSURE_D3_PIN    41
   #define CABIN_PRESSURE_CS_PIN    21
   #define CABIN_PRESSURE_BL_PIN     5
   #define USE_ESPLCD_QSPI_TRANSPORT 1
   ```

### Phase 4 — Optimization (After Validation)

9. **Profile flush performance** using `PerfMonitor.h`. Compare esp_lcd stripe flush times against the LovyanGFX DMA path on equivalent SPI displays. The QSPI bus should be ~2× faster at the same clock due to 4 data lines.

10. **Optimize byte-swap** with 32-bit word processing:
    ```cpp
    // Process 2 pixels at a time
    const uint32_t* src32 = (const uint32_t*)src_row;
    uint32_t*       dst32 = (uint32_t*)dst_row;
    for (int col = 0; col < r.w / 2; ++col) {
        uint32_t v = src32[col];
        dst32[col] = ((v & 0xFF00FF00) >> 8) | ((v & 0x00FF00FF) << 8);
    }
    ```

11. **Evaluate double-buffered async flush.** The current implementation is synchronous (`esp_lcd_panel_draw_bitmap` blocks until the SPI transaction completes). The esp_lcd API supports a `done_cb` callback on the panel IO config — this could enable overlapping DMA with the next stripe's memcpy, matching the double-bounce pattern already used in the LovyanGFX gauges.

### Phase 5 — Generalization

12. **Apply the same pattern to all 360×360 gauges** (Radar Altimeter, Brake Pressure, Battery, Hydraulic Pressure) since they all share the identical flush function signature.

13. **Document the hybrid architecture** in `Docs/Advanced/Display-Pipeline.md` so community contributors can target new QSPI displays (ST77922, ST77903, etc.) by providing only the esp_lcd driver component — the rendering side needs zero changes.

---

## 8. Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Vendor init sequence incorrect for this specific Waveshare PCB | Low | Display blank or corrupted | Compare against working ashchan/hornet-esp32-gauges init; add custom init_cmds override |
| Byte-swap direction wrong (display shows inverted colors) | Low | Wrong colors, easy to diagnose | Toggle swap direction; test with known color patterns (pure red = 0xF800 vs 0x00F8) |
| 80 MHz QSPI unstable on long ribbon cables | Medium | Glitches, corruption | Drop to 40 MHz in `io_cfg.pclk_hz`; the Waveshare has short traces so 80 MHz should work |
| PSRAM contention with QSPI (shared SPI2_HOST) | Low | Performance degradation | ESP32-S3 has separate PSRAM controller (OPI); SPI2_HOST is dedicated to LCD |
| TCA9554 reset required on some Waveshare boards | Low | Display doesn't wake up | Add I2C reset sequence if software reset fails (GPIO expander at address 0x20) |

---

## 9. Pinout Reference

**Waveshare ESP32-S3-LCD-1.85:**

| Signal | GPIO | Color (if wired) | Notes |
|--------|------|-------------------|-------|
| QSPI SCLK | 40 | — | Clock |
| QSPI D0 | 46 | — | Data line 0 |
| QSPI D1 | 45 | — | Data line 1 |
| QSPI D2 | 42 | — | Data line 2 |
| QSPI D3 | 41 | — | Data line 3 |
| CS | 21 | — | Chip select |
| Backlight | 5 | — | Active HIGH |
| TCA9554 SDA | 7 | — | I2C GPIO expander (reset) |
| TCA9554 SCL | 6 | — | I2C GPIO expander (reset) |
| Touch SDA | 7 | — | Shared I2C bus |
| Touch SCL | 6 | — | Shared I2C bus |
| Touch INT | 8 | — | Active LOW |
| Touch RST | 9 | — | Via TCA9554 |

---

## 10. License

The `esp_lcd_st77916` component is licensed under **Apache License 2.0** by Espressif Systems. The license file is included in the sketch folder. CockpitOS remains under its existing license terms.
