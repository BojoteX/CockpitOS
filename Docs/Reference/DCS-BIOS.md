# DCS-BIOS Integration Reference

This document explains how CockpitOS integrates with DCS-BIOS: what DCS-BIOS is, how the protocol works, how CockpitOS subscribes to cockpit data, and how commands flow from your physical panel into DCS World.

---

## What is DCS-BIOS?

DCS-BIOS is a community-maintained LUA export script that runs inside DCS World. It does two things:

1. **Exports cockpit state** -- It reads every switch position, indicator light, gauge value, and display string from the virtual cockpit and broadcasts them as a binary data stream over UDP.
2. **Accepts commands** -- It receives text commands over UDP and applies them to the virtual cockpit (flipping switches, pressing buttons, setting knob positions).

DCS-BIOS is the bridge between the simulation and your physical hardware. CockpitOS is the firmware that runs on the hardware side.

### Installation

Download DCS-BIOS from the official repository:

**https://github.com/DCS-Skunkworks/dcs-bios/releases**

Install it into your DCS World Saved Games folder:
```
Saved Games\DCS\Scripts\DCS-BIOS\
```

DCS-BIOS activates automatically when DCS World starts. You can verify it is running by checking the DCS log file or by using CockpitOS debug tools to listen for UDP traffic.

---

## Protocol Overview

```
DCS World                                              Physical Panel
+-----------+                                          +-----------+
|           |    LUA Export                             |           |
|  Cockpit  | -----------> DCS-BIOS ----+              | CockpitOS |
|  State    |              (LUA)        |              |  (ESP32)  |
|           |                           |              |           |
|           |   UDP Multicast           |              |           |
|           |   239.255.50.10:5010      v              |           |
|           |              Binary frames ============> | Parse     |
|           |              (export data)               | & update  |
|           |                                          | LEDs,     |
|           |   UDP Port 7778           ^              | displays  |
|           |              Text commands <============ |           |
|           | <----------- DCS-BIOS <---+              | Buttons,  |
|  Apply    |              (LUA)                       | switches  |
|  Commands |                                          |           |
+-----------+                                          +-----------+
```

### Export Protocol (DCS to Panel)

DCS-BIOS exports the entire cockpit state as a flat binary buffer. The buffer is a fixed-size memory region where each control's value occupies a specific **address** within that buffer. When any value changes, DCS-BIOS sends an update frame containing the changed region.

**Transport:** UDP multicast to `239.255.50.10` on port `5010`

**Frame format:** Binary frames consisting of:
- Sync sequence (marks the start of a frame)
- Address/length/data triplets (which memory region changed and the new bytes)
- End-of-frame marker

CockpitOS parses these frames and extracts the values for controls it has subscribed to.

### Command Protocol (Panel to DCS)

CockpitOS sends commands to DCS-BIOS as plain-text ASCII strings over UDP port 7778 (or over USB/Serial depending on transport mode).

**Format:** `CONTROL_NAME VALUE\n`

**Examples:**
```
MASTER_ARM_SW 1
MASTER_CAUTION_RESET_SW 1
HMD_OFF_BRT 32768
CHART_DIMMER +3200
CHART_DIMMER -3200
```

- For `set_state` controls: the value is an integer (e.g., `0`, `1`, `65535`)
- For `variable_step` controls: the value is a signed offset (e.g., `+3200`, `-3200`)
- For `fixed_step` controls: the value is a direction (e.g., `INC`, `DEC`)

---

## Address, Mask, and Shift

Every DCS-BIOS output is located at a specific position in the export buffer, defined by three values:

| Field | Description |
|-------|-------------|
| **Address** | Byte offset in the export buffer where this value starts (e.g., `29804`) |
| **Mask** | Bitmask that isolates this value's bits within the 16-bit word at the address (e.g., `0x0C00` or `3072`) |
| **Shift** | Number of bits to right-shift after applying the mask to get the final value (e.g., `10`) |

### Example

For `AMPCD_CONT_SW` (Contrast Switch on the AMPCD panel):
```
Address: 29804
Mask:    3072   (binary: 0000110000000000)
Shift:   10
```

To extract the value:
1. Read the 16-bit word at address 29804 from the export buffer
2. Apply the mask: `word & 3072`
3. Right-shift: `result >> 10`
4. The result is the selector position (0, 1, or 2)

### How CockpitOS Uses This

You do not need to calculate addresses, masks, or shifts manually. The `DCSBIOSBridgeData.h` file (auto-generated by the Label Creator) contains all the subscription definitions. CockpitOS registers listeners for each address it needs and processes the incoming data automatically.

---

## Label Hashing

CockpitOS uses a compile-time hash function to map control labels (like `"MASTER_ARM_SW"`) to their corresponding data structures. This avoids expensive string comparisons at runtime.

### How It Works

1. During code generation, the Label Creator builds a **hash table** in `InputMapping.h` and `DCSBIOSBridgeData.h`.
2. Each label is hashed to a table index using a simple recursive hash function.
3. At runtime, when DCS-BIOS data arrives for a specific address, CockpitOS looks up the corresponding control by its hashed label in O(1) time.

### The Hash Function

```cpp
constexpr uint16_t labelHash(const char* s);
```

This is a `constexpr` function evaluated at compile time. The hash tables are fully resolved before the firmware runs on the ESP32, so there is zero runtime cost for the hashing itself.

### Generated Hash Table Example

```cpp
struct InputHashEntry { const char* label; const InputMapping* mapping; };
static const InputHashEntry inputHashTable[83] = {
    {"INST_PNL_DIMMER_INC", &InputMappings[17]},
    {nullptr, nullptr},
    {"RIGHT_FIRE_BTN_COVER", &InputMappings[40]},
    // ... more entries ...
};
```

Entries with `{nullptr, nullptr}` are empty slots in the open-addressing hash table.

---

## Subscription System

CockpitOS subscribes to specific DCS-BIOS addresses so it only processes data relevant to the current panel.

### How Subscriptions Work

1. At compile time, `DCSBIOSBridgeData.h` defines every DCS-BIOS address this panel cares about, compiled directly into the firmware.
2. For each address, CockpitOS registers a **listener** callback.
3. When a DCS-BIOS export frame arrives containing data at a subscribed address, the listener fires.
4. The listener extracts the value (using address/mask/shift), looks up the corresponding LED or display mapping, and updates the hardware.

### Selective Processing

CockpitOS only processes addresses it has subscribed to. Export data for addresses not in the subscription list is skipped. This keeps CPU usage low even when DCS-BIOS is exporting hundreds of controls for an aircraft -- your panel only processes the handful it actually needs.

---

## Aircraft JSON Files

CockpitOS includes aircraft definition files that describe every cockpit control for each supported aircraft module.

### Location

```
src/LABELS/_core/aircraft/
```

**Example files:**
- `FA-18C_hornet.json` -- F/A-18C Hornet
- `AH-64D.json` -- AH-64D Apache

### Structure

Each JSON file is organized by cockpit panel category. Within each category, individual controls are defined with:

```json
{
    "Panel Category": {
        "CONTROL_IDENTIFIER": {
            "category": "Panel Category",
            "control_type": "selector",
            "description": "Human-readable description",
            "identifier": "CONTROL_IDENTIFIER",
            "inputs": [
                {
                    "description": "set position",
                    "interface": "set_state",
                    "max_value": 2
                }
            ],
            "outputs": [
                {
                    "address": 29804,
                    "address_mask_shift_identifier": "FA_18C_hornet_CONTROL_ID",
                    "description": "selector position",
                    "mask": 3072,
                    "max_value": 2,
                    "shift_by": 10,
                    "type": "integer"
                }
            ]
        }
    }
}
```

### Key Fields

| Field | Description |
|-------|-------------|
| `identifier` | The DCS-BIOS control name (used in commands) |
| `control_type` | Type of control: `selector`, `limited_dial`, `led`, `display`, etc. |
| `inputs[].interface` | How to send commands: `set_state`, `variable_step`, `fixed_step` |
| `inputs[].max_value` | Maximum value for `set_state` commands |
| `outputs[].address` | Export buffer address |
| `outputs[].mask` | Bitmask for value extraction |
| `outputs[].shift_by` | Right-shift amount after masking |
| `outputs[].max_value` | Maximum value this output can have |
| `outputs[].type` | Data type: `integer` or `string` |

### How the Label Creator Uses Aircraft JSON

When you create a new label set:

1. You select an aircraft (e.g., `FA-18C_hornet`).
2. The Label Creator loads the corresponding JSON file.
3. You select which cockpit panels to include.
4. The Label Creator extracts all controls from the selected panels.
5. It generates `InputMapping.h`, `LEDMapping.h`, `DisplayMapping.cpp`, and `DCSBIOSBridgeData.h` based on these controls.

---

## Metadata (JSON Overlays)

Each label set can include a `METADATA/` directory containing JSON files that modify or extend the aircraft definitions. Metadata is applied on top of the base aircraft JSON during code generation.

### Location

```
src/LABELS/<YOUR_LABEL_SET>/METADATA/
```

### Common Metadata Files

| File | Purpose |
|------|---------|
| `CommonData.json` | Shared data fields available across all aircraft (altitude, heading, IAS, etc.) |
| `MetadataStart.json` | Custom control definitions or overrides applied before panel generation |
| `MetadataEnd.json` | Custom control definitions or overrides applied after panel generation |

### CommonData.json

This file defines aircraft-independent data fields that are always available in DCS-BIOS, regardless of the aircraft module:

```json
{
    "Altitude": {
        "ALT_MSL_FT": {
            "category": "Altitude",
            "control_type": "metadata",
            "description": "Altitude MSL (ft)",
            "identifier": "ALT_MSL_FT",
            "outputs": [{
                "address": 1076,
                "mask": 65535,
                "max_value": 65535,
                "shift_by": 0,
                "type": "integer"
            }]
        }
    }
}
```

### Use Cases for Metadata

- **Add custom controls** that are not in the standard DCS-BIOS aircraft definition
- **Override control properties** (e.g., change the command name or value range)
- **Include shared data fields** (altitude, heading, speed) for multi-function displays
- **Define composite controls** that combine multiple DCS-BIOS outputs

---

## Data Flow Summary

Here is the complete data flow from a physical button press to a cockpit change and back:

```
1. BUTTON PRESS
   GPIO pin goes LOW
        |
        v
2. INPUT SCAN (POLLING_RATE_HZ)
   CockpitOS detects state change
   Looks up InputMapping by pin/source
        |
        v
3. COMMAND GENERATION
   Builds command string: "MASTER_ARM_SW 1\n"
        |
        v
4. TRANSPORT SEND
   USB HID report / WiFi UDP / Serial
        |
        v
5. BRIDGE (if applicable)
   HID Manager / socat converts to UDP
   Sends to port 7778
        |
        v
6. DCS-BIOS (LUA)
   Receives command, applies to cockpit
   Cockpit state changes
        |
        v
7. EXPORT UPDATE
   DCS-BIOS detects change in export buffer
   Sends binary frame to 239.255.50.10:5010
        |
        v
8. TRANSPORT RECEIVE
   CockpitOS receives frame
        |
        v
9. SUBSCRIPTION MATCH
   Checks if frame contains subscribed addresses
   Extracts value using address/mask/shift
        |
        v
10. OUTPUT UPDATE
    Updates LED, display, or gauge
    Hardware reflects new cockpit state
```

---

## Debug Tools for DCS-BIOS

| Tool | Location | Purpose |
|------|----------|---------|
| `CONSOLE_UDP_debug.py` | `Debug Tools/` | Monitor UDP traffic (frames + commands) |
| `LOG_DCS_commands.py` | `Debug Tools/` | Log all DCS-BIOS commands being sent |
| `SEND_CommandTester.py` | `Debug Tools/` | Manually send DCS-BIOS commands to test |
| `SEND_bulk_CommandTester.py` | `Debug Tools/` | Send multiple commands in rapid succession |
| `RECORD_DCS_stream.py` | `Debug Tools/` | Record DCS-BIOS export stream to file |
| `PLAY_DCS_stream.py` | `Debug Tools/` | Replay a recorded DCS-BIOS stream |
| `FRAME_avg_size.py` | `Debug Tools/` | Analyze average frame sizes |
| `BOOTLOADER_reset_tool.py` | `Debug Tools/` | Reset ESP32 into bootloader mode |

### Testing Without DCS Running

Set `IS_REPLAY=1` in `Config.h` to use recorded DCS-BIOS data for testing. This simulates a loopback stream so you can verify your panel's outputs without running DCS World.

Generate replay data:
```
python ReplayData\generate_ReplayData.py
```

---

## See Also

- [Control Types](Control-Types.md) -- How each input type maps to DCS-BIOS commands
- [Config.h Reference](Config.md) -- Transport and timing settings
- [Transport Modes](Transport-Modes.md) -- How data reaches DCS-BIOS
- [Label Creator](../Tools/Label-Creator.md) -- Generating mapping files from aircraft JSON
- [Troubleshooting](Troubleshooting.md) -- Connection and data flow problems

---

*CockpitOS DCS-BIOS Integration Reference | Last updated: February 2026*
