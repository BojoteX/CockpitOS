################################################################################
#                                                                              #
#              COCKPITOS LLM INSTRUCTION SET - VERSION 3.0                     #
#                    OPTIMIZED FOR LANGUAGE MODEL PROCESSING                   #
#                                                                              #
#   Target: Language Models assisting with CockpitOS development              #
#   Optimization: Token-efficient, ASCII-only, zero ambiguity                 #
#   Last Updated: 2025-01                                                      #
#   Repository: https://github.com/BojoteX/CockpitOS                           #
#                                                                              #
################################################################################

==============================================================================
SECTION 0: LLM PROCESSING DIRECTIVES (READ FIRST - MANDATORY)
==============================================================================

0.1 DOCUMENT PURPOSE
--------------------
This document enables accurate code generation and technical guidance for
CockpitOS firmware development. Follow directives exactly. Do not improvise.

0.2 PROCESSING PRIORITY ORDER
-----------------------------
When responding to ANY CockpitOS question:
1. Check Section 0.3 (CRITICAL ISSUES) - prevents catastrophic errors
2. Check Section 0.4 (ABSOLUTE CONSTRAINTS) - never violate these
3. Check Section 0.5 (DECISION ROUTER) - find correct section fast
4. Reference specific section for detailed guidance
5. When generating code, verify against Section 19 (ANTI-PATTERNS)

0.3 CRITICAL ISSUES - CHECK BEFORE ANY CODE GENERATION
------------------------------------------------------
ISSUE-001: ADDRESS RANGE BUG
  WRONG: ExportStreamListener(0x0000, 0xFFFE)
  RIGHT: ExportStreamListener(0x0000, 0xFFFD)
  CAUSE: 0xFFFE causes flush timing issues with chunked HID transmission
  IMPACT: Multi-aircraft support breaks, data corruption

ISSUE-002: TFT RESET PIN (IdeasPark ST7789)
  WRONG: cfg.pin_rst = -1;
  RIGHT: cfg.pin_rst = 4;
  CAUSE: IdeasPark boards require explicit GPIO 4 for reset
  IMPACT: Display blank or corrupted

ISSUE-003: ESP32-S3/P4 USB MODE
  WRONG: Default Arduino USB settings
  RIGHT: Tools -> USB Mode -> "USB-OTG (TinyUSB)"
  CAUSE: S3/P4 have dual USB controllers, must select OTG
  IMPACT: USB HID not detected by host

ISSUE-004: ARDUINO CORE VERSION
  MINIMUM: ESP32 Arduino Core 3.3.0+
  CAUSE: Older versions have USB stack bugs
  IMPACT: Random disconnects, failed enumeration

ISSUE-005: SERIAL DEBUG OUTPUT
  WRONG: Serial.println("debug");
  RIGHT: debugPrintln("debug");
  CAUSE: debugPrint* routes to Serial OR WiFi UDP based on config
  IMPACT: Debug output lost, breaks WiFi debug mode

0.4 ABSOLUTE CONSTRAINTS - NEVER VIOLATE
----------------------------------------
CONSTRAINT-MEM-01: NO HEAP ALLOCATION
  Forbidden: malloc, new, free, delete, std::vector, std::string, String
  Required: Static allocation, stack allocation for small temps
  Exception: TFT sprites may use PSRAM (Section 16)

CONSTRAINT-MEM-02: NO BLOCKING CALLS
  Forbidden: delay(), busy-wait while loops, blocking I/O waits
  Required: Non-blocking state machines, hardware timers, interrupts

CONSTRAINT-MEM-03: BOUNDED LOOPS ONLY
  Forbidden: while(condition) without iteration limit
  Required: for(int i=0; i<MAX && condition; i++)
  Typical limits: 64 (input scan), 256 (protocol parse), 1024 (search)

CONSTRAINT-MEM-04: NO EXCEPTIONS/RTTI
  Forbidden: try/catch, throw, typeid, dynamic_cast
  Required: Return codes, explicit error handling

CONSTRAINT-MEM-05: CONST BY DEFAULT
  Required: Every global/static that doesn't change MUST be const/constexpr
  Required: Use static_assert for compile-time validation

CONSTRAINT-IO-01: NO DIRECT HARDWARE ACCESS IN PANELS
  Forbidden: digitalWrite(), analogRead() in panel code
  Required: CUtils API (GPIO_setDigital, HIDManager_moveAxis, etc.)

CONSTRAINT-IO-02: NO DIRECT SERIAL OUTPUT
  Forbidden: Serial.print(), Serial.println(), Serial.printf()
  Required: debugPrint(), debugPrintln(), debugPrintf()

0.5 DECISION ROUTER - FIND CORRECT SECTION FAST
-----------------------------------------------
Question about ESP32 variants/capabilities?     --> Section 2
Question about DCS-BIOS protocol/parsing?       --> Section 3
Question about project file structure?          --> Section 4
Question about Label Sets/configuration?        --> Section 5
Question about InputMapping.h/inputs?           --> Section 6
Question about LEDMapping.h/outputs?            --> Section 7
Question about Panel creation/registration?     --> Section 8
Question about CoverGate/guarded controls?      --> Section 9
Question about latched/toggle buttons?          --> Section 10
Question about CUtils/hardware API?             --> Section 11
Question about HIDManager/input logic?          --> Section 12
Question about DCSBIOSBridge/subscriptions?     --> Section 13
Question about transport modes (USB/WiFi/etc)?  --> Section 14
Question about Config.h options?                --> Section 15
Question about TFT displays/gauges?             --> Section 16
Question about HT1622 segment LCDs?             --> Section 17
Question about debugging/performance?           --> Section 18
Question about what NOT to do?                  --> Section 19
Question about choosing an approach?            --> Section 20
Question about errors/troubleshooting?          --> Section 21
Question about quick reference tables?          --> Section 22
Question about HID_Manager.py (Python)?         --> Section 23
Question about BLE/Bluetooth?                   --> Section 24
Question about FreeRTOS tasks?                  --> Section 25
Question about multi-aircraft support?          --> Section 26
Need ready-to-use code templates?               --> Section 27

0.6 KEY RELATIONSHIPS
---------------------
DCS-BIOS: LUA scripts running INSIDE DCS World on PC (not on ESP32)
CockpitOS: Firmware running ON ESP32 microcontroller
Communication: UDP (WiFi) or USB HID or Serial between them
Data flow EXPORT: DCS World -> DCS-BIOS LUA -> UDP/USB -> CockpitOS -> Hardware
Data flow IMPORT: Hardware -> CockpitOS -> UDP/USB -> DCS-BIOS LUA -> DCS World

Repositories:
  CockpitOS: https://github.com/BojoteX/CockpitOS
  DCS-BIOS:  https://github.com/DCS-Skunkworks/dcs-bios

==============================================================================
SECTION 1: SYSTEM ARCHITECTURE
==============================================================================

1.1 WHAT IS COCKPITOS
---------------------
Firmware for ESP32 MCUs interfacing physical cockpit panels with DCS World
flight simulator via DCS-BIOS protocol.

Capabilities:
  INPUTS:  Buttons, switches, rotary encoders, potentiometers, matrix rotaries
  OUTPUTS: LEDs (GPIO/WS2812/TM1637/GN1640T/PCA9555), displays (HT1622/TFT), servos
  COMMS:   USB HID, WiFi UDP, Serial/CDC, Bluetooth BLE

Primary aircraft: F/A-18C Hornet (any DCS-BIOS aircraft JSON supported)

1.2 FOUR-LAYER ARCHITECTURE
---------------------------
LAYER 4: PANEL LOGIC          Location: src/Panels/*.cpp
  - Custom panel implementations (IFEI, WingFold, TFT gauges)
  - Subscribes to DCS-BIOS data via callbacks
  - Uses REGISTER_PANEL macro for lifecycle management
  - NEVER touches hardware directly - uses HIDManager/CUtils APIs

LAYER 3: BRIDGE & HID         Location: src/*.cpp, src/Core/*.cpp
  - DCSBIOSBridge: Protocol parsing, subscription dispatch
  - HIDManager: Button/axis logic, group arbitration, mode switching
  - LEDControl: Unified LED routing regardless of hardware type
  - InputControl: GPIO/HC165/PCA9555 polling, encoder handling
  - RingBuffer: Non-blocking I/O for USB/UDP (64-byte chunks)

LAYER 2: HARDWARE ABSTRACTION Location: lib/CUtils/src/*.cpp
  - CUtils.h: Unified API for all hardware drivers
  - Drivers: GPIO, PCA9555, TM1637, GN1640, WS2812, HC165, HT1622, AnalogGauge
  - Panel code NEVER accesses hardware directly - always through CUtils

LAYER 1: HARDWARE             Physical ESP32 + peripherals
  - ESP32 variants (S2, S3, Classic, C3, C6, H2, P4)
  - I2C bus, SPI bus, GPIO pins, ADC channels
  - External ICs: PCA9555, TM1637, GN1640T, HT1622, WS2812, 74HC165

1.3 DATA FLOW TIMING
--------------------
Export (DCS -> Panel): ~30 Hz (33ms frames)
Input polling:         250 Hz (4ms interval)
HID reports:           250 Hz (4ms interval)
Display refresh:       30-60 Hz (16-33ms)
Command throttle:      33-50ms minimum between commands

==============================================================================
SECTION 2: HARDWARE REQUIREMENTS
==============================================================================

2.1 ESP32 VARIANT SUPPORT
-------------------------
VARIANT         NATIVE USB    WIFI    BLE     NOTES
ESP32-S2        Yes           Yes     No      RECOMMENDED. LOLIN S2 Mini.
ESP32-S3        Yes           Yes     Yes     RECOMMENDED. Dual-core, more RAM.
ESP32-P4        Yes           Yes     Yes     NEWEST. Full support.
ESP32 Classic   No            Yes     Yes     Requires external USB-UART.
ESP32-C3        No            Yes     Yes     RISC-V. WiFi/Serial only.
ESP32-C6        No            Yes     Yes     WiFi 6. Serial/WiFi only.
ESP32-H2        No            No      Yes     Thread/Zigbee. BLE only.

2.2 USB HID REQUIREMENTS
------------------------
For USE_DCSBIOS_USB = 1:
  - ESP32-S2/S3/P4 required (native USB peripheral)
  - ESP32-S3/P4: Tools -> USB Mode -> "USB-OTG (TinyUSB)" [CRITICAL]
  - ESP32-S2: Default Arduino settings work
  - HID_Manager.py must run on host PC

2.3 INPUT HARDWARE SUPPORT
--------------------------
TYPE                MAX COUNT   NOTES
Direct GPIO         ~20 pins    Board-dependent available pins
74HC165 chain       64 bits     Daisy-chainable shift registers
PCA9555 I2C         128 I/O     8 devices x 16 I/O each (addr 0x20-0x27)
TM1637 keys         8 keys      Per TM1637 device
Matrix rotary       N/A         Strobe-based position detection
Analog (ADC)        ~6 inputs   12-bit resolution (0-4095)

2.4 OUTPUT HARDWARE SUPPORT
---------------------------
TYPE                MAX COUNT   NOTES
GPIO LEDs           ~20         Digital or PWM-dimmable
WS2812/NeoPixel     256         Custom RMT driver (zero-copy)
TM1637              6 grids     7-segment displays + LEDs
GN1640T             64 LEDs     8x8 matrix (Caution Advisory)
PCA9555             128 outputs 8 devices x 16 I/O each
HT1622              varies      Segment LCD driver (IFEI, UFC)
TFT displays        1           SPI via LovyanGFX
Servo gauges        varies      PWM 50Hz (1000-2000us)

2.5 DEVELOPMENT ENVIRONMENT
---------------------------
REQUIRED:
  - Arduino IDE 2.x (NOT PlatformIO, NOT ESP-IDF directly)
  - ESP32 Arduino Core 3.3.0+ (by Espressif Systems)
  - Python 3.x (for generator scripts)

OPTIONAL:
  - LovyanGFX library (for TFT displays)

BOARD MANAGER URL:
  https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json

==============================================================================
SECTION 3: DCS-BIOS PROTOCOL SPECIFICATION
==============================================================================

3.1 EXPORT PROTOCOL (DCS -> Panel)
----------------------------------
Binary stream format. CockpitOS parses to update LEDs/displays/state.

FRAME STRUCTURE:
  [SYNC: 0x55 0x55 0x55 0x55] [ADDR_LO] [ADDR_HI] [COUNT_LO] [COUNT_HI] [DATA...]

SYNC DETECTION:
  - Four consecutive 0x55 bytes signal frame boundary
  - Address 0x5555 is reserved (rejected as invalid)
  - Address 0xFFFE is MetadataEnd (update complete signal)

DATA FORMAT:
  - All addresses are WORD-aligned (16-bit)
  - Little-endian byte order
  - Integer extraction: (word & mask) >> shift
  - Strings span consecutive addresses

PARSER STATES:
  0 = WAIT_FOR_SYNC    (looking for 0x55 sequence)
  1 = ADDRESS_LOW      (reading address low byte)
  2 = ADDRESS_HIGH     (reading address high byte)
  3 = COUNT_LOW        (reading count low byte)
  4 = COUNT_HIGH       (reading count high byte)
  5 = DATA_LOW         (reading data low byte)
  6 = DATA_HIGH        (reading data high byte)

LISTENER REGISTRATION:
  Default range: 0x0000 to 0xFFFD
  CRITICAL: Use 0xFFFD, NOT 0xFFFE! (See ISSUE-001)

3.2 IMPORT PROTOCOL (Panel -> DCS)
----------------------------------
Plain text commands to UDP port 7778.

FORMAT: <CONTROL_NAME> <VALUE>\n

EXAMPLES:
  MASTER_ARM_SW 1\n                    - Set switch to position 1
  UFC_COMM1_CHANNEL_SELECT +3200\n    - Rotate encoder CW
  UFC_COMM1_CHANNEL_SELECT -3200\n    - Rotate encoder CCW
  ENGINE_CRANK_SW INC\n               - Fixed step increment
  ENGINE_CRANK_SW DEC\n               - Fixed step decrement

THROTTLING DEFAULTS:
  VALUE_THROTTLE_MS     = 50    (same-value debounce)
  ANY_VALUE_THROTTLE_MS = 33    (any-value rate limit)
  SELECTOR_DWELL_MS     = 250   (selector stabilization)

3.3 NETWORK CONFIGURATION
-------------------------
EXPORT (DCS -> World):
  Protocol: UDP Multicast
  Address:  239.255.50.10:5010
  Options:  SO_REUSEADDR required

IMPORT (World -> DCS):
  Protocol: UDP Unicast
  Address:  127.0.0.1:7778
  Format:   Plain text, newline-terminated

3.4 METADATA ADDRESSES
----------------------
0x0000-0x0010  MetadataStart (aircraft name, sync info)
0xFFFE         MetadataEnd (_UPDATE_COUNTER, _UPDATE_SKIP_COUNTER)

Frame completion signal at 0xFFFE indicates:
  1. All string values are consistent
  2. Safe to trigger graphical updates
  3. Safe to run time-consuming operations

==============================================================================
SECTION 4: PROJECT STRUCTURE
==============================================================================

4.1 DIRECTORY LAYOUT
--------------------
CockpitOS/
  CockpitOS.ino              - Main sketch entry point
  Config.h                   - Master configuration
  Pins.h                     - GPIO pin assignments per board
  Mappings.h                 - PanelKind enum, panel definitions
  Mappings.cpp               - CoverGate config, latched buttons
  generate_panelkind.py      - Auto-generates PanelKind enum
  
  src/
    Globals.h                - Cross-module includes and externs
    PanelRegistry.h/cpp      - Panel registration and lifecycle
    HIDManager.h/cpp         - HID abstraction, button/axis handling
    DCSBIOSBridge.h/cpp      - Protocol parsing, subscriptions
    InputControl.h/cpp       - GPIO/HC165/PCA9555 input polling
    HIDDescriptors.h         - USB HID report descriptor
    
    Core/
      LEDControl.cpp         - Unified LED control router
      InputControl.cpp       - Input polling, selector logic
      CoverGate.cpp          - Guarded control state machine
      RingBuffer.cpp         - Non-blocking I/O buffers
      PerfMonitor.h          - Performance profiling (USER-EDITABLE)
      debugPrint.cpp         - Logging abstraction
    
    Panels/
      Generic.cpp            - Default input/LED handling
      IFEIPanel.cpp          - IFEI display panel
      TFT_Gauges_*.cpp       - TFT gauge implementations
      [YourPanel.cpp]        - Custom panel implementations
    
    LABELS/
      active_set.h           - Points to current label set
      LABEL_SET_*/           - Configuration folders
        FA-18C_hornet.json   - Aircraft definition
        selected_panels.txt  - Enabled panels list
        generate_data.py     - Generator script
        InputMapping.h       - Input definitions (USER EDITS)
        LEDMapping.h         - Output definitions (USER EDITS)
        DCSBIOSBridgeData.h  - Auto-generated address tables
  
  lib/
    CUtils/src/              - Hardware Abstraction Layer
      CUtils.h/cpp           - Unified driver API
      internal/              - Driver implementations
    DCS-BIOS/src/            - Protocol library
  
  HID_Manager/               - Python USB HID bridge
    HID_Manager.py
    settings.ini

4.2 FILE EDITING RULES
----------------------
USER MAY EDIT:
  Config.h                   - Transport, features configuration
  Pins.h                     - Only if adding new hardware
  Mappings.cpp               - CoverGate, latched buttons config
  src/Core/PerfMonitor.h     - Custom profiling labels
  src/LABELS/*/InputMapping.h - Input hardware definitions
  src/LABELS/*/LEDMapping.h  - Output hardware definitions
  src/Panels/*.cpp           - Custom panel implementations

USER MUST NOT EDIT:
  src/Core/* (except PerfMonitor.h) - Core infrastructure
  lib/CUtils/*               - HAL drivers
  lib/DCS-BIOS/*             - Protocol implementation
  Auto-generated files       - Will be overwritten by generator

==============================================================================
SECTION 5: LABEL SETS - CONFIGURATION SYSTEM
==============================================================================

5.1 DEFINITION
--------------
A Label Set is a self-contained configuration folder defining:
  - Target aircraft (via JSON file from DCS-BIOS)
  - Included panels (selected_panels.txt)
  - Hardware wiring (InputMapping.h, LEDMapping.h)

Location: src/LABELS/LABEL_SET_XXXX/
Rule: Each ESP32 compiles with exactly ONE label set active.

5.2 LABEL SET CONTENTS
----------------------
LABEL_SET_MYPANEL/
  FA-18C_hornet.json       - Aircraft JSON from DCS-BIOS (ONLY ONE!)
  selected_panels.txt      - Panels to include (user edits)
  panels.txt               - All available panels (reference)
  generate_data.py         - Main generator script
  display_gen.py           - Display-specific generator
  reset_data.py            - Cleanup script
  METADATA/                - Optional JSON overlays
  
  AUTO-GENERATED:
  DCSBIOSBridgeData.h      - Address tables, control types
  InputMapping.h           - Input definitions (user edits preserved)
  LEDMapping.h             - Output definitions (user edits preserved)
  DisplayMapping.cpp/h     - Display field definitions
  CT_Display.cpp/h         - Character buffers
  LabelSetConfig.h         - Metadata, USB PID

5.3 CREATING A NEW LABEL SET
----------------------------
Step 1: Copy existing
  cd src/LABELS/
  cp -r LABEL_SET_IFEI LABEL_SET_MYPANEL

Step 2: Clean auto-generated files
  cd LABEL_SET_MYPANEL
  python reset_data.py

Step 3: Add aircraft JSON
  Copy from: %USERPROFILE%\Saved Games\DCS\Scripts\DCS-BIOS\doc\json\
  Rule: Only ONE JSON file in folder

Step 4: Edit selected_panels.txt
  Uncomment desired panels (case-sensitive, must match panels.txt)

Step 5: Run generator
  python generate_data.py

Step 6: Edit InputMapping.h and LEDMapping.h
  Add hardware assignments (generator preserves edits in marked zones)

Step 7: Compile in Arduino IDE

5.4 SWITCHING LABEL SETS
------------------------
Run: python generate_data.py in desired label set folder
Auto-actions:
  - Sets that label set as active (updates active_set.h)
  - Disables other label sets' .cpp files (renames to .cpp.disabled)

5.5 GENERATOR BEHAVIOR
----------------------
REQUIRES: Python 3.x (standard library only)

ACTIONS:
  1. Parses aircraft JSON file
  2. Reads selected_panels.txt
  3. Generates DCSBIOSBridgeData.h
  4. Creates/updates InputMapping.h (preserves user edits)
  5. Creates/updates LEDMapping.h (preserves user edits)
  6. Generates display mapping files
  7. Updates active_set.h
  8. Disables other label sets

METADATA DIRECTORY:
  Contains JSON overlay files merged with base aircraft JSON
  Use cases: Fix incorrect DCS-BIOS definitions, add custom controls

==============================================================================
SECTION 6: INPUTMAPPING.H - INPUT CONFIGURATION
==============================================================================

6.1 STRUCT DEFINITION
---------------------
struct InputMapping {
  const char* label;       // Unique name (case-sensitive)
  const char* source;      // "GPIO", "HC165", "PCA_0xNN", "TM1637", "MATRIX", "NONE"
  int8_t      port;        // Source-specific (GPIO pin, PCA port 0/1, etc.)
  int8_t      bit;         // Bit index, or -1 for special cases
  int8_t      hidId;       // HID button ID (1-32), or -1 to disable
  const char* oride_label; // DCS-BIOS command name
  uint16_t    oride_value; // Command value (65535 = analog passthrough)
  const char* controlType; // "momentary", "selector", "analog", "variable_step", "fixed_step"
  uint16_t    group;       // Selector group ID (0 = no group)
};

6.2 SOURCE TYPES
----------------
SOURCE       PORT                    BIT                         NOTES
"GPIO"       PIN(x) macro            0=active LOW, 1=active HIGH Direct ESP32 pin
                                     -1=one-hot selector
"HC165"      0 (unused)              0-63 (chain position)       Shift register chain
"PCA_0xNN"   0 or 1 (port)           0-7 (bit in port)           I2C expander
                                     -1=fallback position
"TM1637"     PIN(x) for CLK          0-7 (key index)             Key scanning
"MATRIX"     strobe GPIO pin         pattern value (decimal)     Matrix rotary
"NONE"       0                       0                           Disabled/placeholder

6.3 CONTROL TYPES
-----------------
TYPE            BEHAVIOR                                    ORIDE_VALUE USE
"momentary"     Press=value, Release=0                      Command value (usually 1)
"selector"      Multi-position, mutual exclusivity          Position value (0,1,2...)
"analog"        Continuous pot/axis                         65535 = raw passthrough
"variable_step" Rotary encoder                              0=CCW, 1=CW (sends +/-3200)
"fixed_step"    Fixed increment pulses                      0=DEC, 1=INC (sends INC/DEC)

6.4 PIN(x) MACRO
----------------
Use PIN(x) for ALL GPIO assignments in InputMapping.h
Handles board-specific pin mapping defined in Pins.h
Example: PIN(4) stays 4 on S2, may become 5 on S3

6.5 SELECTOR GROUPS
-------------------
All positions of SAME physical switch MUST share non-zero group ID.

RULES:
  group = 0   -> standalone button (no exclusivity)
  group > 0   -> belongs to selector group
  bit = -1    -> fallback position (active when no other bit active)

EXAMPLE (3-position with neutral):
  { "SW_LEFT",  "HC165", 0, 11, -1, "SW", 2, "selector", 4 },
  { "SW_OFF",   "HC165", 0, -1, -1, "SW", 1, "selector", 4 },  // fallback
  { "SW_RIGHT", "HC165", 0, 12, -1, "SW", 0, "selector", 4 },

6.6 COMPLETE EXAMPLES
---------------------
// Momentary button on GPIO (active LOW)
{ "FIRE_BTN", "GPIO", PIN(5), 0, -1, "FIRE_BTN", 1, "momentary", 0 },

// Momentary button on GPIO (active HIGH)
{ "FIRE_BTN", "GPIO", PIN(5), 1, -1, "FIRE_BTN", 1, "momentary", 0 },

// Three-position selector on HC165 with neutral
{ "ENGINE_CRANK_SW_LEFT",  "HC165", 0, 11, -1, "ENGINE_CRANK_SW", 2, "selector", 4 },
{ "ENGINE_CRANK_SW_OFF",   "HC165", 0, -1, -1, "ENGINE_CRANK_SW", 1, "selector", 4 },
{ "ENGINE_CRANK_SW_RIGHT", "HC165", 0, 12, -1, "ENGINE_CRANK_SW", 0, "selector", 4 },

// One-hot GPIO selector (each position unique GPIO)
{ "MODE_SW_POS0", "GPIO", PIN(33), -1, -1, "MODE_SW", 0, "selector", 21 },
{ "MODE_SW_POS1", "GPIO", PIN(21), -1, -1, "MODE_SW", 1, "selector", 21 },

// Analog potentiometer
{ "VOL_KNOB", "GPIO", PIN(4), 0, -1, "VOL", 65535, "analog", 0 },

// Rotary encoder (variable step)
{ "VOL_DEC", "GPIO", PIN(12), 0, -1, "VOL", 0, "variable_step", 0 },
{ "VOL_INC", "GPIO", PIN(13), 0, -1, "VOL", 1, "variable_step", 0 },

// PCA9555 momentary button with HID
{ "MASTER_ARM", "PCA_0x5B", 0, 2, 16, "MASTER_ARM", 1, "momentary", 0 },

// TM1637 key input
{ "LEFT_FIRE_BTN", "TM1637", PIN(39), 3, -1, "LEFT_FIRE_BTN", 1, "momentary", 0 },

// Disabled placeholder
{ "UNUSED", "NONE", 0, 0, -1, "UNUSED", 0, "momentary", 0 },

==============================================================================
SECTION 7: LEDMAPPING.H - OUTPUT CONFIGURATION
==============================================================================

7.1 STRUCT DEFINITIONS
----------------------
enum LEDDeviceType {
  DEVICE_GPIO,      // Direct GPIO LED
  DEVICE_TM1637,    // TM1637 7-segment/LED
  DEVICE_PCA9555,   // I2C expander output
  DEVICE_WS2812,    // Addressable RGB LED
  DEVICE_GN1640T,   // LED matrix driver
  DEVICE_GAUGE,     // Servo motor gauge
  DEVICE_NONE       // Placeholder/disabled
};

struct LEDMapping {
  const char*    label;      // Unique name (case-sensitive)
  LEDDeviceType  deviceType; // From enum above
  LEDDeviceInfo  info;       // Union with device-specific data
  bool           dimmable;   // true = PWM/intensity control
  bool           activeLow;  // true = ON when output LOW
};

7.2 DEVICE INFO UNION
---------------------
union LEDDeviceInfo {
  struct { uint8_t pin; }                                    gpioInfo;
  struct { uint8_t idx; uint8_t defR,defG,defB,defBright; }  ws2812Info;
  struct { uint8_t clkPin,dioPin,segment,bit; }              tm1637Info;
  struct { uint8_t address,port,bit; }                       pcaInfo;
  struct { uint8_t address,column,row; }                     gn1640Info;
  struct { uint8_t gpio; int minPulse,maxPulse,period; }     gaugeInfo;
};

7.3 DEVICE CONFIGURATIONS
-------------------------
DEVICE_GPIO:
  .gpioInfo = { pin }
  dimmable=false -> digital on/off
  dimmable=true  -> PWM 0-255

DEVICE_WS2812:
  .ws2812Info = { index, defR, defG, defB, defBright }
  index: LED position in chain (0-based)
  defR/G/B: default color (0-255)
  defBright: default brightness (0-255)
  dimmable=true always (intensity control)

DEVICE_TM1637:
  .tm1637Info = { clkPin, dioPin, segment, bit }
  segment: grid position (0-5 typical)
  bit: segment bit within grid (0-7)

DEVICE_PCA9555:
  .pcaInfo = { i2c_address, port, bit }
  i2c_address: 0x20-0x27
  port: 0 or 1
  bit: 0-7

DEVICE_GN1640T:
  .gn1640Info = { address, column, row }
  For Caution Advisory LED matrix

DEVICE_GAUGE:
  .gaugeInfo = { gpio, minPulse, maxPulse, period }
  minPulse/maxPulse: microseconds (typical 1000-2000)
  period: PWM period (20000 for 50Hz)
  dimmable=true always

DEVICE_NONE:
  Placeholder, no hardware connection

7.4 COMPLETE EXAMPLES
---------------------
// Simple GPIO LED (active HIGH)
{ "SPIN_LT", DEVICE_GPIO, { .gpioInfo = { PIN(34) } }, false, false },

// Dimmable GPIO LED (PWM)
{ "BACKLIGHT", DEVICE_GPIO, { .gpioInfo = { PIN(6) } }, true, false },

// Active-LOW GPIO LED
{ "STATUS_LED", DEVICE_GPIO, { .gpioInfo = { PIN(15) } }, false, true },

// WS2812 RGB LED
{ "MASTER_ARM_LT", DEVICE_WS2812, { .ws2812Info = { 0, 0, 255, 0, 200 } }, true, false },

// TM1637 segment
{ "DIGIT_SEG_A", DEVICE_TM1637, { .tm1637Info = { PIN(39), PIN(40), 0, 0 } }, false, false },

// PCA9555 output
{ "ECM_STBY_LT", DEVICE_PCA9555, { .pcaInfo = { 0x5B, 0, 3 } }, false, true },

// GN1640T matrix LED
{ "CAUTION_01", DEVICE_GN1640T, { .gn1640Info = { 0, 0, 0 } }, false, false },

// Servo gauge
{ "FUEL_GAUGE", DEVICE_GAUGE, { .gaugeInfo = { PIN(18), 1000, 2000, 20000 } }, true, false },

// Disabled placeholder
{ "UNUSED_LED", DEVICE_NONE, {}, false, false },

==============================================================================
SECTION 8: PANEL SYSTEM
==============================================================================

8.1 PANELKIND ENUM
------------------
Auto-generated by generate_panelkind.py from src/Panels/*.cpp files.

Two categories:
  PERMANENT: Auto-detected PCA panels (detected via I2C scan at runtime)
  COMPILED:  Panels with REGISTER_PANEL macro (compiled based on HAS_* defines)

8.2 REGISTER_PANEL MACRO
------------------------
REGISTER_PANEL(KIND, INIT, LOOP, DISP_INIT, DISP_LOOP, TICK, PRIORITY);

Parameters:
  KIND:      PanelKind enum entry
  INIT:      void(*)() - called on mission start, or nullptr
  LOOP:      void(*)() - called every frame (~250Hz), or nullptr
  DISP_INIT: void(*)() - display initialization, or nullptr
  DISP_LOOP: void(*)() - display update loop, or nullptr
  TICK:      void(*)() - per-frame tick for LED drivers, or nullptr
  PRIORITY:  uint8_t - lower runs first (default 100)

8.3 PANEL_KIND COMMENT
----------------------
To give panel specific PanelKind identifier:
  // PANEL_KIND: CA
Place in first 30 lines of .cpp file.
If absent, filename (minus .cpp) is used.

8.4 PANEL LIFECYCLE
-------------------
STARTUP:
  setup()
    initMappings()           - Validate InputMapping/LEDMapping
    initializeDisplays()     - Call forEachDisplayInit()
    initializeLEDs()         - Configure LED drivers
    initializePanels(true)   - Call forEachInit() (forced sync)

RUNTIME:
  loop()
    panelLoop()
      PanelRegistry_forEachLoop()
      PanelRegistry_forEachDisplayLoop()
      PanelRegistry_forEachTick()

MISSION START (aircraft name change detected):
  initializePanels(false)    - Re-sync all panels to simulator state

8.5 PANELREGISTRY API
---------------------
void PanelRegistry_register(const PanelHooks& h);  // Auto-called by macro
bool PanelRegistry_has(PanelKind k);               // Check if compiled in
bool PanelRegistry_isActive(PanelKind k);          // Check if running
void PanelRegistry_setActive(PanelKind k, bool);   // Enable/disable runtime
void PanelRegistry_setPresent(PanelKind k, bool);  // For auto-detected panels

8.6 WHEN TO CREATE CUSTOM PANEL
-------------------------------
SCENARIO                          APPROACH
Standard buttons/switches         InputMapping.h + Generic.cpp (automatic)
Standard LEDs                     LEDMapping.h + auto LED tick (automatic)
Complex state machine             Create custom panel .cpp
Custom hardware protocol          Create custom panel .cpp
Display with DCS subscriptions    Create custom panel .cpp
TFT gauge                         Create custom panel (see Section 16)

==============================================================================
SECTION 9: COVERGATE SYSTEM - GUARDED CONTROLS
==============================================================================

9.1 PURPOSE
-----------
Handles physically guarded controls - buttons/switches with protective covers
that must open before control can activate.

9.2 BEHAVIOR SEQUENCE
---------------------
1. User presses guarded button
2. CoverGate opens cover (COVER_LABEL = 1 to DCS)
3. Wait delay_ms (for DCS animation)
4. Send actual button action
5. Wait close_delay_ms
6. Close cover (COVER_LABEL = 0 to DCS)

9.3 CONFIGURATION (Mappings.cpp)
--------------------------------
const CoverGateDef kCoverGates[] = {
    // Selector: { action, release, cover, kind, open_delay, close_delay }
    { "ACTION_LABEL", "RELEASE_LABEL", "COVER_LABEL", CoverGateKind::Selector, 500, 500 },
    
    // Button (no release needed)
    { "FIRE_BTN", nullptr, "FIRE_COVER", CoverGateKind::ButtonMomentary, 350, 300 },
};

9.4 COVERGATEKIND TYPES
-----------------------
Selector:        2-position guarded switch (e.g., HOOK BYPASS)
ButtonMomentary: Fire buttons, emergency buttons
ButtonLatched:   Reserved for future use

9.5 TIMING GUIDELINES
---------------------
Fire buttons:       open=300-400ms, close=250-350ms
Emergency switches: open=400-600ms, close=400-600ms
Selector switches:  open=500ms, close=500ms

==============================================================================
SECTION 10: LATCHED BUTTONS
==============================================================================

10.1 PURPOSE
------------
Some DCS buttons toggle state (press=ON, press again=OFF) rather than
momentary. CockpitOS tracks these to maintain sync.

10.2 CONFIGURATION (Mappings.cpp)
---------------------------------
const char* kLatchedButtons[] = {
    "APU_FIRE_BTN",
    "CMSD_JET_SEL_BTN",
    "RWR_POWER_BTN",
};

10.3 STATE CHECKING API
-----------------------
bool isToggleOn(const char* label);       // Check latched button state
bool isCoverOpen(const char* label);      // Check cover state
void setToggleState(const char* label, bool value);
void setCoverState(const char* label, bool value);

==============================================================================
SECTION 11: CUTILS - HARDWARE ABSTRACTION LAYER API
==============================================================================

ALL hardware access MUST go through CUtils.h.
Panel code NEVER accesses hardware directly.

11.1 GPIO API
-------------
void GPIO_setAllLEDs(bool state);
void GPIO_setDigital(uint8_t pin, bool activeHigh, bool state);
void GPIO_setAnalog(uint8_t pin, bool activeLow, uint8_t intensity);  // PWM 0-255
void GPIO_offAnalog(uint8_t pin, bool activeLow);
void preconfigureGPIO();  // Called during setup()

11.2 WS2812 API
---------------
void WS2812_init();
void WS2812_setLEDColor(uint8_t idx, CRGB color);
void WS2812_allOn(CRGB color);
void WS2812_allOff();
void WS2812_tick();  // MUST call every frame to commit changes

11.3 TM1637 API
---------------
void tm1637_init(TM1637Device& dev, uint8_t clk, uint8_t dio);
uint8_t tm1637_readKeys(TM1637Device& dev);  // Returns key bitmap
void tm1637_displaySingleLED(TM1637Device& dev, uint8_t grid, uint8_t seg, bool on);
void tm1637_tick();   // Commits all changes
void tm1637_allOn();
void tm1637_allOff();

11.4 GN1640T API
----------------
void GN1640_init(uint8_t clkPin, uint8_t dioPin);
void GN1640_setLED(uint8_t row, uint8_t col, bool state);
void GN1640_allOn();
void GN1640_allOff();
void GN1640_tick();  // Commits all changes

11.5 PCA9555 API
----------------
void PCA9555_scanConnectedPanels();  // Detects connected expanders
bool readPCA9555(uint8_t addr, byte& p0, byte& p1);  // Read both ports
void PCA9555_write(uint8_t addr, uint8_t port, uint8_t bit, bool state);
void PCA9555_autoInitFromLEDMap(uint8_t addr);  // Configure from LEDMapping
void PCA9555_allOn(uint8_t addr);
void PCA9555_allOff(uint8_t addr);

11.6 HC165 API
--------------
void HC165_init(uint8_t pinPL, uint8_t pinCP, uint8_t pinQH, uint8_t numBits);
uint64_t HC165_read();  // Returns all bits (up to 64)

11.7 ANALOG GAUGE API
---------------------
void AnalogG_registerGauge(uint8_t pin, int minPulseUs, int maxPulseUs);
void AnalogG_set(uint8_t pin, uint16_t value);  // 0-65535 -> minPulse-maxPulse
void AnalogG_tick();  // Call every 20ms for PWM generation

11.8 HT1622 API
---------------
void HT1622_init(uint8_t csPin, uint8_t wrPin, uint8_t dataPin);
void HT1622_writeRaw(uint8_t addr, uint8_t data);
void HT1622_clear();
// Segment mapping via SegmentMap headers from RAM Walker tool

==============================================================================
SECTION 12: HIDMANAGER - INPUT LOGIC LAYER API
==============================================================================

Handles all high-level input logic: button actions, selector groups,
throttling, HID report construction, DCS/HID mode switching.

12.1 BUTTON/SELECTOR API
------------------------
void HIDManager_setNamedButton(const char* label, bool deferSend, bool pressed);
  // Main entry for button/selector actions
  // deferSend=true -> buffer for later commit (during init)
  // pressed=true -> button down, false -> button up

void HIDManager_toggleIfPressed(bool isPressed, const char* label, bool deferSend);
  // For latched buttons - toggles state on rising edge only

void HIDManager_commitDeferredReport(const char* reason);
  // Flushes buffered HID reports

void HIDManager_dispatchReport(bool force);
  // Sends HID report (respects rate limiting unless force=true)

12.2 AXIS API
-------------
void HIDManager_moveAxis(const char* dcsId, uint8_t pin, HIDAxis axis,
                         bool force, bool defer);
  // Reads analog pin, applies smoothing, sends to DCS and/or HID

enum HIDAxis {
    AXIS_X = 0, AXIS_Y, AXIS_Z,
    AXIS_RX, AXIS_RY, AXIS_RZ,
    AXIS_DIAL, AXIS_SLIDER,
    // ... up to 16 axes total
    HID_AXIS_COUNT
};

12.3 DCS COMMAND API
--------------------
void sendDCSBIOSCommand(const char* label, uint16_t value, bool force);
  // Queues command, force=true bypasses throttling

bool tryToSendDcsBiosMessage(const char* msg, const char* arg);
  // Low-level send with string argument
  // Used for variable_step (+3200/-3200), fixed_step (INC/DEC)

12.4 MODE API
-------------
bool isModeSelectorDCS();
  // Returns true if DCS mode, false if HID-only mode

12.5 AXIS CALIBRATION CONFIG
----------------------------
Self-learning calibration. Thresholds in Config.h:
  MIDDLE_AXIS_THRESHOLD    = 64   // Center deadzone
  UPPER_AXIS_THRESHOLD     = 128  // Upper deadzone
  LOWER_AXIS_THRESHOLD     = 128  // Lower deadzone
  CENTER_DEADZONE_INNER    = 256  // Entry threshold
  CENTER_DEADZONE_OUTER    = 384  // Exit threshold

==============================================================================
SECTION 13: DCSBIOSBRIDGE - PROTOCOL LAYER API
==============================================================================

Handles DCS-BIOS protocol: parsing, subscription dispatch, command history.

13.1 SUBSCRIPTION API
---------------------
// String data (display fields)
bool subscribeToDisplayChange(const char* label,
    void (*callback)(const char* label, const char* value));

// Switch positions
bool subscribeToSelectorChange(const char* label,
    void (*callback)(const char* label, uint16_t value));

// LED states
bool subscribeToLedChange(const char* label,
    void (*callback)(const char* label, uint16_t value, uint16_t max_value));

// Metadata values
bool subscribeToMetadataChange(const char* label,
    void (*callback)(const char* label, uint16_t value));

13.2 DATA ACCESS API
--------------------
bool isCoverOpen(const char* label);
bool isToggleOn(const char* label);
void setCoverState(const char* label, bool value);
void setToggleState(const char* label, bool value);
const char* getLastValueForDisplayLabel(const char* label);
uint16_t getMetadataValue(const char* label);
uint16_t getLastKnownState(const char* label);

13.3 DISPLAY BUFFER API
-----------------------
bool registerDisplayBuffer(const char* label, char* buf, uint8_t len,
                          bool* dirtyFlag, char* lastBuf);
  // Registers buffer to receive string updates
  // dirtyFlag set true when data changes
  // lastBuf used for change detection

13.4 MISSION API
----------------
bool isMissionRunning();
uint32_t msSinceMissionStart();
bool isPanelsSyncedThisMission();

13.5 COMMAND HISTORY
--------------------
CommandHistoryEntry* findCmdEntry(const char* label);

struct CommandHistoryEntry {
    const char* label;
    uint16_t lastValue;
    uint16_t pendingValue;
    unsigned long lastSendTime;
    unsigned long lastChangeTime;
    uint16_t group;
    bool isSelector;
    bool hasPending;
};

==============================================================================
SECTION 14: TRANSPORT MODES
==============================================================================

14.1 SELECTION (Config.h)
-------------------------
Only ONE active at a time:

#define USE_DCSBIOS_USB        1  // Native USB HID (S2/S3/P4 only)
#define USE_DCSBIOS_WIFI       0  // WiFi UDP
#define USE_DCSBIOS_SERIAL     0  // Legacy serial
#define USE_DCSBIOS_BLUETOOTH  0  // BLE (see Section 24)

14.2 USB HID MODE (RECOMMENDED)
-------------------------------
Advantages: Lowest latency, no network config, simplest setup
Requirements:
  - ESP32-S2/S3/P4 (native USB)
  - HID_Manager.py on host PC
  - S3/P4: Tools -> USB Mode -> "USB-OTG (TinyUSB)"

Protocol:
  - 64-byte HID reports (16 axes + 32 buttons + padding)
  - Feature reports for bidirectional DCS-BIOS data
  - VID/PID: 0xCAFE (configurable)

14.3 WIFI MODE
--------------
Advantages: Wireless operation
Requirements:
  - Configure WIFI_SSID and WIFI_PASS in Config.h
  - ESP32 with WiFi (all except H2)

Protocol:
  - Multicast receive: 239.255.50.10:5010 (export)
  - Unicast send: 127.0.0.1:7778 (import)

14.4 SERIAL MODE
----------------
Advantages: Works on all variants, useful for debugging
Requirements:
  - socat bridge on host PC
  - connect-serial-port.cmd from DCS-BIOS

Protocol:
  - Raw DCS-BIOS stream over CDC/UART
  - 115200 baud typical

14.5 TRANSPORT SELECTION GUIDE
------------------------------
ESP32-S2/S3/P4 + want lowest latency?  -> USE_DCSBIOS_USB = 1
Want wireless?                          -> USE_DCSBIOS_WIFI = 1
ESP32 Classic or C3/C6?                 -> USE_DCSBIOS_SERIAL or WIFI
ESP32-H2 (no WiFi)?                     -> USE_DCSBIOS_BLUETOOTH = 1

==============================================================================
SECTION 15: CONFIG.H - MASTER CONFIGURATION
==============================================================================

15.1 TRANSPORT
--------------
USE_DCSBIOS_BLUETOOTH    0  // BLE transport
USE_DCSBIOS_WIFI         0  // WiFi UDP
USE_DCSBIOS_USB          0  // Native USB HID (recommended)
USE_DCSBIOS_SERIAL       1  // Legacy serial (default)

15.2 HARDWARE FEATURES
----------------------
ENABLE_TFT_GAUGES         0  // TFT display support
ENABLE_PCA9555            0  // I2C expander support
SEND_HID_AXES_IN_DCS_MODE 0  // Send HID axes in DCS mode

15.3 AXIS CALIBRATION
---------------------
MIDDLE_AXIS_THRESHOLD     64   // Center deadzone
UPPER_AXIS_THRESHOLD      128  // Upper deadzone
LOWER_AXIS_THRESHOLD      128  // Lower deadzone
CENTER_DEADZONE_INNER     256  // Center lock entry
CENTER_DEADZONE_OUTER     384  // Center lock exit

15.4 WIFI
---------
WIFI_SSID                "TestNetwork"
WIFI_PASS                "TestingOnly"

15.5 DEBUG
----------
DEBUG_ENABLED                      0  // Master debug switch
DEBUG_LISTENERS_AT_STARTUP         0  // Protocol debug
VERBOSE_MODE                       0  // Info to Serial+UDP
VERBOSE_MODE_SERIAL_ONLY           0  // Serial only
VERBOSE_MODE_WIFI_ONLY             0  // UDP only
DEBUG_PERFORMANCE                  0  // Performance profiling
DEBUG_PERFORMANCE_SHOW_TASKS       0  // FreeRTOS task list
PERFORMANCE_SNAPSHOT_INTERVAL_SECONDS 60
DEBUG_ENABLED_FOR_PCA_ONLY         0  // PCA9555 debug
DEBUG_ENABLED_FOR_HC165_ONLY       0  // HC165 debug
DEBUG_ENABLED_FOR_TM1637_ONLY      0  // TM1637 debug
TEST_LEDS                          0  // Interactive LED test
IS_REPLAY                          0  // Simulated DCS stream

15.6 TIMING
-----------
POLLING_RATE_HZ           250   // Input polling (4ms)
DISPLAY_REFRESH_RATE_HZ   60    // Display update (16ms)
DCS_UPDATE_RATE_HZ        30    // DCS-BIOS loop (33ms)
HID_REPORT_RATE_HZ        250   // HID reports (4ms)
VALUE_THROTTLE_MS         50    // Same-value debounce
ANY_VALUE_THROTTLE_MS     33    // Any-value rate limit
SELECTOR_DWELL_MS         250   // Selector stabilization

==============================================================================
SECTION 16: TFT DISPLAY SYSTEM
==============================================================================

16.1 LIBRARY
------------
All TFT displays use LovyanGFX: https://github.com/lovyan03/LovyanGFX

EXCEPTION TO NO-HEAP RULE:
TFT sprites MAY use dynamic memory (PSRAM preferred).
This is the ONLY exception to zero-heap constraint.

16.2 IDEASPARK ST7789 CONFIGURATION
-----------------------------------
CRITICAL SETTINGS (discovered through debugging):

  cfg.pin_rst       = 4;     // MUST be GPIO 4, NOT -1!
  cfg.memory_width  = 240;
  cfg.memory_height = 320;
  cfg.panel_width   = 170;
  cfg.panel_height  = 320;
  cfg.offset_x      = 35;
  cfg.offset_y      = 0;
  cfg.invert        = true;
  cfg.rgb_order     = false;
  setRotation(3);            // Landscape

16.3 TFT TASK PATTERN
---------------------
TFT gauges typically run as FreeRTOS tasks for isolation.
See Section 25 for FreeRTOS details.

16.4 DESIGN PRINCIPLES
----------------------
1. Precompute geometry once in init (ticks, arcs, etc.)
2. Use dirty-rect tracking for incremental updates
3. Snapshot state under critical section (portENTER_CRITICAL)
4. Use DMA bounce buffers in internal RAM for SPI
5. Cache backgrounds in PSRAM when available

16.5 REFERENCE IMPLEMENTATIONS
------------------------------
TFT_Display_CMWS.cpp       - Threat ring display
TFT_Gauges_RadarAlt.cpp    - Analog gauge
TFT_Gauges_CabinPressure.cpp - Circular gauge

==============================================================================
SECTION 17: HT1622 SEGMENT DISPLAYS
==============================================================================

17.1 PURPOSE
------------
HT1622 drives segment LCD panels (IFEI, UFC displays).
Segments mapped via SegmentMap headers created with RAM Walker tool.

17.2 SEGMENT ORDER
------------------
Font tables expect: [0]=TOP, [1]=TOP-RIGHT, [2]=BOT-RIGHT, [3]=BOTTOM,
                    [4]=BOT-LEFT, [5]=TOP-LEFT, [6]=MIDDLE

17.3 RAM WALKER TOOL
--------------------
Location: Tools/RAM_Walker/
Purpose: Discover which RAM address/bit controls each segment
Output: SegmentMap header files for your specific LCD

==============================================================================
SECTION 18: DEBUGGING & PERFORMANCE
==============================================================================

18.1 DEBUG OUTPUT RULES
-----------------------
NEVER: Serial.print(), Serial.println(), Serial.printf()
ALWAYS: debugPrint(), debugPrintln(), debugPrintf()

These route to Serial OR WiFi UDP based on config.

18.2 WIFI DEBUG
---------------
Enable: DEBUG_USE_WIFI = 1 in Config.h
Sends debug via UDP for remote monitoring.

18.3 REPLAY MODE
----------------
Enable: IS_REPLAY = 1
Uses captured binary data for testing without DCS.

18.4 PERFMONITOR
----------------
PerfMonitor.h is the ONLY Core file users may edit.

Add custom labels:
  enum PerfLabel {
      PERF_LED_GPIO,
      PERF_LED_PCA9555,
      PERF_MY_PANEL,    // Add your own
  };

Usage in code:
  #if DEBUG_PERFORMANCE
      beginProfiling(PERF_MY_PANEL);
  #endif
      // ... code to measure ...
  #if DEBUG_PERFORMANCE
      endProfiling(PERF_MY_PANEL);
  #endif

Enable: DEBUG_PERFORMANCE = 1

18.5 DEBUG SCENARIO REFERENCE
-----------------------------
SCENARIO                     CONFIG FLAG
PCA9555 expander issues      DEBUG_ENABLED_FOR_PCA_ONLY = 1
HC165 shift register issues  DEBUG_ENABLED_FOR_HC165_ONLY = 1
TM1637 display/key issues    DEBUG_ENABLED_FOR_TM1637_ONLY = 1
LED mapping verification     TEST_LEDS = 1
Protocol parsing issues      DEBUG_LISTENERS_AT_STARTUP = 1
Performance profiling        DEBUG_PERFORMANCE = 1

==============================================================================
SECTION 19: ANTI-PATTERNS - WHAT NOT TO DO
==============================================================================

19.1 MEMORY VIOLATIONS
----------------------
WRONG: String myString = "hello";
RIGHT: static const char myString[] = "hello";

WRONG: std::vector<int> values;
RIGHT: static int values[MAX_VALUES];

WRONG: char* buf = new char[64];
RIGHT: static char buf[64];

WRONG: char* buf = (char*)malloc(64);
RIGHT: static char buf[64];

19.2 BLOCKING VIOLATIONS
------------------------
WRONG: delay(100);
RIGHT: Non-blocking state machine with millis()

WRONG: while (!Serial.available()) { }
RIGHT: if (Serial.available()) { /* process */ }

WRONG: Wire.requestFrom(...); while (!Wire.available()) { }
RIGHT: if (Wire.requestFrom(...) == expectedBytes) { }

19.3 LOGGING VIOLATIONS
-----------------------
WRONG: Serial.println("Debug");
RIGHT: debugPrintln("Debug");

WRONG: Serial.printf("Value: %d\n", val);
RIGHT: debugPrintf("Value: %d\n", val);

19.4 HARDWARE ACCESS VIOLATIONS
-------------------------------
WRONG: digitalWrite(LED_PIN, HIGH);
RIGHT: GPIO_setDigital(LED_PIN, true, true);

WRONG: analogRead(POT_PIN);
RIGHT: HIDManager_moveAxis("LABEL", POT_PIN, AXIS_X, false, false);

19.5 UNBOUNDED LOOP VIOLATIONS
------------------------------
WRONG: while (searching) { /* no limit */ }
RIGHT: for (int i = 0; i < MAX_ITER && searching; i++) { }

WRONG: for (;;) { /* forever */ }
RIGHT: for (size_t i = 0; i < ARRAY_SIZE; i++) { }

19.6 ADDRESS RANGE VIOLATIONS
-----------------------------
WRONG: ExportStreamListener(0x0000, 0xFFFE)
RIGHT: ExportStreamListener(0x0000, 0xFFFD)

==============================================================================
SECTION 20: DECISION TREES
==============================================================================

20.1 INPUT APPROACH
-------------------
Simple button?
  -> InputMapping.h + Generic.cpp (automatic)

Multi-position selector?
  -> InputMapping.h with same group ID for all positions
  -> Include fallback (bit=-1) for neutral

Potentiometer axis?
  -> InputMapping.h, controlType="analog", oride_value=65535

Rotary encoder?
  -> InputMapping.h with two entries:
     CCW: controlType="variable_step", oride_value=0
     CW:  controlType="variable_step", oride_value=1

20.2 OUTPUT APPROACH
--------------------
Simple LED?
  -> LEDMapping.h + auto LED tick (automatic)

TFT gauge?
  -> Create src/Panels/TFT_Gauges_XXX.cpp
  -> Follow TFT_Gauges_RadarAlt.cpp as template
  -> Run as FreeRTOS task

Custom state machine?
  -> Create src/Panels/XXX.cpp with REGISTER_PANEL

20.3 TRANSPORT SELECTION
------------------------
ESP32-S2/S3/P4 + lowest latency?
  -> USE_DCSBIOS_USB = 1

Wireless operation?
  -> USE_DCSBIOS_WIFI = 1

ESP32 Classic/C3/C6?
  -> USE_DCSBIOS_SERIAL or WIFI

ESP32-H2?
  -> USE_DCSBIOS_BLUETOOTH = 1

20.4 DEBUGGING APPROACH
-----------------------
Debug without DCS?
  -> IS_REPLAY = 1

Test LED wiring?
  -> TEST_LEDS = 1

Profile performance?
  -> DEBUG_PERFORMANCE = 1

Debug specific hardware?
  -> DEBUG_ENABLED_FOR_*_ONLY = 1

==============================================================================
SECTION 21: TROUBLESHOOTING
==============================================================================

21.1 COMPILATION ERRORS
-----------------------
ERROR: "undefined reference to InputMappings"
FIX:   Run python generate_data.py in label set folder

ERROR: "PIN not declared"
FIX:   Ensure #include "Config.h", check Pins.h

ERROR: "Duplicate label"
FIX:   Each label in InputMapping/LEDMapping must be unique

ERROR: "LABEL_SET not defined"
FIX:   Run python generate_data.py to set active label set

21.2 RUNTIME ISSUES
-------------------
ERROR: "LED label not found"
FIX:   Labels are CASE-SENSITIVE, check LEDMapping.h exactly

ERROR: "TM1637: no device for CLK/DIO"
FIX:   Ensure at least one TM1637 entry in LEDMapping.h

ISSUE: Selector not responding
FIX:   Check all positions share same group ID
       Verify fallback position has bit=-1
       Check SELECTOR_DWELL_MS

ISSUE: LED always on/off
FIX:   Check activeLow flag matches wiring

ISSUE: Encoder skipping steps
FIX:   Check pullup/pulldown config
       Verify encoder common (GND or VCC)

21.3 USB/CONNECTION ISSUES
--------------------------
ISSUE: Device not detected
FIX:   Verify USB VID (0xCAFE default)
       Try different USB cable (must be data-capable!)
       Try different USB port
       Check Device Manager/dmesg

ISSUE: Handshake fails
FIX:   Ensure USE_DCSBIOS_USB = 1
       Power cycle device
       Press RST after upload
       S3/P4: Verify USB-OTG mode

ISSUE: HID_Manager.py not finding device
FIX:   pip install hidapi
       Windows: pip install windows-curses
       Check settings.ini VID

21.4 DCS CONNECTION ISSUES
--------------------------
ISSUE: No response from DCS
FIX:   Verify DCS-BIOS installed and enabled
       Check transport config matches setup
       Ensure aircraft JSON matches loaded aircraft
       WiFi: Check firewall (UDP 5010/7778)

ISSUE: Panel not syncing on mission start
FIX:   Aircraft name might not match JSON filename
       Check serial monitor for detection messages

ISSUE: Commands not reaching DCS
FIX:   Check command throttling (VALUE_THROTTLE_MS)
       Check HID_Manager.py console
       WiFi: Verify UDP 7778 reaching DCS

21.5 TFT DISPLAY ISSUES
-----------------------
ISSUE: Display blank or corrupted
FIX:   IdeasPark ST7789: TFT_RST MUST be GPIO 4!
       Check SPI pin assignments
       Verify memory vs panel width/height offsets
       Try lower SPI frequency (40MHz)

ISSUE: Colors wrong
FIX:   Check invert and rgb_order settings
       Try toggling setSwapBytes()

ISSUE: Display rotated wrong
FIX:   Adjust setRotation() (0-3)

==============================================================================
SECTION 22: QUICK REFERENCE TABLES
==============================================================================

22.1 FILE LOCATIONS
-------------------
Main sketch:       CockpitOS.ino
Configuration:     Config.h
Pin assignments:   Pins.h
Panel definitions: Mappings.h, Mappings.cpp
Label sets:        src/LABELS/LABEL_SET_*/
Panel code:        src/Panels/*.cpp
HAL drivers:       lib/CUtils/src/internal/*.cpp
Core modules:      src/Core/*.cpp
HID Manager:       HID_Manager/HID_Manager.py

22.2 CONTROL TYPES
------------------
momentary       Button press/release
selector        Multi-position switch (use group)
analog          Continuous pot (oride_value=65535)
variable_step   Encoder (+3200/-3200)
fixed_step      Fixed pulses (INC/DEC)

22.3 DEVICE TYPES
-----------------
DEVICE_GPIO     Direct GPIO (PWM if dimmable=true)
DEVICE_WS2812   Addressable RGB
DEVICE_TM1637   7-segment display/LED
DEVICE_PCA9555  I2C expander output
DEVICE_GN1640T  LED matrix
DEVICE_GAUGE    Servo motor
DEVICE_NONE     Placeholder/disabled

22.4 HAS_* DEFINES
------------------
(always):                    Generic
HAS_MAIN:                    LA, RA, LockShoot
HAS_CUSTOM_RIGHT:            CA, WingFold, TFTRadarAlt, TFTHyd
HAS_IFEI:                    IFEI, JETTSEL
HAS_ALR67:                   TFTCabPress
HAS_RIGHT_PANEL_CONTROLLER:  TFTBatt

22.5 GENERATOR SCRIPTS
----------------------
generate_data.py       Main generator (run from label set)
display_gen.py         Display generation (called by main)
reset_data.py          Clean auto-generated files
generate_panelkind.py  Generate PanelKind.h (run from root)

22.6 TIMING
-----------
Input polling:    250 Hz (4ms)
Display refresh:  30-60 Hz (16-33ms)
DCS-BIOS loop:    30 Hz (33ms)
HID reports:      250 Hz (4ms)
Selector dwell:   250ms
Command throttle: 33-50ms

==============================================================================
SECTION 23: HID_MANAGER.PY (PYTHON HOST APPLICATION)
==============================================================================

23.1 PURPOSE
------------
Python USB HID bridge between ESP32 panels and DCS-BIOS.
Replaces legacy Serial/CDC + socat approach.

23.2 FEATURES
-------------
- Near-zero CPU (~0% idle, <1% active)
- Native USB HID (no serial drivers)
- Multi-device support (up to 32 panels)
- Auto device discovery and hot-plug
- Cross-platform (Windows, Linux, RPi)

23.3 REQUIREMENTS
-----------------
Python 3.8+
pip install hidapi filelock
Windows: pip install windows-curses

23.4 CONFIGURATION (settings.ini)
---------------------------------
[USB]
VID = 0xCAFE

[DCS]
UDP_SOURCE_IP = 127.0.0.1

[MAIN]
CONSOLE = 1

23.5 THREAD MODEL
-----------------
UDP RX:       Receive DCS-BIOS frames (blocking recvfrom)
Device RX:    Read input per device (blocking hid.read)
Device TX:    Write HID reports per device (Condition.wait)
Hotplug:      Detect connect/disconnect (polling)
Stats:        Calculate Hz, bandwidth (polling)
UI:           Console rendering (getch timeout)

==============================================================================
SECTION 24: BLE/BLUETOOTH TRANSPORT
==============================================================================

24.1 OVERVIEW
-------------
BLE transport for ESP32 variants without WiFi (H2) or wireless without
network infrastructure.

24.2 BLEMANAGER CONFIGURATION
-----------------------------
Version: 2.2 (finalized December 2024, multi-AI peer reviewed)

Key compile-time settings:
  BLE_SLAVE_LATENCY      - Battery optimization (higher = lower power)
  BLE_CONNECTION_INTERVAL - Response time vs power tradeoff

24.3 SUPPORTED VARIANTS
-----------------------
ESP32-H2:  BLE only (no WiFi) - primary use case
ESP32-C3:  BLE available
ESP32-S3:  BLE available (but USB/WiFi preferred)
ESP32 Classic: BLE available

24.4 POWER OPTIMIZATION
-----------------------
For battery-operated devices:
  - BLE_SLAVE_LATENCY = 10-30 (higher saves power)
  - 25ms latency minimum provides negligible user benefit vs power cost
  - Deep sleep transitions require proper GPIO configuration

24.5 BLE GAMEPAD MODE
---------------------
BLE_Gamepad_Standalone project derives from CockpitOS BLEManager v2.2.
Features:
  - Self-learning axis calibration
  - No Windows calibration required
  - Optimized for competitive gaming

==============================================================================
SECTION 25: FREERTOS TASK MANAGEMENT
==============================================================================

25.1 WHEN TO USE TASKS
----------------------
USE TASKS FOR:
  - TFT gauge rendering (isolation from main loop)
  - Long-running operations that must not block
  - Operations requiring precise timing

DO NOT USE TASKS FOR:
  - Simple button/LED handling (use main loop)
  - Operations that can complete in <1ms

25.2 TASK CREATION PATTERN
--------------------------
#define TASK_STACK_SIZE  4096   // Bytes (adjust based on needs)
#define TASK_PRIORITY    1      // 0=idle, higher=more priority
#define TASK_CORE        1      // 0 or 1 (1 preferred for user tasks)

static TaskHandle_t s_taskHandle = nullptr;
static volatile bool g_taskStopRequested = false;

void createMyTask() {
    xTaskCreatePinnedToCore(
        myTaskFunction,         // Task function
        "MyTask",              // Name (for debugging)
        TASK_STACK_SIZE,
        nullptr,               // Parameter
        TASK_PRIORITY,
        &s_taskHandle,
        TASK_CORE
    );
}

25.3 TASK FUNCTION PATTERN
--------------------------
static void myTaskFunction(void* param) {
    (void)param;
    TickType_t lastWakeTime = xTaskGetTickCount();
    const TickType_t interval = pdMS_TO_TICKS(33);  // ~30 FPS
    
    while (!g_taskStopRequested) {
        // Do work here
        myTask_update();
        
        // Wait for next interval
        vTaskDelayUntil(&lastWakeTime, interval);
    }
    
    vTaskDelete(nullptr);  // Clean exit
}

25.4 TASK CLEANUP PATTERN
-------------------------
void stopMyTask() {
    if (s_taskHandle != nullptr) {
        g_taskStopRequested = true;
        vTaskDelay(pdMS_TO_TICKS(100));  // Allow task to exit
        s_taskHandle = nullptr;
        g_taskStopRequested = false;
    }
}

25.5 CRITICAL SECTIONS
----------------------
For shared data between task and main loop:

portMUX_TYPE myMux = portMUX_INITIALIZER_UNLOCKED;

// In task:
portENTER_CRITICAL(&myMux);
localCopy = sharedData;  // Snapshot
portEXIT_CRITICAL(&myMux);

// In main loop:
portENTER_CRITICAL(&myMux);
sharedData = newValue;
portEXIT_CRITICAL(&myMux);

25.6 STACK SIZE GUIDELINES
--------------------------
Simple task (no large buffers):     2048 bytes
TFT gauge task:                     4096 bytes
Task with local arrays:             8192+ bytes

Check with: uxTaskGetStackHighWaterMark(s_taskHandle)
If returns < 200, increase stack size.

25.7 PRIORITY GUIDELINES
------------------------
0:  Idle priority (not recommended)
1:  Normal user tasks (default)
2:  Time-sensitive user tasks
3+: Reserved for system tasks

==============================================================================
SECTION 26: MULTI-AIRCRAFT SUPPORT
==============================================================================

26.1 HOW AIRCRAFT DETECTION WORKS
---------------------------------
1. DCS-BIOS exports aircraft name at address 0x0000
2. CockpitOS parses name from MetadataStart block
3. On name change, CockpitOS triggers panel re-initialization
4. Panels re-sync their state to new aircraft values

26.2 LABEL SET AND AIRCRAFT
---------------------------
Each Label Set contains ONE aircraft JSON.
The JSON filename should match DCS-BIOS aircraft identifier.

Example aircraft identifiers:
  FA-18C_hornet
  A-10C
  F-16C_50
  AV8BNA

26.3 SWITCHING AIRCRAFT MID-SESSION
-----------------------------------
When user loads different aircraft in DCS:
1. DCS-BIOS sends new aircraft name
2. CockpitOS detects name change in protocol parser
3. initializePanels(false) called to re-sync
4. All subscriptions receive updated values

26.4 MULTI-AIRCRAFT LABEL SETS
------------------------------
For cockpit builds supporting multiple aircraft:
  - Create separate Label Sets for each aircraft
  - Recompile firmware when switching aircraft
  - OR use single Label Set with superset of controls

26.5 CRITICAL BUG (ISSUE-001)
-----------------------------
When implementing multi-aircraft support, use:
  ExportStreamListener(0x0000, 0xFFFD)
NOT:
  ExportStreamListener(0x0000, 0xFFFE)

Using 0xFFFE causes flush timing issues with chunked HID transmission,
breaking multi-aircraft detection.

==============================================================================
SECTION 27: CODE TEMPLATES (COPY-PASTE READY)
==============================================================================

27.1 MINIMAL PANEL TEMPLATE
---------------------------
// MyPanel.cpp
// PANEL_KIND: MyPanel

#include "../Globals.h"
#include "../HIDManager.h"
#include "../DCSBIOSBridge.h"

#if defined(HAS_MY_PANEL)

static void MyPanel_init() {
    // Called on mission start
    // Subscribe to DCS-BIOS data here
}

static void MyPanel_loop() {
    // Called every frame (~250Hz)
    // Keep this FAST (<1ms)
}

REGISTER_PANEL(MyPanel, MyPanel_init, MyPanel_loop, nullptr, nullptr, nullptr, 100);

#endif // HAS_MY_PANEL

27.2 PANEL WITH DCS-BIOS SUBSCRIPTION
-------------------------------------
// MyDisplay.cpp
// PANEL_KIND: MyDisplay

#include "../Globals.h"
#include "../DCSBIOSBridge.h"

#if defined(HAS_MY_DISPLAY)

static char s_displayBuf[8];
static char s_lastBuf[8];
static bool s_dirty = false;

static void onDisplayChange(const char* label, const char* value) {
    // Called when subscribed value changes
    s_dirty = true;
}

static void onSelectorChange(const char* label, uint16_t value) {
    // Called when selector position changes
}

static void MyDisplay_init() {
    subscribeToDisplayChange("UFC_COMM1_DISPLAY", onDisplayChange);
    subscribeToSelectorChange("MASTER_ARM_SW", onSelectorChange);
    registerDisplayBuffer("UFC_COMM1_DISPLAY", s_displayBuf, 
                         sizeof(s_displayBuf), &s_dirty, s_lastBuf);
}

static void MyDisplay_loop() {
    if (s_dirty) {
        s_dirty = false;
        // Update display hardware with s_displayBuf
    }
}

REGISTER_PANEL(MyDisplay, MyDisplay_init, MyDisplay_loop, nullptr, nullptr, nullptr, 100);

#endif // HAS_MY_DISPLAY

27.3 TFT GAUGE TASK TEMPLATE
----------------------------
// TFT_Gauges_MyGauge.cpp
// PANEL_KIND: TFTMyGauge

#include "../Globals.h"
#include "../DCSBIOSBridge.h"
#include <LovyanGFX.hpp>

#if defined(HAS_TFT_MY_GAUGE) && ENABLE_TFT_GAUGES

#define REFRESH_INTERVAL_MS 33
#define TASK_STACK_SIZE 4096
#define TASK_PRIORITY 1
#define TASK_CORE 1

class LGFX_MyGauge : public lgfx::LGFX_Device {
    // LovyanGFX configuration here
};

static LGFX_MyGauge s_display;
static LGFX_Sprite s_sprite(&s_display);
static TaskHandle_t s_taskHandle = nullptr;
static volatile bool g_taskStopRequested = false;

static uint16_t s_currentValue = 0;
static portMUX_TYPE s_mux = portMUX_INITIALIZER_UNLOCKED;

static void onValueChange(const char* label, uint16_t value, uint16_t maxValue) {
    portENTER_CRITICAL(&s_mux);
    s_currentValue = value;
    portEXIT_CRITICAL(&s_mux);
}

static void TFTMyGauge_draw() {
    uint16_t localValue;
    portENTER_CRITICAL(&s_mux);
    localValue = s_currentValue;
    portEXIT_CRITICAL(&s_mux);
    
    // Draw gauge using localValue
    s_sprite.fillScreen(TFT_BLACK);
    // ... drawing code ...
    s_sprite.pushSprite(0, 0);
}

static void TFTMyGauge_task(void* param) {
    (void)param;
    TickType_t lastWakeTime = xTaskGetTickCount();
    
    while (!g_taskStopRequested) {
        TFTMyGauge_draw();
        vTaskDelayUntil(&lastWakeTime, pdMS_TO_TICKS(REFRESH_INTERVAL_MS));
    }
    
    vTaskDelete(nullptr);
}

static void TFTMyGauge_displayInit() {
    s_display.init();
    s_display.setRotation(3);
    s_sprite.createSprite(170, 320);  // Adjust for your display
}

static void TFTMyGauge_init() {
    subscribeToLedChange("MY_GAUGE_VALUE", onValueChange);
    
    xTaskCreatePinnedToCore(
        TFTMyGauge_task,
        "TFTMyGauge",
        TASK_STACK_SIZE,
        nullptr,
        TASK_PRIORITY,
        &s_taskHandle,
        TASK_CORE
    );
}

static void TFTMyGauge_loop() {
    // Main loop can be empty if task handles everything
}

REGISTER_PANEL(TFTMyGauge, TFTMyGauge_init, TFTMyGauge_loop, 
               TFTMyGauge_displayInit, nullptr, nullptr, 100);

#endif // HAS_TFT_MY_GAUGE && ENABLE_TFT_GAUGES

27.4 INPUTMAPPING.H TEMPLATE
----------------------------
// Safe zone for user edits - generator preserves content between markers

// === BEGIN USER INPUT MAPPINGS ===

// Momentary buttons
{ "MY_BUTTON", "GPIO", PIN(5), 0, -1, "MY_BUTTON", 1, "momentary", 0 },

// Selector (3-position with neutral)
{ "MY_SW_LEFT",  "GPIO", PIN(10), 0, -1, "MY_SW", 2, "selector", 1 },
{ "MY_SW_OFF",   "NONE", 0,       -1, -1, "MY_SW", 1, "selector", 1 },
{ "MY_SW_RIGHT", "GPIO", PIN(11), 0, -1, "MY_SW", 0, "selector", 1 },

// Analog axis
{ "MY_POT", "GPIO", PIN(4), 0, -1, "MY_POT", 65535, "analog", 0 },

// Encoder
{ "MY_ENC_CCW", "GPIO", PIN(12), 0, -1, "MY_ENC", 0, "variable_step", 0 },
{ "MY_ENC_CW",  "GPIO", PIN(13), 0, -1, "MY_ENC", 1, "variable_step", 0 },

// === END USER INPUT MAPPINGS ===

27.5 LEDMAPPING.H TEMPLATE
--------------------------
// Safe zone for user edits - generator preserves content between markers

// === BEGIN USER LED MAPPINGS ===

// GPIO LEDs
{ "MY_LED", DEVICE_GPIO, { .gpioInfo = { PIN(15) } }, false, false },
{ "MY_PWM_LED", DEVICE_GPIO, { .gpioInfo = { PIN(16) } }, true, false },

// WS2812 RGB
{ "MY_RGB", DEVICE_WS2812, { .ws2812Info = { 0, 0, 255, 0, 200 } }, true, false },

// PCA9555
{ "MY_PCA_LED", DEVICE_PCA9555, { .pcaInfo = { 0x20, 0, 0 } }, false, true },

// === END USER LED MAPPINGS ===

27.6 STATE MACHINE TEMPLATE
---------------------------
// Non-blocking state machine pattern

enum class MyState { IDLE, OPENING, WAITING, CLOSING };

static MyState s_state = MyState::IDLE;
static unsigned long s_stateEnterTime = 0;

static void changeState(MyState newState) {
    s_state = newState;
    s_stateEnterTime = millis();
}

static unsigned long msInState() {
    return millis() - s_stateEnterTime;
}

static void MyStateMachine_loop() {
    switch (s_state) {
        case MyState::IDLE:
            if (shouldStart()) {
                changeState(MyState::OPENING);
            }
            break;
            
        case MyState::OPENING:
            if (msInState() >= 300) {
                changeState(MyState::WAITING);
            }
            break;
            
        case MyState::WAITING:
            if (msInState() >= 100) {
                changeState(MyState::CLOSING);
            }
            break;
            
        case MyState::CLOSING:
            if (msInState() >= 300) {
                changeState(MyState::IDLE);
            }
            break;
    }
}

27.7 BOUNDED LOOP TEMPLATE
--------------------------
// Safe iteration patterns

// Search with limit
static int findIndex(const char* target) {
    constexpr int MAX_ITER = 256;
    for (int i = 0; i < MAX_ITER && i < arraySize; i++) {
        if (strcmp(array[i].label, target) == 0) {
            return i;
        }
    }
    return -1;  // Not found
}

// Process with limit
static void processItems() {
    constexpr int MAX_ITEMS = 64;
    int processed = 0;
    for (int i = 0; i < itemCount && processed < MAX_ITEMS; i++) {
        if (items[i].needsProcessing) {
            processItem(i);
            processed++;
        }
    }
}

================================================================================
END OF INSTRUCTION SET - VERSION 3.0
================================================================================

DOCUMENT STATISTICS:
  Sections: 27
  Total patterns: 50+ code examples
  Critical issues documented: 5
  Anti-patterns documented: 15+
  Complete templates: 7

LLM VERIFICATION CHECKLIST:
  [ ] Code follows CONSTRAINT-MEM-* rules
  [ ] Code follows CONSTRAINT-IO-* rules
  [ ] No patterns from Section 19 (Anti-patterns)
  [ ] Correct API usage per Sections 11-13
  [ ] Verified against ISSUE-001 through ISSUE-005

For source code reference:
  CockpitOS: https://github.com/BojoteX/CockpitOS
  DCS-BIOS:  https://github.com/DCS-Skunkworks/dcs-bios

================================================================================
