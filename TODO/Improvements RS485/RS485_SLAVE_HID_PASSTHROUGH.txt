================================================================================
  CockpitOS — RS485 Slave HID Passthrough Implementation Guide
  Audience: LLM Implementation Agent
  Version: 1.0
  Date: 2026-02-11
  Scope: Route RS485 slave input commands to HID reports on the master
================================================================================

TABLE OF CONTENTS
  0. Feature Summary
  1. Architecture Context
  2. Why This Works (Prerequisites Already Met)
  3. Implementation — sendCommand() HID Gate
  4. Implementation — Analog Axis Direct Injection
  5. Control Type Handling Matrix
  6. Mode Routing Logic
  7. What Does NOT Change
  8. File Reference Map
  9. Testing Checklist

================================================================================
0. FEATURE SUMMARY
================================================================================

GOAL: When the RS485 master is in HID mode, input commands received from RS485
slaves should generate HID reports (gamepad button presses / axis movements)
on the master, just as if the controls were physically connected to the master.

This enables remote RS485 slave panels to act as HID game controllers through
the master's USB/BLE connection to the PC, without DCS-BIOS or any simulator
running.

EFFORT: ~20 lines of code in sendCommand(), ~5 lines for a new helper function
in HIDManager.cpp, ~1 line declaration in HIDManager.h.

================================================================================
1. ARCHITECTURE CONTEXT
================================================================================

Current data flow for RS485 slave inputs:

  [Slave panel driver reads hardware]
    -> sendDCSBIOSCommand(label, value, force)       // on slave
      -> sendCommand(label, buf, false)              // on slave
        -> RS485Slave_queueCommand(label, buf)       // queued in TX ring buffer
          -> [RS485 bus: master polls, slave responds with "LABEL VALUE\n"]
            -> processInputCommand() on master       // RS485Master.cpp:824
              -> sendCommand(label, value, false)    // on master
                -> DCS-BIOS transport (WiFi/USB/BLE/Serial)  // CURRENT: only path

The slave sends string commands like:
  - Buttons/selectors: "MASTER_ARM_SW 1", "MASTER_ARM_SW 0"
  - Step controls:     "CHART_DIMMER +3200", "CHART_DIMMER -3200"
                       "SOME_CONTROL INC", "SOME_CONTROL DEC"
  - Analog axes:       "HMD_OFF_BRT 2048"

These arrive at the master's sendCommand(msg, arg, silent) in DCSBIOSBridge.cpp
at line 1330. This is the ONLY place that needs modification.

KEY INSIGHT: sendCommand() is the single funnel for ALL outbound commands from
any source (local panel drivers, RS485 slaves, everything). Adding a HID gate
here makes ALL command sources HID-capable automatically.

================================================================================
2. WHY THIS WORKS (PREREQUISITES ALREADY MET)
================================================================================

The architecture already provides everything needed:

  a) SHARED LABEL NAMESPACE: The master's InputMapping.h contains entries for
     all labels (local + slave). Each entry has a hidId field. The slave sends
     labels that exist in the master's mapping.

  b) CENTRALIZED ROUTING: sendCommand() is the single exit point. One gate
     here covers all command sources.

  c) LABEL-DRIVEN HID: HIDManager_setNamedButton() takes a label string,
     looks it up via findInputByLabel(), and manipulates report.buttons
     using the hidId. No pin or hardware dependency.

  d) MODE SELECTION: isModeSelectorDCS() already gates HID vs DCS behavior
     everywhere. LabelSetConfig.h controls this per label set via
     HAS_HID_MODE_SELECTOR and MODE_DEFAULT_IS_HID.

  e) STATELESS HID: In HID mode there is no simulator, no export stream, no
     round-trip confirmation needed. The slave reads physical hardware, sends
     the state string, master sets the HID bit. Done.

  f) RS485 CODE UNTOUCHED: The slave already sends "LABEL VALUE\n" and the
     master already parses it into sendCommand(label, value). No RS485
     protocol changes needed.

================================================================================
3. IMPLEMENTATION — sendCommand() HID GATE
================================================================================

FILE: src/Core/DCSBIOSBridge.cpp
FUNCTION: sendCommand() — line 1330

Insert the HID gate at the TOP of sendCommand(), BEFORE the RS485_SLAVE_ENABLED
block and before any transport-specific #if blocks. The gate should only execute
on the master (not on slaves, which have their own early return).

PSEUDOCODE:

  void sendCommand(const char* msg, const char* arg, bool silent) {

      // ── NEW: HID passthrough for slave commands (and any sendCommand caller) ──
      // When in HID mode, route matching labels to HID report instead of DCS transport.
      // This runs on master only (slave has RS485_SLAVE_ENABLED early return below).

      #if !RS485_SLAVE_ENABLED
      if (!isModeSelectorDCS()) {
          const InputMapping* m = findInputByLabel(msg);
          if (m && m->hidId > 0 && m->hidId <= 32) {
              const char* ctype = m->controlType ? m->controlType : "";

              if (strcmp(ctype, "analog") == 0) {
                  // Analog axis: arg is a numeric string (e.g. "2048")
                  // Route to direct axis injection (see Section 4)
                  int val = atoi(arg);
                  HIDManager_setAxisDirect(/* resolve axis from mapping */, (uint16_t)val);
              }
              else if (strcmp(ctype, "variable_step") == 0 ||
                       strcmp(ctype, "fixed_step") == 0) {
                  // Step controls: always press=true, auto-clear handles release
                  HIDManager_setNamedButton(msg, false, true);
              }
              else {
                  // Momentary, selector, toggle, everything else
                  int val = atoi(arg);
                  HIDManager_setNamedButton(msg, false, val != 0);
              }

              if (!silent) debugPrintf("[HID-PASS] %s %s\n", msg, arg);
              return;  // Skip DCS transport entirely
          }
          // Label not found or no hidId — fall through to existing behavior
          // (e.g. system commands like "PING" that have no HID mapping)
      }
      #endif

      // ── Existing code below (unchanged) ──

      #if RS485_SLAVE_ENABLED
          RS485Slave_queueCommand(msg, arg);
          ...
          return;
      #endif

      #if USE_DCSBIOS_WIFI
          ...
      #elif USE_DCSBIOS_USB
          ...
      // etc.
  }

IMPORTANT NOTES:
  - The #if !RS485_SLAVE_ENABLED guard ensures this code ONLY compiles on
    masters (and standalone devices). Slaves never execute this path since
    they have their own early return.
  - The isModeSelectorDCS() check means this is a no-op in DCS mode —
    existing behavior is 100% preserved.
  - Labels without a valid hidId (hidId <= 0) fall through to existing
    transport code. This handles system commands like "PING" and labels
    that are DCS-only (hidId = -1 in InputMapping).
  - The return after HID dispatch prevents the command from ALSO going
    out on the DCS transport. In pure HID mode there is no DCS to talk to.

FOR HYBRID MODE (future consideration):
  If MODE_HYBRID_DCS_HID is defined and enabled, remove the `return` after
  the HID call so the command also falls through to the DCS transport.
  This matches the pattern already used in HIDManager_setNamedButton() and
  HIDManager_moveAxis() for hybrid routing.

================================================================================
4. IMPLEMENTATION — ANALOG AXIS DIRECT INJECTION
================================================================================

PROBLEM: HIDManager_moveAxis() expects a GPIO pin number because it calls
analogRead(pin) internally. Remote slave axes have no local pin on the master.

SOLUTION: Add a lightweight function that writes an axis value directly into
the HID report and dispatches it. This keeps HIDManager as the single owner
of the report struct.

FILE: src/Core/HIDManager.cpp

  void HIDManager_setAxisDirect(HIDAxis axis, uint16_t value) {
      if (axis >= HID_AXIS_COUNT) return;
      report.axes[axis] = value;
      HIDManager_dispatchReport(false);
  }

FILE: src/HIDManager.h

  Add declaration:
  void HIDManager_setAxisDirect(HIDAxis axis, uint16_t value);

AXIS RESOLUTION: The slave sends analog values as the arg string. The format
depends on what the slave's panel driver sends via sendDCSBIOSCommand():
  - If the slave sends raw 12-bit ADC values (0-4095), use directly
  - If the slave sends DCS-BIOS 16-bit values (0-65535), scale down:
    value = map(val, 0, 65535, 0, 4095)

Check what sendDCSBIOSCommand sends for analog on the slave side. In
HIDManager_moveAxis (line 686-688), DCS mode sends:
  uint16_t d16 = map(hid, 0, 4095, 0, 65535);
  sendDCS(d16, true);

So the slave will queue a 16-bit value string (0-65535). The master's HID gate
should scale it back:
  int val = atoi(arg);
  uint16_t hid = map(val, 0, 65535, 0, 4095);
  HIDManager_setAxisDirect(axis, hid);

AXIS MAPPING: The sendCommand HID gate needs to resolve which HIDAxis enum
corresponds to the label. Options:
  a) Add an axis field to InputMapping struct (cleanest, but requires
     regenerating all label sets)
  b) Use a small lookup table in the HID gate that maps analog labels to
     HIDAxis values (pragmatic, no schema change)
  c) Use the hidId field creatively for analog entries to encode axis index
     (hacky, not recommended)

Option (b) is recommended for initial implementation. A static mapping like:
  if (strcmp(msg, "HMD_OFF_BRT") == 0) axis = AXIS_X;
Or a small generated table alongside InputMapping.

NOTE: If no slave currently sends analog axes over RS485, this can be deferred.
The button path (Section 3) is the primary deliverable.

================================================================================
5. CONTROL TYPE HANDLING MATRIX
================================================================================

  controlType      | arg from slave      | HID action on master
  -----------------+---------------------+--------------------------------------------
  "momentary"      | "1" / "0"           | HIDManager_setNamedButton(msg, false, val!=0)
  "selector"       | "0","1","2"...      | HIDManager_setNamedButton(msg, false, val!=0)
  "variable_step"  | "+3200" / "-3200"   | HIDManager_setNamedButton(msg, false, true)
                   |                     | (auto-clear via STEP_PULSE_MS in HIDManager_loop)
  "fixed_step"     | "INC" / "DEC"       | HIDManager_setNamedButton(msg, false, true)
                   |                     | (auto-clear via STEP_PULSE_MS in HIDManager_loop)
  "analog"         | "0"-"65535"         | HIDManager_setAxisDirect(axis, scaled_value)
  (no controlType) | varies              | HIDManager_setNamedButton(msg, false, val!=0)

HIDManager_setNamedButton already handles:
  - Group bitmask exclusivity for selectors (clears other bits in group)
  - Step pulse scheduling (sets bit ON, schedules auto-OFF after STEP_PULSE_MS)
  - Latch/toggle detection for latched buttons
  - hidId validation (returns early if hidId <= 0 or > 32)
  - DCS vs HID mode gating internally (will be in HID mode when we call it)

So the sendCommand HID gate does NOT need to replicate any of this logic.
Just call HIDManager_setNamedButton with the right pressed state and it
handles the rest.

================================================================================
6. MODE ROUTING LOGIC
================================================================================

  Mode              | isModeSelectorDCS() | sendCommand behavior
  ------------------+---------------------+-----------------------------------------
  HID mode          | false               | NEW: route to HIDManager if hidId valid
  DCS mode          | true                | UNCHANGED: send via DCS transport
  Hybrid (future)   | true                | Both: HID + DCS transport

  The mode is determined by:
  - LabelSetConfig.h: HAS_HID_MODE_SELECTOR, MODE_DEFAULT_IS_HID
  - Physical switch: MODE_SWITCH_PIN (if HAS_HID_MODE_SELECTOR=1)
  - CockpitOS.ino: isModeSelectorDCS() function (line 160)

  No changes to mode detection are needed.

================================================================================
7. WHAT DOES NOT CHANGE
================================================================================

  FILE                          | CHANGE?  | REASON
  ------------------------------+----------+--------------------------------------
  RS485Master.cpp               | NO       | Already calls sendCommand() correctly
  RS485Slave.cpp                | NO       | Already sends "LABEL VALUE\n"
  RS485Config.h                 | NO       | No protocol changes
  RS485SlaveConfig.h            | NO       | No protocol changes
  HIDManager.cpp (existing)     | NO       | Existing functions handle all logic
  HIDManager.cpp (new function) | YES      | Add HIDManager_setAxisDirect() (~5 lines)
  HIDManager.h                  | YES      | Add declaration (~1 line)
  DCSBIOSBridge.cpp             | YES      | Add HID gate in sendCommand() (~20 lines)
  InputMapping.h                | NO       | Already has hidId for slave labels
  LabelSetConfig.h              | NO       | Already controls HID/DCS mode
  CockpitOS.ino                 | NO       | isModeSelectorDCS() unchanged

  Total changes: 2 files modified, ~25 lines of new code.

================================================================================
8. FILE REFERENCE MAP
================================================================================

  src/Core/DCSBIOSBridge.cpp:1330    sendCommand() — INSERT HID GATE HERE
  src/Core/HIDManager.cpp:774       HIDManager_setNamedButton() — called by gate
  src/Core/HIDManager.cpp:608       HIDManager_moveAxis() — reference for axis scaling
  src/Core/HIDManager.cpp:547       HIDManager_dispatchReport() — called by setAxisDirect
  src/Core/HIDManager.cpp:263       report (GamepadReport_t) — the HID report struct
  src/HIDManager.h                  Add HIDManager_setAxisDirect declaration
  src/Globals.h:61                  isModeSelectorDCS() extern declaration
  src/LABELS/*/InputMapping.h       hidId field in struct (line 12)
  src/LABELS/*/LabelSetConfig.h     HAS_HID_MODE_SELECTOR, MODE_DEFAULT_IS_HID
  CockpitOS.ino:160                 isModeSelectorDCS() implementation
  lib/CUtils/src/internal/RS485Master.cpp:863  sendCommand(label, value, false) call
  lib/CUtils/src/internal/RS485Slave.cpp:1177  RS485Slave_queueCommand() entry point

================================================================================
9. TESTING CHECKLIST
================================================================================

  [ ] Master in HID mode, slave sends momentary button press
      -> Verify HID button bit toggles on/off in PC game controller viewer

  [ ] Master in HID mode, slave sends selector change (group > 0)
      -> Verify group exclusivity: only one bit set per group

  [ ] Master in HID mode, slave sends variable_step (+3200/-3200)
      -> Verify HID button pulses ON then auto-clears after STEP_PULSE_MS

  [ ] Master in HID mode, slave sends fixed_step (INC/DEC)
      -> Verify HID button pulses ON then auto-clears after STEP_PULSE_MS

  [ ] Master in HID mode, slave sends analog axis value
      -> Verify axis moves in PC game controller viewer (if implemented)

  [ ] Master in DCS mode, slave sends any command
      -> Verify ZERO behavioral change — command goes to DCS transport as before

  [ ] Master in HID mode, slave sends label with hidId=-1 (DCS-only)
      -> Verify command falls through gracefully (no crash, no HID action)

  [ ] Master in HID mode, local panel input still works
      -> Verify local buttons/axes still generate HID reports normally

  [ ] System command like "PING" with no InputMapping entry
      -> Verify no crash, falls through to existing transport code

================================================================================
END OF DOCUMENT
================================================================================
