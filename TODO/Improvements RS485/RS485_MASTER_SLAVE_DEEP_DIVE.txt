================================================================================
  CockpitOS RS485 Master & Slave — Technical Improvement Specification
  Audience: LLM Implementation Agent
  Version: 1.0
  Date: 2026-02-11
  Scope: ISR path (primary), Driver path (secondary, root-cause analysis)
================================================================================

TABLE OF CONTENTS
  0. Context & Reference Architecture (AVR)
  1. Issue Index (Master + Slave, severity-ranked)
  2. ISR PATH — Detailed Issues & Fixes
     2.1  uart_param_config Without Driver Install (CRITICAL)
     2.2  Missing RXFIFO_TOUT Interrupt (CRITICAL)
     2.3  esp_timer_get_time Per-Byte in ISR (HIGH)
     2.4  MessageBuffer Cross-Core Safety — Master Only (MEDIUM)
     2.5  txBytes Spin-Wait for Large Broadcasts — Master Only (MEDIUM)
     2.6  Smart Mode 10-Byte-Per-Change Overhead — Master Only (MEDIUM)
     2.7  Discovery Scan Without Separate Counter — Master Only (LOW)
     2.8  Unreachable RX_SKIP_CHECKSUM State — Slave Only (LOW)
  3. DRIVER PATH — Root Cause Failure Analysis
     3.1  The Fundamental Timing Problem
     3.2  Why uart_read_bytes Cannot Meet Protocol Requirements
     3.3  Evidence From ESP-IDF Source Code
     3.4  The HardwareSerial onReceive Callback Alternative
     3.5  Verdict: Is Driver Mode Fundamentally Impossible?
     3.6  A Hybrid Architecture That Could Work
  4. WiFi/BLE Core Contention Analysis
  5. Implementation Priority Order
  6. File Reference Map


================================================================================
0. CONTEXT & REFERENCE ARCHITECTURE (AVR)
================================================================================

The DCS-BIOS RS485 protocol is a master-slave polling bus operating at 250kbps,
8-N-1. The AVR Arduino Mega master (DcsBiosNgRS485Master) achieves near-perfect
bus utilization by leveraging three critical AVR hardware features:

  (a) THREE SEPARATE ISR VECTORS PER UART:
      - USART_RX_vect:  fires when a byte arrives in UDR
      - USART_UDRE_vect: fires when UDR is empty (ready for next TX byte)
      - USART_TX_vect:   fires when the LAST bit of the LAST byte physically
                         leaves the shift register (TX COMPLETE)

  (b) SINGLE-CYCLE PORT I/O:
      - `*txen_port |= txen_pin_mask` is ONE clock cycle (62.5ns at 16MHz)
      - DE pin state changes are effectively instantaneous

  (c) ZERO-OVERHEAD ISR INLINING:
      - __attribute__((always_inline)) forces the compiler to embed the ISR
        handler body directly at the vector entry point
      - No function call/return overhead, no stack frame setup

The ESP32 equivalents are:
  (a) SINGLE ISR with status register — must check UART_INTR_RXFIFO_FULL,
      UART_INTR_TX_DONE, UART_INTR_RXFIFO_TOUT in one handler.
  (b) gpio_ll_set_level — ~30ns on Xtensa, ~60ns on RISC-V. Close enough.
  (c) IRAM_ATTR — ensures ISR code is in IRAM, not flash. The ESP32 has a
      128-byte UART FIFO vs AVR's 1-byte UDR, which means we can batch TX
      bytes rather than interrupting per-byte.

The protocol frame format on the wire:

  Master -> Slave (Poll):       [Addr][MsgType=0][Length=0]
                                 NO CHECKSUM when Length=0

  Master -> Slave (Broadcast):  [Addr=0][MsgType=0][Length][Data...][Checksum]

  Slave -> Master (Empty):      [0x00]
                                 Single byte, NO CHECKSUM

  Slave -> Master (With data):  [Length][MsgType=0][Data...][Checksum]

Critical timing constraints:
  - Master poll timeout (first byte):  1000us (1ms)
  - Master mid-message timeout:        5000us (5ms)
  - Slave sync timeout (bus silence):  500us
  - Byte time at 250kbps, 10 bits:    40us

The CockpitOS implementation files:
  Master: lib/CUtils/src/internal/RS485Master.cpp
          lib/CUtils/src/RS485Config.h
  Slave:  lib/CUtils/src/internal/RS485Slave.cpp
          lib/CUtils/src/RS485SlaveConfig.h

ESP32 Arduino Core 3.3.6 UART HAL:
  Headers:  cores/esp32/esp32-hal-uart.h
            cores/esp32/HardwareSerial.h
  Source:   cores/esp32/esp32-hal-uart.c
            cores/esp32/HardwareSerial.cpp


================================================================================
1. ISSUE INDEX (Master + Slave, Severity-Ranked)
================================================================================

  #   Severity  Affects     Section   Title
  --- --------- ----------  --------- ----------------------------------------
  2.1 CRITICAL  Both        ISR       uart_param_config Without Driver Install
  2.2 CRITICAL  Both        ISR       Missing RXFIFO_TOUT Interrupt
  2.3 HIGH      Both        ISR       esp_timer_get_time Per-Byte in ISR
  2.4 MEDIUM    Master      ISR       MessageBuffer Cross-Core Safety
  2.5 MEDIUM    Master      ISR       txBytes Spin-Wait for Large Broadcasts
  2.6 MEDIUM    Master      ISR       Smart Mode 10-Byte-Per-Change Overhead
  2.7 LOW       Master      ISR       Discovery Scan Without Separate Counter
  2.8 LOW       Slave       ISR       Unreachable RX_SKIP_CHECKSUM State
  3.x N/A       Both        Driver    Root Cause Failure Analysis (separate)


================================================================================
2. ISR PATH — DETAILED ISSUES & FIXES
================================================================================


--------------------------------------------------------------------------------
2.1  uart_param_config Without Driver Install [CRITICAL] [BOTH]
--------------------------------------------------------------------------------

LOCATION:
  Master: RS485Master.cpp:1007-1016 (initRS485Hardware_ISR)
  Slave:  RS485Slave.cpp:624-634    (initRS485Hardware_ISR)

CURRENT CODE (identical pattern in both):

    periph_module_enable(RS485_UART_PERIPH);           // Line ~1004/621

    uart_config_t uart_config = { ... };
    uart_param_config((uart_port_t)RS485_UART_NUM, &uart_config);  // Line ~1016/634

    uart_set_pin((uart_port_t)RS485_UART_NUM, RS485_TX_PIN, RS485_RX_PIN,
                 UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);          // Line ~1019/641

WHY THIS IS PROBLEMATIC:

  uart_param_config() is an ESP-IDF DRIVER-LEVEL API function. Looking at the
  Arduino Core 3.3.6 source (esp32-hal-uart.c:796), the standard init sequence
  is:

      uart_driver_install(...)     // FIRST: installs IDF driver
      uart_param_config(...)       // SECOND: configures parameters

  When you call uart_param_config() WITHOUT uart_driver_install(), you are
  mixing abstraction layers:

  1. periph_module_enable() is a HARDWARE-LEVEL operation that enables the
     UART peripheral clock via the RCC (Reset and Clock Control) registers.

  2. uart_param_config() is a DRIVER-LEVEL function that:
     - Internally calls uart_module_enable() (ANOTHER peripheral enable,
       creating a double-enable with ref-counting)
     - Configures baud rate via uart_ll_set_baudrate()
     - Configures data bits, parity, stop bits via uart_ll_set_data_bit_num(),
       uart_ll_set_parity(), uart_ll_set_stop_bits()
     - Configures flow control
     - Sets clock source via HP_UART_SRC_CLK_ATOMIC()

  3. uart_set_pin() is also a DRIVER-LEVEL function that interacts with the
     Arduino Core's Peripheral Manager (perimanSetPinBus, perimanClearPinBus).
     Without a driver installed, the Peripheral Manager's UART bus state may
     be inconsistent.

  The current code WORKS because:
  - periph_module_enable ref-counting means double-enable is benign
  - uart_param_config happens to not check for driver presence (it configures
    hardware registers directly via uart_ll_* calls internally)
  - uart_set_pin also happens to work without a driver

  BUT this creates a FRAGILE dependency on IDF internal implementation details.
  Any of these behaviors could change in a future ESP-IDF version.

PROPOSED FIX — Pure uart_ll_* initialization:

  Replace uart_param_config() and uart_set_pin() with direct uart_ll_* calls
  that match what uart_param_config does internally, but without any driver-
  level assumptions:

    // Enable peripheral clock
    periph_module_enable(RS485_PERIPH_MODULE);

    // Configure baud rate directly
    // ESP32-S3 with XTAL clock (40MHz): use uart_ll_set_baudrate
    HP_UART_SRC_CLK_ATOMIC() {
        uart_ll_set_sclk(RS485_UART_DEV, UART_SCLK_DEFAULT);
    }
    uart_ll_set_baudrate(RS485_UART_DEV, RS485_BAUD, /* source_clk_freq */);

    // Configure frame format: 8N1
    uart_ll_set_data_bit_num(RS485_UART_DEV, UART_DATA_8_BITS);
    uart_ll_set_parity(RS485_UART_DEV, UART_PARITY_DISABLE);
    uart_ll_set_stop_bits(RS485_UART_DEV, UART_STOP_BITS_1);
    uart_ll_set_hw_flow_ctrl(RS485_UART_DEV, UART_HW_FLOWCTRL_DISABLE, 0);

    // Enable TX and RX
    uart_ll_set_tx_idle_num(RS485_UART_DEV, 0);
    uart_ll_set_txfifo_empty_thr(RS485_UART_DEV, 10);

    // Configure pins via GPIO matrix (bypassing Peripheral Manager)
    esp_rom_gpio_pad_select_gpio(RS485_TX_PIN);
    esp_rom_gpio_connect_out_signal(RS485_TX_PIN, RS485_UART_SIGNAL, false, false);
    esp_rom_gpio_pad_select_gpio(RS485_RX_PIN);
    esp_rom_gpio_connect_in_signal(RS485_RX_PIN, RS485_UART_RX_SIG, false);
    gpio_set_pull_mode((gpio_num_t)RS485_RX_PIN, GPIO_PULLUP_ONLY);

  NOTE ON BAUD RATE CALCULATION: The uart_ll_set_baudrate function requires
  the source clock frequency as a parameter. On ESP32-S3 with XTAL clock,
  this is 40MHz. On ESP32-C3/C6 with XTAL, also 40MHz. The correct approach
  is to query the actual clock frequency:

    uint32_t sclk_freq;
    HP_UART_SRC_CLK_ATOMIC() {
        uart_ll_get_sclk(RS485_UART_DEV, &sclk_freq);
    }

  ALTERNATIVELY, if full bare-metal init is deemed too risky due to cross-SoC
  variations, the SAFER approach is to keep uart_param_config but add a guard:

    // Ensure no driver is fighting us
    if (uart_is_driver_installed((uart_port_t)RS485_UART_NUM)) {
        uart_driver_delete((uart_port_t)RS485_UART_NUM);
    }
    periph_module_enable(RS485_PERIPH_MODULE);
    uart_param_config((uart_port_t)RS485_UART_NUM, &uart_config);
    // Use esp_rom_gpio_* for pin config instead of uart_set_pin
    esp_rom_gpio_pad_select_gpio(RS485_TX_PIN);
    esp_rom_gpio_connect_out_signal(RS485_TX_PIN, RS485_UART_SIGNAL, false, false);
    esp_rom_gpio_pad_select_gpio(RS485_RX_PIN);
    esp_rom_gpio_connect_in_signal(RS485_RX_PIN, RS485_UART_RX_SIG, false);
    gpio_set_pull_mode((gpio_num_t)RS485_RX_PIN, GPIO_PULLUP_ONLY);

  This second approach is RECOMMENDED. It keeps the proven uart_param_config
  baud-rate calculation (which handles clock source selection across all SoCs)
  while eliminating the Peripheral Manager side-effects of uart_set_pin.

RISK IF NOT FIXED: Low probability, high impact. An IDF update could add a
  driver-presence check to uart_param_config, causing init to silently fail.

COUNTERARGUMENT: The code works today on Arduino Core 3.3.6 / IDF 5.3.
  uart_param_config has never required a driver in any public IDF release.
  The fix is defensive, not reactive.


--------------------------------------------------------------------------------
2.2  Missing RXFIFO_TOUT Interrupt [CRITICAL] [BOTH]
--------------------------------------------------------------------------------

LOCATION:
  Master: RS485Master.cpp:1030 (initRS485Hardware_ISR)
          RS485Master.cpp:537-539 (enableRxInt helper)
  Slave:  RS485Slave.cpp:659   (initRS485Hardware_ISR)
          RS485Slave.cpp:411-412 (TX_DONE handler re-enable)

CURRENT CODE:

  Init (both master and slave):
    uart_ll_ena_intr_mask(RS485_UART_DEV, UART_INTR_RXFIFO_FULL);
    // Only RXFIFO_FULL enabled. NO RXFIFO_TOUT.

  Master's enableRxInt() helper (called from TX_DONE handler):
    uart_ll_ena_intr_mask(RS485_UART_DEV,
        UART_INTR_RXFIFO_FULL | UART_INTR_RXFIFO_TOUT);
    // BOTH enabled here — but only after first TX_DONE fires

  Slave's TX_DONE handler (direct, no helper function):
    uart_ll_clr_intsts_mask(uartHw, UART_INTR_RXFIFO_FULL);
    uart_ll_ena_intr_mask(uartHw, UART_INTR_RXFIFO_FULL);
    // ONLY RXFIFO_FULL re-enabled. TOUT NEVER enabled in slave.

WHY THIS MATTERS:

  The RXFIFO_TOUT (RX timeout) interrupt fires when the RX FIFO contains at
  least one byte AND no new bytes arrive for a configurable number of bit
  periods. This is the SAFETY NET for the last byte of a burst.

  Consider this sequence at the hardware level:
    1. Byte arrives in FIFO → RXFIFO_FULL fires (threshold=1) → ISR runs
    2. ISR drains FIFO via while(uart_ll_get_rxfifo_len > 0) loop
    3. ISR finishes, clears interrupt status
    4. BETWEEN step 3 and the CPU returning from the ISR, another byte arrives
    5. This byte sits in the FIFO with count=1, but RXFIFO_FULL already
       fired and was cleared. The interrupt will NOT re-fire until the FIFO
       count transitions through 0 again (edge-triggered on threshold crossing)

  In practice, this race is extremely narrow at 250kbps (40us between bytes).
  The ISR takes ~2-5us on ESP32-S3. The probability of a byte arriving in
  exactly that 2-5us window is low but non-zero (~5-12% per byte boundary).

  However, the ESP32 UART FIFO interrupt is LEVEL-triggered, not edge-triggered.
  As long as fifo_len >= threshold, RXFIFO_FULL stays asserted. The drain loop
  `while (uart_ll_get_rxfifo_len > 0)` handles this correctly — it keeps
  draining until the FIFO is truly empty.

  BUT: there is a hardware race condition documented in the ESP32 Technical
  Reference Manual. The FIFO read pointer update is not instantaneous on
  RISC-V targets (C3/C6/H2). This is exactly why the slave code has:

    #ifdef __riscv
    __asm__ __volatile__("fence");
    #endif

  Even with the fence, there is a window where uart_ll_get_rxfifo_len returns 0
  but a byte has already entered the FIFO. RXFIFO_TOUT catches this case.

  For the SLAVE specifically, this is more critical than the master because:
  - The slave receives LONG broadcast frames (potentially 100+ bytes)
  - The last byte of a broadcast is the CHECKSUM byte
  - If the checksum byte is missed, the state machine stays in RX_WAIT_CHECKSUM
  - The slave will not transition to RX_WAIT_ADDRESS for the next frame
  - The next poll for this slave will be misinterpreted as data, not address
  - This causes the slave to go out of sync until the next 500us silence gap

  For the MASTER, the risk is lower because:
  - Master enables TOUT after the first TX_DONE (via enableRxInt helper)
  - Master receives SHORT responses (typically 1-30 bytes)
  - Master has explicit timeout handling that resets the state machine

PROPOSED FIX:

  (a) At init time, enable BOTH interrupts:

    uart_ll_set_rxfifo_full_thr(RS485_UART_DEV, 1);
    uart_ll_set_rx_tout(RS485_UART_DEV, 10);  // 10 symbol periods (~440us at 250kbps)
                                                // Much shorter than protocol timeouts
    uart_ll_ena_intr_mask(RS485_UART_DEV,
        UART_INTR_RXFIFO_FULL | UART_INTR_RXFIFO_TOUT);

  (b) In BOTH the master's enableRxInt() and the slave's TX_DONE handler,
      re-enable BOTH interrupts:

    uart_ll_clr_intsts_mask(dev, UART_INTR_RXFIFO_FULL | UART_INTR_RXFIFO_TOUT);
    uart_ll_ena_intr_mask(dev, UART_INTR_RXFIFO_FULL | UART_INTR_RXFIFO_TOUT);

  (c) When disabling RX during TX (sendResponseISR, txWithEchoPrevention),
      disable BOTH:

    uart_ll_disable_intr_mask(dev, UART_INTR_RXFIFO_FULL | UART_INTR_RXFIFO_TOUT);

  (d) The RX timeout value of 10 symbols at 250kbps means:
      10 * (1/250000) * 10 bits = 400us
      This is well below the 500us sync timeout and the 1000us poll timeout,
      so it won't interfere with protocol-level timeouts. It's purely a
      hardware-level safety net for the FIFO drain race.

  NOTE: uart_ll_set_rx_tout() may not exist as a direct uart_ll function on
  all SoC variants. The IDF-level equivalent is:
    uart_set_rx_timeout((uart_port_t)RS485_UART_NUM, 10);
  But this requires the driver to be installed. For bare-metal, the register
  write is:
    On ESP32/S3: UART_DEV->conf1.rx_tout_en = 1; UART_DEV->conf1.rx_tout_thrhd = 10;
    On C3/C6:    UART_DEV->tout_conf.rx_tout_en = 1; UART_DEV->tout_conf.rx_tout_thrhd = 10;

  The safest cross-SoC approach is to use uart_ll_set_rx_tout if available in
  the HAL headers, falling back to the appropriate register write.

RISK IF NOT FIXED: Rare but real byte-loss on broadcast streams, causing
  intermittent slave desync that self-recovers on next silence gap. Most likely
  to manifest on RISC-V targets (C3/C6/H2) under heavy bus traffic with WiFi
  ISRs occasionally delaying the UART ISR.


--------------------------------------------------------------------------------
2.3  esp_timer_get_time Per-Byte in ISR [HIGH] [BOTH]
--------------------------------------------------------------------------------

LOCATION:
  Master: RS485Master.cpp:477,484,492,500 (processRxByte — updates rxStartTime
          on EVERY state transition)
  Slave:  RS485Slave.cpp:435 (uart_isr_handler — calls esp_timer_get_time for
          EVERY byte entering the RX loop)

CURRENT CODE:

  Slave (inside ISR RX drain loop):
    while (uart_ll_get_rxfifo_len(uartHw) > 0) {
        uint8_t c;
        uart_ll_read_rxfifo(uartHw, &c, 1);
        int64_t now = esp_timer_get_time();  // <-- CALLED FOR EVERY BYTE
        ...
        lastRxTime = now;                    // <-- STORED FOR EVERY BYTE
    }

  Master (processRxByte, called from ISR):
    case MasterState::RX_WAIT_DATALENGTH:
        ...
        rxStartTime = esp_timer_get_time();  // <-- CALLED PER STATE
        break;
    case MasterState::RX_WAIT_MSGTYPE:
        ...
        rxStartTime = esp_timer_get_time();  // <-- CALLED PER STATE
        break;
    ... (and so on for EVERY state)

WHY THIS IS EXCESSIVE:

  esp_timer_get_time() reads the ESP32's 64-bit hardware timer. On Xtensa
  (ESP32, S2, S3), this is a direct register read — fast (~30ns) but still
  a function call with IRAM lookup. On RISC-V (C3, C6, H2), it's a CSR read
  that may require multiple instructions due to the 64-bit value on a 32-bit
  architecture.

  The AVR reference does NOT timestamp per-byte. The AVR master sets
  rx_start_time ONCE, in the TXC ISR (txcISR, line 160):

    case POLL_DATALENGTH_SENT:
        rx_start_time = micros();       // <-- ONCE, when poll TX completes
        state = RX_WAIT_DATALENGTH;
        clear_txen();
        break;

  The 5ms timeout then covers the ENTIRE response. If any byte arrives within
  5ms of the PREVIOUS byte, the response is valid. The AVR checks this with a
  simple `(micros() - rx_start_time) > 5000` in loop(), which runs between ISR
  invocations.

  The CockpitOS master updates rxStartTime on every state transition, which
  means the 5ms timeout resets with each byte. This is actually MORE GENEROUS
  than the AVR (the AVR's timeout is from poll-TX-complete, not from last byte).
  But the per-byte timer read is unnecessary overhead.

  For the slave, `lastRxTime` is used for SYNC detection only. SYNC is checked
  at the top of the ISR handler:

    if (state == SlaveState::RX_SYNC) {
        if ((now - lastRxTime) >= SYNC_TIMEOUT_US) { ... }
    }

  Once the slave is in RX_WAIT_ADDRESS (normal operation), lastRxTime is still
  updated every byte but NEVER READ until the state machine re-enters RX_SYNC
  (which only happens on protocol errors or unexpected messages).

  Cost analysis:
  - A 128-byte broadcast at 250kbps takes 128 * 40us = 5.12ms
  - 128 calls to esp_timer_get_time adds ~128 * 60ns = ~7.7us total on Xtensa
  - On RISC-V: ~128 * 150ns = ~19.2us total
  - This is <0.4% overhead on Xtensa, <0.4% on RISC-V
  - The overhead is MEASURABLE but not catastrophic

  HOWEVER, the principle of ISR hygiene matters. Every unnecessary instruction
  in an ISR increases worst-case interrupt latency for OTHER interrupts on the
  same core (WiFi, BLE, timers). On a single-core C3/C6, this directly impacts
  WiFi stack responsiveness.

PROPOSED FIX:

  MASTER — Remove per-state rxStartTime updates. Set rxStartTime ONCE in the
  TX_DONE handler (matching AVR behavior):

    // In rxISR TX_DONE handler:
    if (txContext == TxContext::POLL) {
        rxStartTime = esp_timer_get_time();  // ONCE: poll TX complete
        state = MasterState::RX_WAIT_DATALENGTH;
    }

    // In processRxByte: remove ALL rxStartTime = esp_timer_get_time() lines.
    // The 5ms mid-message timeout now measures from poll-TX-complete (like AVR).

  SLAVE — Move esp_timer_get_time() OUTSIDE the byte loop, call it ONCE per
  ISR invocation. Only update lastRxTime conditionally:

    static void IRAM_ATTR uart_isr_handler(void* arg) {
        uint32_t uart_intr_status = uart_ll_get_intsts_mask(uartHw);

        // TX_DONE handling (unchanged)
        ...

        // RX handling
        int64_t now = esp_timer_get_time();  // ONCE per ISR entry
        while (uart_ll_get_rxfifo_len(uartHw) > 0) {
            uint8_t c;
            uart_ll_read_rxfifo(uartHw, &c, 1);
            #ifdef __riscv
            __asm__ __volatile__("fence");
            #endif

            // Only check time for SYNC state
            if (state == SlaveState::RX_SYNC) {
                if ((now - lastRxTime) >= SYNC_TIMEOUT_US) {
                    state = SlaveState::RX_WAIT_ADDRESS;
                } else {
                    lastRxTime = now;
                    continue;
                }
            }

            // State machine (unchanged)
            switch (state) { ... }
        }
        lastRxTime = now;  // Update once at end of ISR

        uart_ll_clr_intsts_mask(uartHw, uart_intr_status);
    }

  IMPACT: Reduces ISR time by ~7-19us per 128-byte broadcast. More importantly,
  it reduces worst-case interrupt-disabled time, improving WiFi coexistence.


--------------------------------------------------------------------------------
2.4  MessageBuffer Cross-Core Safety — Master Only [MEDIUM]
--------------------------------------------------------------------------------

LOCATION:
  Master: RS485Master.cpp:166-202 (MessageBuffer template class)
          RS485Master.cpp:488 (put() called from ISR via processRxByte)
          RS485Master.cpp:874-894 (processCompletedMessage called from task)

CURRENT CODE:

  The MessageBuffer uses `volatile` for writePos, readPos, and complete.
  The ISR calls messageBuffer.put(c) to write data.
  The task calls messageBuffer.get() and messageBuffer.clear() to read/clear.

WHY THIS IS A CONCERN:

  On dual-core ESP32 (S3, classic ESP32), volatile does NOT guarantee
  cross-core visibility. The Xtensa architecture has per-core data caches.
  A write from Core 1's ISR may sit in Core 1's write buffer and not be
  visible to Core 0 reading messageBuffer.complete in the main loop.

  HOWEVER — and this is the key nuance — in the CockpitOS architecture:

  1. The RS485 task is pinned to RS485_TASK_CORE (default: Core 1)
  2. esp_intr_alloc() is called FROM the task, which means the ISR is
     allocated to the SAME core the task runs on (Core 1)
  3. On the same core, ISR and task cannot run simultaneously. The ISR
     preempts the task, and when the ISR returns, the task resumes with
     full cache coherency (the ISR's writes are visible because they share
     the same L1 cache)

  So the current code IS safe GIVEN the current pinning configuration.

  The risk is:
  - If someone changes RS485_TASK_CORE to 0 but the ISR stays on Core 1
  - If the task is not pinned (tskNO_AFFINITY) and migrates between cores
  - If someone calls processCompletedMessage from a different context

PROPOSED FIX:

  Option A (minimal, defensive):
  Add a static_assert or runtime check:

    // In RS485Master_init, after task creation:
    assert(RS485_TASK_CORE >= 0);  // Must be pinned, not tskNO_AFFINITY
    // Document: ISR and task MUST run on the same core

  Option B (proper, zero-cost on same core):
  Use portENTER_CRITICAL_ISR / portEXIT_CRITICAL_ISR around the messageBuffer
  accesses. On same-core, these are just interrupt disable/enable (equivalent
  to what we already have). On cross-core, they add the necessary memory
  barriers.

    // In processCompletedMessage:
    portMUX_TYPE msgMux = portMUX_INITIALIZER_UNLOCKED;
    portENTER_CRITICAL(&msgMux);
    bool isComplete = messageBuffer.complete;
    portEXIT_CRITICAL(&msgMux);
    if (!isComplete) return;

  Option A is RECOMMENDED. The perf cost of critical sections is unnecessary
  when we can simply enforce the architectural constraint.


--------------------------------------------------------------------------------
2.5  txBytes Spin-Wait for Large Broadcasts — Master Only [MEDIUM]
--------------------------------------------------------------------------------

LOCATION:
  Master: RS485Master.cpp:550-558 (txByte / txBytes functions)
          RS485Master.cpp:642-646 (txWithEchoPrevention, >128 byte path)

CURRENT CODE:

    static void txByte(uint8_t c) {
        while (uart_ll_get_txfifo_len(RS485_UART_DEV) == 0) {}  // SPIN
        uart_ll_write_txfifo(RS485_UART_DEV, &c, 1);
    }

    // In txWithEchoPrevention:
    if (len <= 128) {
        uart_ll_write_txfifo(RS485_UART_DEV, data, len);  // One burst
    } else {
        txBytes(data, len);  // Byte-by-byte with spin-wait
    }

WHY THIS MATTERS:

  The ESP32 UART FIFO is 128 bytes deep. For broadcasts <= 128 bytes, the
  entire frame is loaded in one uart_ll_write_txfifo call (~1us). For larger
  broadcasts, txBytes spin-waits for FIFO space.

  At 250kbps, the 128-byte FIFO drains in:
    128 bytes * 10 bits / 250000 bps = 5.12ms

  During this 5.12ms spin-wait, the RS485 task is BLOCKED. It cannot:
  - Check for timeouts
  - Process completed messages
  - Service FreeRTOS tick hooks

  This is NOT a problem for the ISR itself (TX is done from task context, not
  ISR). But it does block the task, which delays the next poll cycle.

  In practice, broadcasts are typically < 128 bytes:
  - Smart mode: RS485_MAX_BROADCAST_CHUNK = 64 bytes (default)
  - Relay mode: RS485_RELAY_CHUNK_SIZE = 128 bytes (default)

  So the >128 path is rarely hit with default config. But with relay mode at
  the default 128 limit, the frame is:
    3 (header) + 128 (data) + 1 (checksum) = 132 bytes
  This exceeds the 128-byte FIFO by 4 bytes, triggering the spin path.

PROPOSED FIX:

  Option A (simple): Reduce RS485_RELAY_CHUNK_SIZE default to 124:
    3 (header) + 124 (data) + 1 (checksum) = 128 bytes = exactly one FIFO load.

  Option B (proper): Use the TX_DONE interrupt for continuation. After loading
  128 bytes, arm TX_DONE. When TX_DONE fires, check if there are remaining
  bytes. If so, load more and re-arm. This is exactly how the AVR's UDRE
  interrupt works — feeding bytes one at a time from the ring buffer.
  However, this requires significant restructuring of the broadcast path.

  Option A is RECOMMENDED for simplicity. The broadcast chunk size should be
  chosen to always fit in one FIFO load: max_chunk <= 128 - 4 (header+checksum).


--------------------------------------------------------------------------------
2.6  Smart Mode 10-Byte-Per-Change Overhead — Master Only [MEDIUM]
--------------------------------------------------------------------------------

LOCATION:
  Master: RS485Master.cpp:702-723 (prepareBroadcastData, Smart mode)

CURRENT CODE:

    while (changeCount > 0 && broadcastLen < RS485_MAX_BROADCAST_CHUNK) {
        Change& change = changeQueue[changeTail];
        broadcastBuffer[broadcastLen++] = 0x55;  // Sync byte 1
        broadcastBuffer[broadcastLen++] = 0x55;  // Sync byte 2
        broadcastBuffer[broadcastLen++] = 0x55;  // Sync byte 3
        broadcastBuffer[broadcastLen++] = 0x55;  // Sync byte 4
        broadcastBuffer[broadcastLen++] = change.address & 0xFF;
        broadcastBuffer[broadcastLen++] = (change.address >> 8) & 0xFF;
        broadcastBuffer[broadcastLen++] = 0x02;  // Count low (2 bytes)
        broadcastBuffer[broadcastLen++] = 0x00;  // Count high
        broadcastBuffer[broadcastLen++] = change.value & 0xFF;
        broadcastBuffer[broadcastLen++] = (change.value >> 8) & 0xFF;
    }

  Each change is wrapped in a COMPLETE DCS-BIOS sync+address+count+data frame:
  4 (sync) + 2 (address) + 2 (count) + 2 (value) = 10 bytes per change.

  The actual payload is 4 bytes (address + value). The overhead is 150%.

WHY THIS MATTERS:

  The DCS-BIOS protocol supports MULTI-WORD frames natively. A single sync
  header can carry multiple consecutive address/value pairs:

    [0x55 0x55 0x55 0x55] [addr_lo addr_hi] [count_lo count_hi] [data...]

  Where count = total data bytes. If you have 6 changes at consecutive
  addresses (e.g., 0x1000, 0x1002, 0x1004, 0x1006, 0x1008, 0x100A), you could
  send:

    [0x55 0x55 0x55 0x55] [0x00 0x10] [0x0C 0x00] [v1_lo v1_hi v2_lo ...]
    = 4 + 2 + 2 + 12 = 20 bytes for 6 values

  vs current: 6 * 10 = 60 bytes for 6 values (3x the wire time)

  At 250kbps:
    60 bytes = 2.4ms wire time
    20 bytes = 0.8ms wire time

  This directly affects poll frequency. Every 1.6ms saved on broadcast is
  1.6ms more polling time.

  HOWEVER: Changes are typically NOT at consecutive addresses. DCS-BIOS export
  data is sparse — a cockpit change might touch addresses 0x1234, 0x5678, and
  0x7ABC. These cannot be combined into a single frame.

PROPOSED FIX:

  Sort the change queue by address, then batch consecutive addresses into
  single frames. Non-consecutive changes get individual frames (as now).

  This is an OPTIMIZATION, not a bug fix. Impact depends on aircraft/panel
  configuration. For panels that monitor adjacent address ranges (common for
  multi-indicator panels), the savings can be significant.

  RECOMMENDATION: Low priority. The current approach works correctly, is simple,
  and the bandwidth overhead is manageable at 250kbps with typical change rates.


--------------------------------------------------------------------------------
2.7  Discovery Scan Without Separate Counter — Master Only [LOW]
--------------------------------------------------------------------------------

LOCATION:
  Master: RS485Master.cpp:944-981 (advancePollAddress)

CURRENT CODE:

    static uint8_t advancePollAddress() {
        ...
        if (discoveryCounter >= RS485_DISCOVERY_INTERVAL) {
            discoveryCounter = 0;
            uint8_t probeAddr = currentPollAddr;  // Starts from current position
            for (uint8_t i = 1; i <= RS485_MAX_SLAVE_ADDRESS; i++) {
                probeAddr = (probeAddr % RS485_MAX_SLAVE_ADDRESS) + 1;
                if (!slavePresent[probeAddr]) {
                    return probeAddr;
                }
            }
        }
        ...
    }

  The AVR uses SEPARATE counters:
    - poll_address_counter: tracks current position in known-slave round-robin
    - scan_address_counter: tracks current position in unknown-address scan

  The CockpitOS version uses `currentPollAddr` as the starting point for both,
  meaning the discovery scan address depends on where the poll counter is.

WHY THIS MATTERS (minimally):

  With the AVR's separate counters, the scan is deterministic and covers all
  addresses evenly regardless of which known slave was just polled. With the
  current code, if currentPollAddr is 5 and the only unknown address is 3,
  the scan starts from 5 and wraps: 6, 7, ..., 127, 1, 2, 3 — eventually
  finding it. If currentPollAddr were already 2, it would find 3 immediately.

  The net effect is that discovery timing is slightly non-uniform but
  functionally correct. All unknown addresses will eventually be probed.

PROPOSED FIX:

    static uint8_t scanAddressCounter = 1;  // Separate counter

    // In discovery branch:
    scanAddressCounter = (scanAddressCounter % RS485_MAX_SLAVE_ADDRESS) + 1;
    while (slavePresent[scanAddressCounter]) {
        scanAddressCounter = (scanAddressCounter % RS485_MAX_SLAVE_ADDRESS) + 1;
    }
    return scanAddressCounter;

RISK IF NOT FIXED: None functional. Discovery is slightly less uniform.


--------------------------------------------------------------------------------
2.8  Unreachable RX_SKIP_CHECKSUM State — Slave Only [LOW]
--------------------------------------------------------------------------------

LOCATION:
  Slave: RS485Slave.cpp:566-568

CURRENT CODE:

    case SlaveState::RX_SKIP_CHECKSUM:
        state = SlaveState::RX_WAIT_ADDRESS;
        break;

WHY THIS IS DEAD CODE:

  When the slave skips another slave's response:
  - RX_SKIP_LENGTH reads the data length byte
  - Sets skipRemaining = length + 2 (MsgType + Length data bytes + Checksum)
  - Transitions to RX_SKIP_DATA
  - RX_SKIP_DATA decrements skipRemaining for each byte
  - When skipRemaining == 0, transitions to RX_WAIT_ADDRESS

  The checksum byte is counted in `skipRemaining = c + 2`, so it's consumed
  by RX_SKIP_DATA, not by RX_SKIP_CHECKSUM. No code path ever sets
  state = SlaveState::RX_SKIP_CHECKSUM.

PROPOSED FIX:

  Remove the state and its enum entry. This is pure dead code cleanup.
  Add a comment explaining why the skip path doesn't need a separate checksum
  state (the +2 in skipRemaining covers MsgType and Checksum).


================================================================================
3. DRIVER PATH — ROOT CAUSE FAILURE ANALYSIS
================================================================================


--------------------------------------------------------------------------------
3.1  The Fundamental Timing Problem
--------------------------------------------------------------------------------

The DCS-BIOS RS485 protocol has a HARD timing constraint:

  After the master sends a poll frame (3 bytes = 120us at 250kbps),
  the slave MUST respond with its first byte within 1000us (1ms).

  After the master receives the first byte of a slave's response,
  subsequent bytes must arrive within 5000us (5ms) of each other.

For the MASTER in driver mode, the critical path is:

  1. sendPoll() calls txWithEchoPrevention():
     - uart_write_bytes() — blocks until data is in the FIFO/ring buffer
     - uart_wait_tx_done() — blocks until TX_DONE (last bit leaves shift register)
     - For DE-pin devices: hardware RS485 mode releases DE automatically
     - For auto-direction devices: manual uart_flush_input()
     Total: ~120us (3 bytes at 250kbps) + IDF overhead

  2. sendPoll() sets rxStartTime and state = RX_WAIT_DATALENGTH
     Inside a portENTER_CRITICAL / portEXIT_CRITICAL section.

  3. rs485PollLoop() RETURNS to the task loop

  4. vTaskDelayUntil sleeps for RS485_TASK_TICK_INTERVAL (1ms = 1 tick)

  5. Next rs485PollLoop() invocation:
     - uart_read_bytes(..., 0) with timeout=0 (non-blocking)
     - Drains IDF ring buffer into local rxBuf
     - Processes each byte through processRxByte()

  THE PROBLEM: Between step 2 and step 5, up to 1ms passes. The slave
  typically responds within 100-200us. Its response bytes arrive during
  step 4 (the sleep) and are buffered by the IDF driver's internal ISR
  into the 256-byte ring buffer. This part is fine.

  But checkRxTimeout() runs in step 5, comparing rxStartTime (set in step 2)
  against esp_timer_get_time() (read in step 5). The elapsed time is:

    ~120us (TX) + ~0-1000us (vTaskDelay scheduling) + ~0-100us (task resume)

  Worst case: 120 + 1000 + 100 = 1220us > 1000us timeout
  This EXCEEDS the poll timeout, causing a false timeout on a slave that
  actually responded.

  The race condition is:
  - If the task wakes up quickly (< ~880us after TX), it reads the response
    bytes BEFORE the timeout fires. Works correctly.
  - If the task wakes up slowly (> ~880us after TX), checkRxTimeout fires
    BEFORE uart_read_bytes runs, marking the slave as offline.

  On a busy system (WiFi active, other tasks at same priority), FreeRTOS tick
  timing is not guaranteed to be exactly 1ms. Task wake jitter of +-500us is
  common.

For the SLAVE in driver mode, the problem is even more severe:

  The slave must respond WITHIN the master's 1ms poll timeout. This means:
  - The slave must DETECT the poll (reading the address+msgtype+length bytes)
  - The slave must DECIDE to respond (check address match)
  - The slave must TRANSMIT the response (at least the first byte)
  All within ~880us of the poll's last byte leaving the master.

  With 1ms task tick polling, the slave's uart_read_bytes sees the poll bytes
  up to 1ms AFTER they arrive. Add processing time, and the response TX starts
  1-2ms after the poll — AFTER the master has already timed out.


--------------------------------------------------------------------------------
3.2  Why uart_read_bytes Cannot Meet Protocol Requirements
--------------------------------------------------------------------------------

The ESP-IDF uart_read_bytes() function operates through this chain:

  UART RX FIFO → IDF ISR → Ring Buffer → uart_read_bytes() → user code

  The IDF ISR (installed by uart_driver_install) is a general-purpose handler
  that:
  1. Reads bytes from the FIFO into the driver's ring buffer
  2. Posts a UART_DATA event to the event queue
  3. Optionally wakes a blocked uart_read_bytes caller

  When called with timeout=0, uart_read_bytes returns whatever is currently in
  the ring buffer WITHOUT blocking. But it provides NO callback mechanism to
  notify the task when new data arrives.

  The uart_read_bytes() call with timeout > 0 DOES block until data arrives,
  but it blocks the ENTIRE task, preventing timeout checking and other
  operations.

  This creates an impossible choice:
  - timeout=0: Non-blocking, but you must poll. Polling interval = task tick.
  - timeout>0: Blocks until data, but can't do anything else while waiting.

  Neither option provides the sub-100us response time needed for protocol
  compliance.

WHAT THE AVR DOES DIFFERENTLY:

  The AVR processes each byte IN the ISR. There is no "polling" step.
  When a byte arrives, USART_RX_vect fires immediately, the state machine
  runs, and if a response is needed, TX begins within the same ISR chain.
  Total latency from last poll byte to first response byte: ~10-20us.

  The CockpitOS ISR mode replicates this exactly. The ISR processes bytes
  inline and can respond within ~8-20us.

  The driver mode CANNOT replicate this because the IDF driver's ISR handles
  the byte (putting it in the ring buffer), but the protocol logic runs in
  a separate context (the task) with scheduling-dependent latency.


--------------------------------------------------------------------------------
3.3  Evidence From ESP-IDF Source Code
--------------------------------------------------------------------------------

The ESP32 Arduino Core 3.3.6 (esp32-hal-uart.c) provides the uartSetFastReading
function (line 848-863):

    void uartSetFastReading(uart_t *uart) {
        uart_intr_config_t uart_intr = {
            .intr_enable_mask = UART_INTR_RXFIFO_FULL | UART_INTR_RXFIFO_TOUT,
            .rx_timeout_thresh = 1,        // Trigger after 1 symbol of silence
            .txfifo_empty_intr_thresh = 10,
            .rxfifo_full_thresh = 2,       // Trigger after 2 bytes
        };
        uart_intr_config(uart->num, &uart_intr);
    }

  This function REDUCES the driver's interrupt thresholds for faster byte
  delivery to the ring buffer. But it doesn't change the fundamental
  architecture: bytes still go to the ring buffer, and the task still polls.

  HardwareSerial::onReceive() (HardwareSerial.h:306) provides a CALLBACK:

    void onReceive(OnReceiveCb function, bool onlyOnTimeout = false);

  This callback is invoked from a dedicated event task
  (ARDUINO_SERIAL_EVENT_TASK_PRIORITY = configMAX_PRIORITIES - 1) when:
  - RXFIFO_FULL bytes accumulate (default 120), or
  - RXFIFO_TOUT fires (default 10 symbols of silence)

  The event task runs at near-maximum priority. If the callback processes bytes
  and triggers TX, the latency would be:
    ISR → event queue → event task wake → callback → TX
    Estimated: ~50-200us total

  This is SIGNIFICANTLY better than 1ms polling, but still worse than the
  ISR-mode direct processing (~2-8us from byte arrival to state machine run).


--------------------------------------------------------------------------------
3.4  The HardwareSerial onReceive Callback Alternative
--------------------------------------------------------------------------------

If we wanted to salvage driver mode, the HardwareSerial::onReceive callback
is the most promising approach:

    HardwareSerial RS485Serial(RS485_UART_NUM);

    void onRS485Receive() {
        while (RS485Serial.available()) {
            uint8_t c = RS485Serial.read();
            processRxByte(c);  // Run state machine per byte
        }
    }

    void initRS485_DriverCallback() {
        RS485Serial.begin(RS485_BAUD, SERIAL_8N1, RS485_RX_PIN, RS485_TX_PIN);
        RS485Serial.setRxFIFOFull(1);         // Interrupt on every byte
        RS485Serial.setRxTimeout(1);          // Timeout after 1 symbol
        RS485Serial.onReceive(onRS485Receive, false);  // Callback on FIFO full too
        RS485Serial.setMode(UART_MODE_RS485_HALF_DUPLEX);  // If DE pin used
        RS485Serial.setPins(-1, -1, -1, RS485_DE_PIN);     // Map RTS to DE
    }

  Pros:
  - Uses official Arduino API (portable, stable across IDF versions)
  - onReceive runs at configMAX_PRIORITIES-1 (priority 24 on default config)
  - setRxFIFOFull(1) + setRxTimeout(1) minimizes latency
  - Hardware RS485 mode handles DE automatically
  - No bare-metal register access needed

  Cons:
  - Still goes through ISR → ring buffer → event queue → event task → callback
  - Estimated latency: 50-200us per byte (vs 2-8us for bare-metal ISR)
  - onReceive callback runs in a SEPARATE task, not the RS485 task. Shared
    state access requires synchronization.
  - The UART event task stack is only 2048 bytes (ARDUINO_SERIAL_EVENT_TASK_STACK_SIZE).
    Running the full state machine + TX in this callback risks stack overflow.
  - TX from the callback (RS485Serial.write()) goes through the driver's TX
    path, which is slower than direct FIFO write.

  For the MASTER, onReceive latency of 50-200us is acceptable — the master
  only needs to detect slave responses, and the 1ms poll timeout gives plenty
  of margin if the callback fires within 200us.

  For the SLAVE, the response must be sent within ~880us of the poll's last
  byte. With 50-200us callback latency + TX time, this is tight but feasible
  for short responses (1-30 bytes).

  VERDICT: onReceive-based driver mode is a VIABLE FALLBACK for the master,
  MARGINAL for the slave. It does NOT match ISR mode performance but is
  functional for systems where ISR mode is not available (e.g., when the
  UART peripheral is already claimed by the IDF driver for another purpose).


--------------------------------------------------------------------------------
3.5  Verdict: Is Driver Mode Fundamentally Impossible?
--------------------------------------------------------------------------------

  Q: Is the driver path broken due to a SOFTWARE BUG?
  A: PARTIALLY YES. The specific bug is the 1ms polling interval
     (vTaskDelayUntil with RS485_TASK_TICK_INTERVAL=1) combined with timeout
     checking AFTER polling. This creates a race condition where the timeout
     can fire before bytes are read.

  Q: Could this software bug be fixed?
  A: YES, but not completely. Reducing the task tick interval to 0ms (no delay,
     tight loop) would eliminate the sleep gap but would spin the CPU at 100%,
     defeating the purpose of FreeRTOS scheduling.

     The REAL fix is to not poll for bytes at all — use the onReceive callback
     approach described in section 3.4.

  Q: Is driver mode FUNDAMENTALLY impossible for RS485 master/slave?
  A: NO, but it requires a different architecture than the current polling
     approach. An onReceive-callback driver mode is viable for the master
     and marginal for the slave. It will NEVER match ISR-mode latency
     (50-200us vs 2-8us), but it can meet protocol timing requirements.

  Q: Why does the AVR not have this problem?
  A: The AVR has NO OS. There is no scheduler, no task switching, no ring
     buffer between the ISR and the protocol logic. The ISR IS the protocol
     logic. The ESP32 ISR mode replicates this architecture exactly. The
     driver mode inserts an OS layer (ISR → ring buffer → scheduler → task)
     between the hardware and the protocol, adding 50-1000us of latency.

SUMMARY:
  - Current driver mode: BROKEN. Polling-based timing cannot meet protocol.
  - Fixed driver mode (onReceive): VIABLE for master, MARGINAL for slave.
  - ISR mode: CORRECT. Matches AVR architecture. Keep as primary path.


--------------------------------------------------------------------------------
3.6  A Hybrid Architecture That Could Work
--------------------------------------------------------------------------------

If a working driver-mode fallback is desired, the architecture should be:

  INIT:
    uart_driver_install(RS485_UART_NUM, 256, 0, 0, NULL, 0);
    uart_param_config(RS485_UART_NUM, &uart_config);
    uart_set_pin(RS485_UART_NUM, TX, RX, DE, UART_PIN_NO_CHANGE);
    uart_set_mode(RS485_UART_NUM, UART_MODE_RS485_HALF_DUPLEX);

    // Configure for minimum latency
    uart_set_rx_full_threshold(RS485_UART_NUM, 1);
    uart_set_rx_timeout(RS485_UART_NUM, 1);

    // Get the IDF event queue
    QueueHandle_t uart_queue;
    uart_driver_install(RS485_UART_NUM, 256, 0, 20, &uart_queue, 0);

  RX TASK (replaces polling loop):
    static void rs485RxTask(void* param) {
        uart_event_t event;
        while (taskRunning) {
            if (xQueueReceive(uart_queue, &event, pdMS_TO_TICKS(10))) {
                if (event.type == UART_DATA) {
                    uint8_t rxBuf[128];
                    int len = uart_read_bytes(RS485_UART_NUM, rxBuf, event.size, 0);
                    for (int i = 0; i < len; i++) {
                        processRxByte(rxBuf[i]);
                    }
                }
            }
            // Check timeouts regardless of whether we received data
            checkRxTimeout();
        }
    }

  TX (from main task or RX task):
    uart_write_bytes(RS485_UART_NUM, data, len);
    uart_wait_tx_done(RS485_UART_NUM, pdMS_TO_TICKS(10));
    // Hardware RS485 mode handles DE and echo automatically

  This approach uses the IDF's UART event queue instead of polling. The
  xQueueReceive call blocks until a UART event arrives (with a 10ms safety
  timeout). When UART_DATA events arrive, bytes are processed immediately.

  Latency: ISR → ring buffer → event queue → xQueueReceive wake → read → process
  Estimated: 100-500us from byte arrival to processRxByte

  This is NOT as good as ISR mode but should be sufficient for the master's
  1ms poll timeout. For the slave, it is marginal.


================================================================================
4. WiFi/BLE CORE CONTENTION ANALYSIS
================================================================================

The ESP32 (dual-core) and ESP32-S3 (dual-core) run WiFi/BLE on Core 0 by
default (CONFIG_ESP_WIFI_TASK_CORE_ID = 0). The RS485 task defaults to Core 1.

CONTENTION SCENARIOS:

  (a) RS485 ISR mode on Core 1, WiFi on Core 0:
      NO contention. Each core has its own interrupt controller. The RS485 UART
      ISR on Core 1 is never delayed by WiFi ISRs on Core 0. This is the IDEAL
      configuration and the current default.

  (b) RS485 ISR mode on Core 0, WiFi on Core 0:
      SEVERE contention. WiFi ISRs (particularly the Wi-Fi BB ISR) can hold
      Core 0's interrupt disabled for up to 50-100us. During this time, UART
      RX bytes accumulate in the FIFO (128-byte depth, so no overflow at
      250kbps for up to 51ms). But the state machine doesn't run, so:
      - Master: poll timeout may fire prematurely if WiFi ISR delays byte
        processing by > 1ms
      - Slave: response to poll may be delayed by > 1ms, causing master timeout

  (c) RS485 on single-core chip (C3, C6, H2):
      WiFi and RS485 ISRs share the same (only) core. The ESP-IDF interrupt
      priority system ensures Level 1 interrupts (our RS485 UART ISR) can be
      preempted by higher-priority WiFi interrupts.

      Our ISR is allocated with ESP_INTR_FLAG_LEVEL1 (lowest ISR priority).
      WiFi BB ISR typically runs at Level 1 or Level 2. This means:

      - If WiFi ISR is Level 1 (same as ours): no preemption, but our ISR
        will be delayed while WiFi ISR runs. WiFi ISR duration: ~10-50us
        typical, up to 100us worst case.
      - If WiFi ISR is Level 2+: WiFi can preempt our ISR mid-execution.
        This is actually FINE because our ISR is interrupt-safe (no shared
        state modified without volatile, no non-reentrant calls).

      The V3.1 TX_DONE improvement is critical here: the old spin-wait TX
      blocked the ISR for ~220us. On single-core with WiFi, this would block
      WiFi ISRs for 220us — causing WiFi packet loss and stack instability.
      The TX_DONE approach reduces ISR time to ~8us, making WiFi coexistence
      viable on single-core chips.

  (d) RS485 driver mode on any core with WiFi:
      Driver mode uses FreeRTOS tasks, which are scheduled by the tick
      scheduler. WiFi tasks run at priority 23 (ESP_TASK_PRIO_MAX - 1).
      RS485 task runs at priority 5 (default). WiFi tasks will ALWAYS
      preempt the RS485 task. On a busy WiFi connection (streaming data),
      the RS485 task may be starved for up to 10-50ms, far exceeding all
      protocol timeouts.

      The onReceive callback approach (section 3.4) partially mitigates
      this because the serial event task runs at configMAX_PRIORITIES-1
      (priority 24 on default config), which is HIGHER than WiFi tasks.

RECOMMENDATION:

  For dual-core ESP32/S3:
    - ISR mode on Core 1 (default). No WiFi contention. IDEAL.

  For single-core C3/C6/H2:
    - ISR mode with TX_DONE (current v3.1). WiFi coexistence is viable.
    - Consider raising ISR priority to Level 2 if WiFi stability is an issue:
      esp_intr_alloc(..., ESP_INTR_FLAG_IRAM | ESP_INTR_FLAG_LEVEL2, ...);
    - Monitor for missed polls (statTimeouts) as an indicator of contention.

  For any chip with driver mode:
    - NOT RECOMMENDED for production. WiFi task priority > RS485 task priority
      creates unpredictable latency spikes that violate protocol timing.


================================================================================
5. IMPLEMENTATION PRIORITY ORDER
================================================================================

Priority 1 (should fix):
  2.2  Add RXFIFO_TOUT to init + all RX enable paths (both master and slave)
       Effort: ~20 lines changed. Risk: none. Benefit: eliminates edge-case
       byte loss on broadcast streams.

  2.3  Reduce esp_timer_get_time calls in ISR (both master and slave)
       Effort: ~30 lines changed. Risk: none. Benefit: reduces ISR time by
       ~10-20us per broadcast frame, improves WiFi coexistence.

Priority 2 (should fix when convenient):
  2.1  Clean up uart_param_config usage in ISR init (both master and slave)
       Effort: ~40 lines changed. Risk: low (tested alternative path needed).
       Benefit: eliminates fragile cross-API dependency.

  2.4  Add core-pinning assertion for MessageBuffer safety (master)
       Effort: ~5 lines. Risk: none. Benefit: prevents future misconfig.

  2.5  Reduce RS485_RELAY_CHUNK_SIZE to fit FIFO (master)
       Effort: 1 line. Risk: none. Benefit: eliminates spin-wait path.

Priority 3 (nice to have):
  2.6  Smart mode frame batching (master) — optimization, not a fix
  2.7  Separate discovery scan counter (master) — behavioral parity with AVR
  2.8  Remove dead RX_SKIP_CHECKSUM state (slave) — code cleanup

Priority 4 (optional, significant effort):
  3.6  Implement hybrid driver-mode architecture — only if a working fallback
       is required for specific deployment scenarios.


================================================================================
6. FILE REFERENCE MAP
================================================================================

CockpitOS RS485 Implementation:
  lib/CUtils/src/RS485Config.h               Master configuration
  lib/CUtils/src/RS485SlaveConfig.h           Slave configuration
  lib/CUtils/src/internal/RS485Master.cpp     Master implementation (1441 lines)
  lib/CUtils/src/internal/RS485Slave.cpp      Slave implementation (1297 lines)
  lib/CUtils/src/CUtils.h                     Public API declarations (lines 220-246)

ESP32 Arduino Core 3.3.6 UART:
  cores/esp32/esp32-hal-uart.h                HAL header (uart_t, uartBegin, uartSetMode)
  cores/esp32/esp32-hal-uart.c                HAL implementation (uartBegin, uartSetFastReading)
  cores/esp32/HardwareSerial.h                Arduino Serial class (onReceive, setMode, setRxFIFOFull)
  cores/esp32/HardwareSerial.cpp              Arduino Serial implementation

AVR DCS-BIOS Reference:
  libraries/DCS-BIOS/src/internal/DcsBiosNgRS485Master.h       AVR master header
  libraries/DCS-BIOS/src/internal/DcsBiosNgRS485Master.cpp.inc AVR master implementation
  libraries/DCS-BIOS/src/internal/DcsBiosNgRS485Slave.h        AVR slave header
  libraries/DCS-BIOS/src/internal/DcsBiosNgRS485Slave.cpp.inc  AVR slave implementation
  libraries/DCS-BIOS/src/internal/Protocol.h                   DCS-BIOS protocol parser
  libraries/DCS-BIOS/src/internal/Protocol.cpp                 Protocol parser implementation
  libraries/DCS-BIOS/src/internal/RingBuffer.h                 Lock-free ring buffer

================================================================================
END OF DOCUMENT
================================================================================
