/**
 * @file RS485Master.cpp
 * @brief RS-485 Master Driver for CockpitOS - v2.4 ISR-Only
 *
 * ARCHITECTURE:
 *   - Bare-metal UART using uart_ll_* for direct hardware access
 *   - ISR-driven RX with FIFO threshold of 1 for minimum latency
 *   - State machine runs DIRECTLY in ISR (like AVR) - no buffering delay
 *   - TX is NON-BLOCKING: FIFO loaded, TX_DONE interrupt handles bus turnaround
 *   - Bus released within ~1us of last bit (matches AVR TXC behavior)
 *   - RISC-V memory barriers for ESP32-C3/C6 cache coherency
 *   - Smart mode with DcsOutputTable filtering and change detection
 *   - Relay mode for Arduino-compatible raw byte pumping
 *
 * V2.3 CRITICAL FIX - TX_DONE NON-BLOCKING TX:
 *   The v2.2 blocking txWithEchoPrevention() held DE HIGH for ~52us after
 *   TX completed (cooldown delay + sequential operations). Fast auto-direction
 *   slaves responded during this window, causing bus contention and lost inputs.
 *   V2.3 uses UART_INTR_TX_DONE to release the bus at the exact hardware moment
 *   TX finishes — matching the AVR's TXC ISR behavior. This eliminates the
 *   interoperability bug with mixed hardware types.
 *
 * V2.2 IMPROVEMENTS (from standalone master.ino v2):
 *   - State machine runs in ISR: Bytes are processed immediately as they
 *     arrive, not buffered then processed later. This matches AVR behavior
 *     exactly and provides lowest possible latency.
 *   - Immediate slave response forwarding: After processResponse() detects
 *     a complete message, it's forwarded to CockpitOS immediately.
 *
 * RATIONALE:
 *   ISR mode is the only viable approach for RS485 on ESP32. The master
 *   controls bus timing and needs lowest possible latency to catch slave
 *   responses. Both master and slave use bare-metal UART with ISR-driven
 *   RX and TX_DONE non-blocking TX for optimal timing.
 *
 * PROTOCOL: 100% compatible with Arduino DCS-BIOS RS485 implementation
 *
 * ==========================================================================
 */

#if RS485_MASTER_ENABLED

#include "../RS485Config.h"

// ESP-IDF includes
#include "esp_attr.h"
#include "esp_intr_alloc.h"
#include "driver/periph_ctrl.h"
#include "driver/uart.h"
#include "driver/gpio.h"
#include "hal/uart_ll.h"
#include "hal/gpio_ll.h"
#include "soc/uart_periph.h"

// FreeRTOS includes (for task mode)
#if RS485_USE_TASK
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#endif

// RISC-V fence for C3/C6 cache coherency
#if CONFIG_IDF_TARGET_ESP32C3 || CONFIG_IDF_TARGET_ESP32C6 || CONFIG_IDF_TARGET_ESP32H2
    #define RS485_RISCV_FENCE() __asm__ __volatile__("fence" ::: "memory")
#else
    #define RS485_RISCV_FENCE() do {} while(0)
#endif

// ============================================================================
// HARDWARE ABSTRACTION
// ============================================================================

// Map UART number to hardware
#if RS485_UART_NUM == 0
    #define RS485_UART_DEV      UART_LL_GET_HW(0)
    #define RS485_UART_PERIPH   PERIPH_UART0_MODULE
    #define RS485_UART_SIGNAL   U0TXD_OUT_IDX
    #define RS485_UART_RX_SIG   U0RXD_IN_IDX
    #define RS485_UART_INTR_SRC ETS_UART0_INTR_SOURCE
#elif RS485_UART_NUM == 1
    #define RS485_UART_DEV      UART_LL_GET_HW(1)
    #define RS485_UART_PERIPH   PERIPH_UART1_MODULE
    #define RS485_UART_SIGNAL   U1TXD_OUT_IDX
    #define RS485_UART_RX_SIG   U1RXD_IN_IDX
    #define RS485_UART_INTR_SRC ETS_UART1_INTR_SOURCE
#else
    #define RS485_UART_DEV      UART_LL_GET_HW(2)
    #define RS485_UART_PERIPH   PERIPH_UART2_MODULE
    #define RS485_UART_SIGNAL   U2TXD_OUT_IDX
    #define RS485_UART_RX_SIG   U2RXD_IN_IDX
    #define RS485_UART_INTR_SRC ETS_UART2_INTR_SOURCE
#endif

// ============================================================================
// PROTOCOL CONSTANTS
// ============================================================================

static constexpr uint8_t ADDR_BROADCAST = 0;
static constexpr uint8_t MSGTYPE_DCSBIOS = 0;
static constexpr uint8_t CHECKSUM_PLACEHOLDER = 0x72;

// ============================================================================
// STATE MACHINE (matches standalone master.ino v2)
// ============================================================================

enum class MasterState : uint8_t {
    IDLE,
    TX_WAITING_DONE,        // FIFO loaded, waiting for TX_DONE interrupt
    RX_WAIT_DATALENGTH,
    RX_WAIT_MSGTYPE,
    RX_WAIT_DATA,
    RX_WAIT_CHECKSUM
};

// TX completion context — tells the TX_DONE handler what to do after bus turnaround
enum class TxContext : uint8_t {
    POLL,       // After TX: transition to RX_WAIT_DATALENGTH, start RX timeout
    BROADCAST,  // After TX: go back to IDLE
    TIMEOUT     // After TX: go back to IDLE (timeout zero byte)
};

// ============================================================================
// MESSAGE BUFFER - Lock-free ring buffer for slave responses
// ============================================================================

template<uint16_t SIZE>
class MessageBuffer {
private:
    volatile uint8_t buffer[SIZE];
    volatile uint16_t writePos;
    volatile uint16_t readPos;

public:
    volatile bool complete;
    volatile uint32_t dropCount;

    MessageBuffer() : writePos(0), readPos(0), complete(false), dropCount(0) {}

    void IRAM_ATTR put(uint8_t c) {
        if (getLength() < SIZE) {  // Overflow protection: drop byte if buffer full
            buffer[writePos % SIZE] = c;
            writePos++;
        } else {
            dropCount++;
        }
    }

    uint8_t get() {
        uint8_t c = buffer[readPos % SIZE];
        readPos++;
        return c;
    }

    uint16_t getLength() const { return (uint16_t)(writePos - readPos); }
    bool isEmpty() const { return writePos == readPos; }
    bool isNotEmpty() const { return writePos != readPos; }

    void clear() {
        readPos = 0;
        writePos = 0;
        complete = false;
    }
};

static MessageBuffer<RS485_INPUT_BUFFER_SIZE> messageBuffer;

// ============================================================================
// SMART MODE: CHANGE TRACKING (only when RS485_SMART_MODE=1)
// ============================================================================

#if RS485_SMART_MODE

// DCS-BIOS export stream parser state
enum ParseState : uint8_t {
    PARSE_WAIT_SYNC,
    PARSE_ADDRESS_LOW,
    PARSE_ADDRESS_HIGH,
    PARSE_COUNT_LOW,
    PARSE_COUNT_HIGH,
    PARSE_DATA_LOW,
    PARSE_DATA_HIGH
};

static ParseState parseState = PARSE_WAIT_SYNC;
static uint8_t syncByteCount = 0;
static uint16_t parseAddress = 0;
static uint16_t parseCount = 0;
static uint16_t parseData = 0;

// Change tracking for delta compression
#if RS485_CHANGE_DETECT
static uint16_t prevExport[0x4000];  // 32KB for address range 0x0000-0x7FFF
static bool prevInitialized = false;
#endif

// Change queue
struct Change { uint16_t address; uint16_t value; };
static Change changeQueue[RS485_CHANGE_QUEUE_SIZE];
static volatile uint16_t changeHead = 0;
static volatile uint16_t changeTail = 0;
static volatile uint16_t changeCount = 0;

// Forward declaration for DcsOutputTable lookup (from DCSBIOSBridgeData.h)
struct AddressEntry;  // Forward declare the struct
extern const AddressEntry* findDcsOutputEntries(uint16_t addr);

static void initPrevValues() {
    #if RS485_CHANGE_DETECT
    for (size_t i = 0; i < 0x4000; ++i) {
        prevExport[i] = 0xFFFFu;
    }
    prevInitialized = true;
    #endif
}

static void queueChange(uint16_t address, uint16_t value) {
    if (changeCount >= RS485_CHANGE_QUEUE_SIZE) {
        // Queue full - drop oldest
        changeTail = (changeTail + 1) % RS485_CHANGE_QUEUE_SIZE;
        changeCount--;
    }
    changeQueue[changeHead].address = address;
    changeQueue[changeHead].value = value;
    changeHead = (changeHead + 1) % RS485_CHANGE_QUEUE_SIZE;
    changeCount++;
}

static void processAddressValue(uint16_t address, uint16_t value) {
    if (address >= 0x8000) return;  // Invalid address range

    // Filter by DcsOutputTable (CockpitOS label set)
    if (findDcsOutputEntries(address) == nullptr) {
        return;  // Not needed by any slave
    }

    #if RS485_CHANGE_DETECT
    uint16_t index = address >> 1;
    if (prevExport[index] == value) return;  // No change
    prevExport[index] = value;
    #endif

    queueChange(address, value);
}

static void parseExportByte(uint8_t c) {
    // Sync detection runs in parallel with parsing
    if (c == 0x55) {
        syncByteCount++;
    } else {
        syncByteCount = 0;
    }

    if (syncByteCount >= 4) {
        parseState = PARSE_ADDRESS_LOW;
        syncByteCount = 0;
        return;
    }

    switch (parseState) {
        case PARSE_WAIT_SYNC:
            break;
        case PARSE_ADDRESS_LOW:
            parseAddress = c;
            parseState = PARSE_ADDRESS_HIGH;
            break;
        case PARSE_ADDRESS_HIGH:
            parseAddress |= ((uint16_t)c << 8);
            parseState = (parseAddress != 0x5555) ? PARSE_COUNT_LOW : PARSE_WAIT_SYNC;
            break;
        case PARSE_COUNT_LOW:
            parseCount = c;
            parseState = PARSE_COUNT_HIGH;
            break;
        case PARSE_COUNT_HIGH:
            parseCount |= ((uint16_t)c << 8);
            parseState = PARSE_DATA_LOW;
            break;
        case PARSE_DATA_LOW:
            parseData = c;
            parseCount--;
            parseState = PARSE_DATA_HIGH;
            break;
        case PARSE_DATA_HIGH:
            parseData |= ((uint16_t)c << 8);
            parseCount--;
            processAddressValue(parseAddress, parseData);
            parseAddress += 2;
            parseState = (parseCount == 0) ? PARSE_ADDRESS_LOW : PARSE_DATA_LOW;
            break;
    }
}

#else
// ============================================================================
// RELAY MODE: RAW BYTE BUFFER (only when RS485_SMART_MODE=0)
// ============================================================================

static uint8_t rawBuffer[RS485_RAW_BUFFER_SIZE];
static volatile uint16_t rawHead = 0;
static volatile uint16_t rawTail = 0;

static inline uint16_t rawCount() { return (uint16_t)(rawHead - rawTail); }
static inline bool rawEmpty() { return rawHead == rawTail; }

static void bufferRawByte(uint8_t byte) {
    if (rawCount() >= RS485_RAW_BUFFER_SIZE - 1) {
        // Overflow - discard oldest
        rawTail++;
    }
    rawBuffer[rawHead % RS485_RAW_BUFFER_SIZE] = byte;
    rawHead++;
}

#endif // RS485_SMART_MODE

// ============================================================================
// STATE VARIABLES
// ============================================================================

static volatile MasterState state = MasterState::IDLE;
static volatile TxContext txContext = TxContext::BROADCAST;  // Current TX completion context
static intr_handle_t intrHandle = nullptr;
static bool initialized = false;

// Slave tracking
static bool slavePresent[128];  // Which slaves have responded
static uint8_t currentPollAddr = 1;
static uint8_t discoveryCounter = 0;

// Timing (volatile - accessed from ISR)
static volatile int64_t rxStartTime = 0;
static volatile int64_t lastPollUs = 0;
static volatile int64_t messageCompleteTime = 0;  // For messageBuffer drain timeout (Fix 3)

// Response parsing (volatile - modified in ISR)
static volatile uint8_t rxtxLen = 0;
static volatile uint8_t rxMsgType = 0;

// Broadcast buffer
static uint8_t broadcastBuffer[256];
static size_t broadcastLen = 0;

// Statistics
static uint32_t statPolls = 0;
static uint32_t statResponses = 0;
static uint32_t statTimeouts = 0;
static uint32_t statBroadcasts = 0;
static uint32_t statInputCmds = 0;
static uint32_t statBytesOut = 0;

// ============================================================================
// FREERTOS TASK (when RS485_USE_TASK=1)
// ============================================================================

#if RS485_USE_TASK

// Command from slave to be processed by main loop
struct SlaveCommand {
    char label[48];
    char value[16];
};

static TaskHandle_t rs485TaskHandle = nullptr;
static QueueHandle_t cmdQueue = nullptr;
static volatile bool taskRunning = false;

// Forward declaration for the internal poll loop
static void rs485PollLoop();

// FreeRTOS task function
static void rs485Task(void* param) {
    (void)param;

    debugPrintln("[RS485M] Task started");

    TickType_t lastWakeTime = xTaskGetTickCount();

    while (taskRunning) {
        // Run the poll loop
        rs485PollLoop();

        // Wait for next tick interval
        vTaskDelayUntil(&lastWakeTime, pdMS_TO_TICKS(RS485_TASK_TICK_INTERVAL));
    }

    debugPrintln("[RS485M] Task stopped");
    vTaskDelete(nullptr);
}

// Queue a command from slave to be processed by main loop
static void queueSlaveCommand(const char* label, const char* value) {
    if (!cmdQueue) return;

    SlaveCommand cmd;
    strncpy(cmd.label, label, sizeof(cmd.label) - 1);
    cmd.label[sizeof(cmd.label) - 1] = '\0';
    strncpy(cmd.value, value, sizeof(cmd.value) - 1);
    cmd.value[sizeof(cmd.value) - 1] = '\0';

    // Non-blocking send - drop if queue full
    xQueueSend(cmdQueue, &cmd, 0);
}

// Process queued commands (called from main loop)
static void processQueuedCommands() {
    if (!cmdQueue) return;

    SlaveCommand cmd;
    while (xQueueReceive(cmdQueue, &cmd, 0) == pdTRUE) {
        // Forward to CockpitOS
        sendCommand(cmd.label, cmd.value, false);
    }
}

#endif // RS485_USE_TASK

// ============================================================================
// RX BYTE PROCESSOR - Runs in ISR context (like AVR)
// ============================================================================

// rxStartTime is set ONCE in the TX_DONE handler when a poll completes —
// matching the AVR's TXC ISR behavior (rx_start_time = micros()). The 5ms
// mid-message timeout measures from poll-TX-complete, not from last byte.
// This eliminates per-byte esp_timer_get_time() calls in the ISR hot path.
static inline void IRAM_ATTR processRxByte(uint8_t c) {
    switch (state) {
        case MasterState::RX_WAIT_DATALENGTH:
            rxtxLen = c;
            slavePresent[currentPollAddr] = true;
            if (rxtxLen > 0) {
                state = MasterState::RX_WAIT_MSGTYPE;
            } else {
                // Empty response - slave has no data
                state = MasterState::IDLE;
            }
            break;

        case MasterState::RX_WAIT_MSGTYPE:
            rxMsgType = c;
            (void)rxMsgType;  // Not used but kept for protocol completeness
            state = MasterState::RX_WAIT_DATA;
            break;

        case MasterState::RX_WAIT_DATA:
            messageBuffer.put(c);
            if (--rxtxLen == 0) {
                state = MasterState::RX_WAIT_CHECKSUM;
            }
            break;

        case MasterState::RX_WAIT_CHECKSUM:
            // Checksum intentionally ignored (AVR behavior, Arduino uses 0x72)
            messageBuffer.complete = true;
            messageCompleteTime = esp_timer_get_time();
            state = MasterState::IDLE;
            break;

        default:
            // Unexpected byte while IDLE - discard
            break;
    }
}

// ============================================================================
// UART HELPERS (must be defined before rxISR — TX_DONE handler calls these)
// ============================================================================

static inline void IRAM_ATTR deAssert() {
    #if RS485_DE_PIN >= 0
    gpio_ll_set_level(&GPIO, (gpio_num_t)RS485_DE_PIN, 1);
    #endif
}

static inline void IRAM_ATTR deDeassert() {
    #if RS485_DE_PIN >= 0
    gpio_ll_set_level(&GPIO, (gpio_num_t)RS485_DE_PIN, 0);
    #endif
}

static inline void IRAM_ATTR disableRxInt() {
    uart_ll_disable_intr_mask(RS485_UART_DEV, UART_INTR_RXFIFO_FULL | UART_INTR_RXFIFO_TOUT);
}

static inline void IRAM_ATTR enableRxInt() {
    uart_ll_clr_intsts_mask(RS485_UART_DEV, UART_INTR_RXFIFO_FULL | UART_INTR_RXFIFO_TOUT);
    uart_ll_ena_intr_mask(RS485_UART_DEV, UART_INTR_RXFIFO_FULL | UART_INTR_RXFIFO_TOUT);
}

static inline void IRAM_ATTR flushRxFifo() {
    uart_ll_rxfifo_rst(RS485_UART_DEV);
}

static inline bool txIdle() {
    return uart_ll_is_tx_idle(RS485_UART_DEV);
}

static void txByte(uint8_t c) {
    while (uart_ll_get_txfifo_len(RS485_UART_DEV) == 0) {}
    uart_ll_write_txfifo(RS485_UART_DEV, &c, 1);
}

static void txBytes(const uint8_t* data, size_t len) {
    for (size_t i = 0; i < len; i++) {
        txByte(data[i]);
    }
}

// ============================================================================
// UART INTERRUPT SERVICE ROUTINE - Handles both TX_DONE and RX
// ============================================================================

static void IRAM_ATTR rxISR(void* arg) {
    (void)arg;
    uint32_t uart_intr_status = uart_ll_get_intsts_mask(RS485_UART_DEV);

    // ================================================================
    // TX_DONE: Transmission complete — do bus turnaround
    // ================================================================
    // This is the critical fix for the interop bug. TX_DONE fires when the
    // last bit of the last byte has physically left the shift register.
    // We release the bus HERE — matching the AVR's TXC ISR behavior.
    // No cooldown delay. The transceiver switches in nanoseconds.
    if (uart_intr_status & UART_INTR_TX_DONE) {
        // Flush echo bytes — safe because DE is still HIGH at this instant,
        // so no legitimate slave response bytes can be in the FIFO yet
        flushRxFifo();

        // Release the bus (DE LOW)
        #if RS485_DE_PIN >= 0
        deDeassert();
        #endif

        // Re-enable RX interrupt — receiver is active NOW
        enableRxInt();

        // Disable TX_DONE interrupt — one-shot
        uart_ll_disable_intr_mask(RS485_UART_DEV, UART_INTR_TX_DONE);
        uart_ll_clr_intsts_mask(RS485_UART_DEV, UART_INTR_TX_DONE);

        // Transition based on what we were transmitting
        if (txContext == TxContext::POLL) {
            // Poll TX complete — start listening for slave response
            rxStartTime = esp_timer_get_time();
            state = MasterState::RX_WAIT_DATALENGTH;
        } else {
            // Broadcast or timeout zero — back to idle
            state = MasterState::IDLE;
        }
    }

    // ================================================================
    // RXFIFO_FULL: Incoming byte — process state machine
    // ================================================================
    while (uart_ll_get_rxfifo_len(RS485_UART_DEV) > 0) {
        uint8_t c;
        uart_ll_read_rxfifo(RS485_UART_DEV, &c, 1);
        RS485_RISCV_FENCE();

        // Process byte through state machine immediately (like AVR)
        processRxByte(c);
    }

    // Clear handled interrupt status
    uart_ll_clr_intsts_mask(RS485_UART_DEV, uart_intr_status);
}

// Transmit with echo prevention — NON-BLOCKING (v2.3)
// V2.3 Pattern: disableRx → DE assert → warmup → load FIFO → arm TX_DONE → return
//
// When TX_DONE fires (in rxISR): flush echo → DE release → enableRx → set next state
//
// Cooldown delay is ELIMINATED. TX_DONE fires when the last bit has physically
// left the shift register — the bus can be released immediately.
// This matches AVR TXC ISR behavior and fixes the interop bug with auto-direction slaves.
static void txWithEchoPrevention(const uint8_t* data, size_t len) {
    disableRxInt();

    // Warmup — only needed for manual DE pin devices (transceiver settling)
    // Auto-direction devices switch in nanoseconds on TX activity
    #if RS485_DE_PIN >= 0
    deAssert();
    #if RS485_TX_WARMUP_DELAY_US > 0
    ets_delay_us(RS485_TX_WARMUP_DELAY_US);
    #endif
    #endif

    // Load TX FIFO — all bytes in one burst for polls/timeouts (<=3 bytes),
    // or use txBytes for larger broadcasts that may exceed FIFO depth
    if (len <= 128) {
        uart_ll_write_txfifo(RS485_UART_DEV, data, len);
    } else {
        txBytes(data, len);
    }

    // Arm TX_DONE interrupt — fires when last bit leaves shift register
    uart_ll_clr_intsts_mask(RS485_UART_DEV, UART_INTR_TX_DONE);
    uart_ll_ena_intr_mask(RS485_UART_DEV, UART_INTR_TX_DONE);

    // Mark state — TX_DONE handler in rxISR will complete the bus turnaround
    state = MasterState::TX_WAITING_DONE;

    // Return immediately — CPU is FREE while hardware shifts out the bytes
}

// ============================================================================
// BROADCAST FUNCTIONS
// ============================================================================

#if RS485_SMART_MODE
// SMART MODE: Build DCS-BIOS frames from change queue
static void prepareBroadcastData() {
    broadcastLen = 0;

    while (changeCount > 0 && broadcastLen < RS485_MAX_BROADCAST_CHUNK) {
        Change& change = changeQueue[changeTail];

        // Build complete DCS-BIOS frame for this change
        broadcastBuffer[broadcastLen++] = 0x55;
        broadcastBuffer[broadcastLen++] = 0x55;
        broadcastBuffer[broadcastLen++] = 0x55;
        broadcastBuffer[broadcastLen++] = 0x55;
        broadcastBuffer[broadcastLen++] = change.address & 0xFF;
        broadcastBuffer[broadcastLen++] = (change.address >> 8) & 0xFF;
        broadcastBuffer[broadcastLen++] = 0x02;  // Count low
        broadcastBuffer[broadcastLen++] = 0x00;  // Count high
        broadcastBuffer[broadcastLen++] = change.value & 0xFF;
        broadcastBuffer[broadcastLen++] = (change.value >> 8) & 0xFF;

        changeTail = (changeTail + 1) % RS485_CHANGE_QUEUE_SIZE;
        changeCount--;
    }
}
#else
// RELAY MODE: Drain raw bytes
static void prepareBroadcastData() {
    broadcastLen = 0;

    uint16_t available = rawCount();
    if (available == 0) return;

    size_t toSend = (available > RS485_RELAY_CHUNK_SIZE) ? RS485_RELAY_CHUNK_SIZE : available;

    for (size_t i = 0; i < toSend; i++) {
        broadcastBuffer[broadcastLen++] = rawBuffer[rawTail % RS485_RAW_BUFFER_SIZE];
        rawTail++;
    }
}
#endif

static void sendBroadcast() {
    prepareBroadcastData();

    if (broadcastLen == 0) return;

    // Build complete RS485 frame in one buffer (matches standalone exactly)
    // Frame: [Addr=0][MsgType=0][Length][Data...][Checksum]
    uint8_t frame[256 + 4];
    uint16_t idx = 0;

    frame[idx++] = ADDR_BROADCAST;      // 0x00
    frame[idx++] = MSGTYPE_DCSBIOS;     // 0x00
    frame[idx++] = (uint8_t)broadcastLen;

    // FIX: Checksum only includes DATA bytes, NOT header (matches standalone)
    uint8_t checksum = 0;
    for (size_t i = 0; i < broadcastLen; i++) {
        frame[idx++] = broadcastBuffer[i];
        checksum ^= broadcastBuffer[i];
    }
    frame[idx++] = checksum;

    // FIX: Send entire frame in ONE transmission (matches standalone)
    // Split transmission was causing sync issues
    txContext = TxContext::BROADCAST;
    txWithEchoPrevention(frame, idx);

    statBroadcasts++;
    statBytesOut += idx;
}

// ============================================================================
// POLL FUNCTIONS
// ============================================================================

static void sendPoll(uint8_t addr) {
    // RS485 poll frame: [Addr][MsgType=0][Length=0] - NO CHECKSUM when Length=0!
    uint8_t frame[3] = { addr, MSGTYPE_DCSBIOS, 0 };

    currentPollAddr = addr;
    txContext = TxContext::POLL;
    txWithEchoPrevention(frame, 3);
    // TX_DONE handler will set rxStartTime and state = RX_WAIT_DATALENGTH
    // This matches AVR exactly: rx_start_time is set in TXC ISR, not before

    statPolls++;
}

// Send 0x00 byte for timeout (maintains bus sync)
static void sendTimeoutZero() {
    uint8_t zero = 0x00;
    txContext = TxContext::TIMEOUT;
    txWithEchoPrevention(&zero, 1);
}

// ============================================================================
// RESPONSE PROCESSING
// ============================================================================

static void processInputCommand(const uint8_t* data, size_t len) {
    if (len == 0) return;

    // Response may contain multiple newline-delimited commands:
    //   "MASTER_ARM_SW 1\nFLAP_SW 2\n"
    // Split on '\n' and process each command individually.
    char cmdBuf[RS485_INPUT_BUFFER_SIZE];
    size_t cmdLen = (len >= sizeof(cmdBuf)) ? sizeof(cmdBuf) - 1 : len;
    memcpy(cmdBuf, data, cmdLen);
    cmdBuf[cmdLen] = '\0';

    char* cursor = cmdBuf;
    for (int cmdLimit = 0; cmdLimit < 16 && *cursor; cmdLimit++) {
        // Skip leading whitespace/newlines
        while (*cursor == '\n' || *cursor == '\r' || *cursor == ' ') cursor++;
        if (*cursor == '\0') break;

        // Find end of this command (next newline or end of string)
        char* eol = cursor;
        while (*eol && *eol != '\n' && *eol != '\r') eol++;
        char saved = *eol;
        *eol = '\0';

        // Parse "LABEL VALUE" from this single command
        char* space = strchr(cursor, ' ');
        if (space) {
            *space = '\0';
            const char* label = cursor;
            const char* value = space + 1;

            #if RS485_DEBUG_VERBOSE
            debugPrintf("[RS485M] CMD: %s = %s (slave %d)\n", label, value, currentPollAddr);
            #endif

            statInputCmds++;

            #if RS485_USE_TASK
            queueSlaveCommand(label, value);
            #else
            sendCommand(label, value, false);
            #endif
        }

        // Advance past this command
        if (saved == '\0') break;  // Was end of string
        cursor = eol + 1;
    }
}

// Process completed message from messageBuffer (called from main loop)
static void processCompletedMessage() {
    if (!messageBuffer.complete) return;

    statResponses++;

    // Drain message data and process as command
    if (messageBuffer.isNotEmpty()) {
        uint8_t cmdData[RS485_INPUT_BUFFER_SIZE];
        size_t cmdLen = 0;

        while (messageBuffer.isNotEmpty() && cmdLen < RS485_INPUT_BUFFER_SIZE) {
            cmdData[cmdLen++] = messageBuffer.get();
        }

        if (cmdLen > 0) {
            processInputCommand(cmdData, cmdLen);
        }
    }

    messageBuffer.clear();
}

// Check for RX timeout during poll wait
// FIX: Two-tier timeout logic matching standalone exactly
static void checkRxTimeout() {
    if (state == MasterState::IDLE || state == MasterState::TX_WAITING_DONE) return;

    int64_t now = esp_timer_get_time();
    int64_t elapsed = now - rxStartTime;

    // Timeout waiting for first response byte (1ms) - mark slave as not present
    if (state == MasterState::RX_WAIT_DATALENGTH) {
        if (elapsed > RS485_POLL_TIMEOUT_US) {
            slavePresent[currentPollAddr] = false;  // FIX: Mark slave offline
            sendTimeoutZero();
            // state is now TX_WAITING_DONE — TX_DONE handler will set IDLE
            statTimeouts++;
        }
        return;
    }

    // Timeout mid-message (5ms) - inject \n marker and set complete
    // Matches AVR MasterPCConnection::checkTimeout() and standalone behavior:
    // Injecting '\n' keeps the DCS-BIOS serial parser aligned and flushes the message path
    if (state == MasterState::RX_WAIT_MSGTYPE ||
        state == MasterState::RX_WAIT_DATA ||
        state == MasterState::RX_WAIT_CHECKSUM) {
        if (elapsed > RS485_RX_TIMEOUT_US) {
            messageBuffer.clear();
            messageBuffer.put('\n');
            messageBuffer.complete = true;
            messageCompleteTime = esp_timer_get_time();
            state = MasterState::IDLE;
            statTimeouts++;

            // Flush any remaining bytes from RX and re-enable RX interrupts
            flushRxFifo();
            enableRxInt();
        }
    }
}

// ============================================================================
// SLAVE DISCOVERY & POLLING LOGIC
// ============================================================================

static uint8_t advancePollAddress() {
    uint8_t startAddr = currentPollAddr;

    // Periodically scan for new slaves
    discoveryCounter++;
    if (discoveryCounter >= RS485_DISCOVERY_INTERVAL) {
        discoveryCounter = 0;

        // Find next unknown address to probe
        // Use local variable to avoid side-effect on currentPollAddr
        // (matches standalone's separate scanAddressCounter pattern)
        uint8_t probeAddr = currentPollAddr;
        for (uint8_t i = 1; i <= RS485_MAX_SLAVE_ADDRESS; i++) {
            probeAddr = (probeAddr % RS485_MAX_SLAVE_ADDRESS) + 1;
            if (!slavePresent[probeAddr]) {
                return probeAddr;
            }
        }
    }

    // Find next known slave
    for (uint8_t i = 0; i < RS485_MAX_SLAVE_ADDRESS; i++) {
        currentPollAddr++;
        if (currentPollAddr > RS485_MAX_SLAVE_ADDRESS) {
            currentPollAddr = 1;
        }
        if (slavePresent[currentPollAddr]) {
            return currentPollAddr;
        }
    }

    // No known slaves - scan sequentially
    currentPollAddr = startAddr + 1;
    if (currentPollAddr > RS485_MAX_SLAVE_ADDRESS) {
        currentPollAddr = 1;
    }
    return currentPollAddr;
}

// ============================================================================
// PUBLIC API
// ============================================================================

bool RS485Master_init() {
    if (initialized) return true;

    // Initialize state
    memset((void*)slavePresent, 0, sizeof(slavePresent));
    messageBuffer.clear();
    state = MasterState::IDLE;
    currentPollAddr = 1;

    #if RS485_SMART_MODE
        changeHead = changeTail = changeCount = 0;
        parseState = PARSE_WAIT_SYNC;
        syncByteCount = 0;
        #if RS485_CHANGE_DETECT
        initPrevValues();
        #endif
    #else
        rawHead = rawTail = 0;
    #endif

    // Configure DE pin first (before UART)
    #if RS485_DE_PIN >= 0
    gpio_config_t de_conf = {
        .pin_bit_mask = (1ULL << RS485_DE_PIN),
        .mode = GPIO_MODE_OUTPUT,
        .pull_up_en = GPIO_PULLUP_DISABLE,
        .pull_down_en = GPIO_PULLDOWN_DISABLE,
        .intr_type = GPIO_INTR_DISABLE
    };
    gpio_config(&de_conf);
    deDeassert();  // Start in RX mode
    #endif

    // Enable UART peripheral
    periph_module_enable(RS485_UART_PERIPH);

    // Configure UART using the SAME approach as working DCS-BIOS library
    uart_config_t uart_config = {
        .baud_rate = RS485_BAUD,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .rx_flow_ctrl_thresh = 0,
        .source_clk = UART_SCLK_DEFAULT
    };
    uart_param_config((uart_port_t)RS485_UART_NUM, &uart_config);

    // Configure UART pins
    uart_set_pin((uart_port_t)RS485_UART_NUM, RS485_TX_PIN, RS485_RX_PIN,
                 UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);

    // Ensure RX pin has pullup for stable idle state
    gpio_set_pull_mode((gpio_num_t)RS485_RX_PIN, GPIO_PULLUP_ONLY);

    // Trigger interrupt on every byte for lowest latency
    uart_ll_set_rxfifo_full_thr(RS485_UART_DEV, 1);
    // Safety net: RXFIFO_TOUT catches bytes that arrive between FIFO drain
    // and ISR return (RISC-V FIFO pointer race). 10 bit-periods = ~400us at
    // 250kbps — well below protocol timeouts.
    uart_ll_set_rx_tout(RS485_UART_DEV, 10);

    // Clear and enable interrupts
    uart_ll_clr_intsts_mask(RS485_UART_DEV, UART_LL_INTR_MASK);
    uart_ll_ena_intr_mask(RS485_UART_DEV, UART_INTR_RXFIFO_FULL | UART_INTR_RXFIFO_TOUT);

    // Install RX interrupt
    esp_intr_alloc(RS485_UART_INTR_SRC,
                   ESP_INTR_FLAG_IRAM | ESP_INTR_FLAG_LEVEL1,
                   rxISR, nullptr, &intrHandle);

    initialized = true;

    debugPrintf("[RS485M] Init OK (v2.3 TX_DONE): %d baud, TX=%d, RX=%d, DE=%d\n",
                RS485_BAUD, RS485_TX_PIN, RS485_RX_PIN, RS485_DE_PIN);
    debugPrintln("[RS485M] TX: Non-blocking (FIFO burst + TX_DONE interrupt)");

    debugPrintf("[RS485M] ISR registered on core %d\n", xPortGetCoreID());

    #if RS485_SMART_MODE
        #if RS485_CHANGE_DETECT
        debugPrintln("[RS485M] Mode: SMART (filtered + change detection)");
        #else
        debugPrintln("[RS485M] Mode: SMART (filtered, no delta)");
        #endif
    #else
        debugPrintln("[RS485M] Mode: RELAY (raw bytes, Arduino-compatible)");
    #endif

    // Create FreeRTOS task if enabled
    #if RS485_USE_TASK
    // Create command queue for slave commands
    cmdQueue = xQueueCreate(RS485_CMD_QUEUE_SIZE, sizeof(SlaveCommand));
    if (!cmdQueue) {
        debugPrintln("[RS485M] ERROR: Failed to create command queue!");
        return false;
    }

    // Create the RS485 task
    taskRunning = true;

    #if defined(CONFIG_IDF_TARGET_ESP32S2) || defined(CONFIG_IDF_TARGET_ESP32C3) || \
        defined(CONFIG_IDF_TARGET_ESP32C6) || defined(CONFIG_IDF_TARGET_ESP32H2)
    // Single-core chips - use xTaskCreate (no core affinity)
    BaseType_t result = xTaskCreate(
        rs485Task,
        "RS485M",
        RS485_TASK_STACK_SIZE,
        nullptr,
        RS485_TASK_PRIORITY,
        &rs485TaskHandle
    );
    #else
    // Dual-core chips - pin to specified core
    BaseType_t result = xTaskCreatePinnedToCore(
        rs485Task,
        "RS485M",
        RS485_TASK_STACK_SIZE,
        nullptr,
        RS485_TASK_PRIORITY,
        &rs485TaskHandle,
        RS485_TASK_CORE
    );
    #endif

    if (result != pdPASS) {
        debugPrintln("[RS485M] ERROR: Failed to create task!");
        taskRunning = false;
        return false;
    }

    debugPrintf("[RS485M] Task created: priority=%d, stack=%d\n",
                RS485_TASK_PRIORITY, RS485_TASK_STACK_SIZE);
    #else
    debugPrintln("[RS485M] Running in main loop mode");
    #endif

    return true;
}

// ============================================================================
// INTERNAL POLL LOOP (called from task or main loop)
// ============================================================================

static void rs485PollLoop() {
    if (!initialized) return;

    // V2.2 IMPROVEMENT: Immediate forwarding - check for completed messages FIRST
    // This reduces latency by forwarding slave responses immediately after detection
    if (messageBuffer.complete) {
        processCompletedMessage();
    }

    // Safety: if message wasn't drained after processing, force-clear on timeout
    // Matches AVR's MasterPCConnection::checkTimeout() pattern (5ms safety valve)
    if (messageBuffer.complete) {
        int64_t now = esp_timer_get_time();
        if ((now - messageCompleteTime) > RS485_MSG_DRAIN_TIMEOUT_US) {
            messageBuffer.clear();
            messageBuffer.complete = false;
            statTimeouts++;
        }
    }

    // Check for RX timeout during non-IDLE states
    checkRxTimeout();

    // Only start new poll/broadcast when IDLE
    if (state == MasterState::IDLE) {
        int64_t now = esp_timer_get_time();

        // Check if we should broadcast
        #if RS485_SMART_MODE
        bool hasBroadcastData = (changeCount > 0);
        #else
        bool hasBroadcastData = !rawEmpty();
        #endif

        // FIX: Match standalone priority logic exactly
        // Priority 1: Send broadcast if available, but ensure we poll at least every MAX_POLL_INTERVAL
        if (hasBroadcastData && (now - lastPollUs) < RS485_MAX_POLL_INTERVAL_US) {
            sendBroadcast();
            return;  // Don't poll this iteration
        }

        // Priority 2: Poll a slave if message buffer is free (matches standalone)
        if (messageBuffer.isEmpty() && !messageBuffer.complete) {
            uint8_t nextAddr = advancePollAddress();
            sendPoll(nextAddr);
            lastPollUs = now;
        }
    }

    // Periodic status
    #if RS485_STATUS_INTERVAL_MS > 0
    static uint32_t lastStatusMs = 0;
    if (millis() - lastStatusMs >= RS485_STATUS_INTERVAL_MS) {
        lastStatusMs = millis();

        uint8_t onlineCount = 0;
        for (uint8_t i = 1; i <= RS485_MAX_SLAVE_ADDRESS; i++) {
            if (slavePresent[i]) onlineCount++;
        }

        float respRate = statPolls > 0 ? 100.0f * statResponses / statPolls : 0;

        #if RS485_SMART_MODE
        debugPrintf("[RS485M] Polls=%lu Resp=%.1f%% Bcasts=%lu Cmds=%lu Slaves=%d Queue=%d Drops=%lu Tout=%lu\n",
                    statPolls, respRate, statBroadcasts, statInputCmds, onlineCount, changeCount, messageBuffer.dropCount, statTimeouts);
        #else
        debugPrintf("[RS485M] Polls=%lu Resp=%.1f%% Bcasts=%lu Cmds=%lu Slaves=%d Raw=%d Drops=%lu Tout=%lu\n",
                    statPolls, respRate, statBroadcasts, statInputCmds, onlineCount, rawCount(), messageBuffer.dropCount, statTimeouts);
        #endif
    }
    #endif
}

// ============================================================================
// PUBLIC LOOP FUNCTION
// ============================================================================

void RS485Master_loop() {
    #if RS485_USE_TASK
    // Task mode: just process queued commands from slaves
    processQueuedCommands();
    #else
    // Main loop mode: run the poll loop directly
    rs485PollLoop();
    #endif
}

void RS485Master_feedExportData(const uint8_t* data, size_t len) {
    if (!initialized) return;

    #if RS485_SMART_MODE
    // Parse and queue changes
    for (size_t i = 0; i < len; i++) {
        parseExportByte(data[i]);
    }
    #else
    // Buffer raw bytes
    for (size_t i = 0; i < len; i++) {
        bufferRawByte(data[i]);
    }
    #endif
}

void RS485Master_forceFullSync() {
    #if RS485_SMART_MODE
        #if RS485_CHANGE_DETECT
        initPrevValues();
        #endif
        changeHead = changeTail = changeCount = 0;
    #else
        rawHead = rawTail = 0;
    #endif
    debugPrintln("[RS485M] Forced full sync");
}

bool RS485Master_isSlaveOnline(uint8_t addr) {
    if (addr < 1 || addr > 127) return false;
    return slavePresent[addr];
}

uint8_t RS485Master_getOnlineSlaveCount() {
    uint8_t count = 0;
    for (uint8_t i = 1; i <= RS485_MAX_SLAVE_ADDRESS; i++) {
        if (slavePresent[i]) count++;
    }
    return count;
}

void RS485Master_printStatus() {
    debugPrintln("\n[RS485M] ========== STATUS ==========");

    #if RS485_SMART_MODE
        #if RS485_CHANGE_DETECT
        debugPrintln("[RS485M] Mode: SMART (filtered + change detection)");
        #else
        debugPrintln("[RS485M] Mode: SMART (filtered, no delta)");
        #endif
        debugPrintf("[RS485M] Change queue: %d/%d\n", changeCount, RS485_CHANGE_QUEUE_SIZE);
    #else
        debugPrintln("[RS485M] Mode: RELAY (raw bytes)");
        debugPrintf("[RS485M] Raw buffer: %d/%d\n", rawCount(), RS485_RAW_BUFFER_SIZE);
    #endif

    debugPrint("[RS485M] Online slaves: ");
    bool first = true;
    for (uint8_t i = 1; i <= RS485_MAX_SLAVE_ADDRESS; i++) {
        if (slavePresent[i]) {
            if (!first) debugPrint(", ");
            debugPrintf("%d", i);
            first = false;
        }
    }
    if (first) debugPrint("(none)");
    debugPrintln("");

    float respRate = statPolls > 0 ? 100.0f * statResponses / statPolls : 0;
    debugPrintf("[RS485M] Polls: %lu, Responses: %lu (%.1f%%)\n", statPolls, statResponses, respRate);
    debugPrintf("[RS485M] Timeouts: %lu\n", statTimeouts);
    debugPrintf("[RS485M] Broadcasts: %lu, Bytes out: %lu\n", statBroadcasts, statBytesOut);
    debugPrintf("[RS485M] Input commands: %lu\n", statInputCmds);
    #if RS485_USE_TASK
    debugPrintf("[RS485M] Execution: FreeRTOS task (priority %d)\n", RS485_TASK_PRIORITY);
    #else
    debugPrintln("[RS485M] Execution: Main loop");
    #endif
    debugPrintln("[RS485M] ================================\n");
}

void RS485Master_stop() {
    #if RS485_USE_TASK
    if (taskRunning && rs485TaskHandle) {
        taskRunning = false;
        // Wait for task to finish
        vTaskDelay(pdMS_TO_TICKS(100));

        // Delete queue
        if (cmdQueue) {
            vQueueDelete(cmdQueue);
            cmdQueue = nullptr;
        }

        rs485TaskHandle = nullptr;
        debugPrintln("[RS485M] Task stopped");
    }
    #endif

    // Disable UART interrupt
    if (intrHandle) {
        esp_intr_free(intrHandle);
        intrHandle = nullptr;
    }

    initialized = false;
    debugPrintln("[RS485M] Stopped");
}

#endif // RS485_MASTER_ENABLED
