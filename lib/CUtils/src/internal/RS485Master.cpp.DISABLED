/**
 * @file RS485Master.cpp
 * @brief RS-485 Master Driver for CockpitOS - Complete Rewrite v2.0
 *
 * ARCHITECTURE:
 *   - Bare-metal UART using uart_ll_* for direct hardware access
 *   - ISR-driven RX with FIFO threshold of 1 for minimum latency
 *   - Echo prevention via RX interrupt disable during TX
 *   - RISC-V memory barriers for ESP32-C3/C6 cache coherency
 *   - Zero blocking calls in the hot path
 *   - Smart mode with DcsOutputTable filtering and change detection
 *   - Relay mode for Arduino-compatible raw byte pumping
 *
 * PROTOCOL: 100% compatible with Arduino DCS-BIOS RS485 implementation
 *
 * ==========================================================================
 */

#if RS485_MASTER_ENABLED

#include "../RS485Config.h"

// ESP-IDF includes
#include "esp_attr.h"
#include "esp_intr_alloc.h"
#include "driver/periph_ctrl.h"
#include "driver/uart.h"
#include "driver/gpio.h"
#include "hal/uart_ll.h"
#include "soc/uart_periph.h"

// RISC-V fence for C3/C6 cache coherency
#if CONFIG_IDF_TARGET_ESP32C3 || CONFIG_IDF_TARGET_ESP32C6 || CONFIG_IDF_TARGET_ESP32H2
    #define RS485_RISCV_FENCE() __asm__ __volatile__("fence" ::: "memory")
#else
    #define RS485_RISCV_FENCE() do {} while(0)
#endif

// ============================================================================
// HARDWARE ABSTRACTION
// ============================================================================

// Map UART number to hardware
#if RS485_UART_NUM == 0
    #define RS485_UART_DEV      UART_LL_GET_HW(0)
    #define RS485_UART_PERIPH   PERIPH_UART0_MODULE
    #define RS485_UART_SIGNAL   U0TXD_OUT_IDX
    #define RS485_UART_RX_SIG   U0RXD_IN_IDX
    #define RS485_UART_INTR_SRC ETS_UART0_INTR_SOURCE
#elif RS485_UART_NUM == 1
    #define RS485_UART_DEV      UART_LL_GET_HW(1)
    #define RS485_UART_PERIPH   PERIPH_UART1_MODULE
    #define RS485_UART_SIGNAL   U1TXD_OUT_IDX
    #define RS485_UART_RX_SIG   U1RXD_IN_IDX
    #define RS485_UART_INTR_SRC ETS_UART1_INTR_SOURCE
#else
    #define RS485_UART_DEV      UART_LL_GET_HW(2)
    #define RS485_UART_PERIPH   PERIPH_UART2_MODULE
    #define RS485_UART_SIGNAL   U2TXD_OUT_IDX
    #define RS485_UART_RX_SIG   U2RXD_IN_IDX
    #define RS485_UART_INTR_SRC ETS_UART2_INTR_SOURCE
#endif

// ============================================================================
// PROTOCOL CONSTANTS
// ============================================================================

static constexpr uint8_t ADDR_BROADCAST = 0;
static constexpr uint8_t MSGTYPE_DCSBIOS = 0;
static constexpr uint8_t CHECKSUM_PLACEHOLDER = 0x72;

// ============================================================================
// STATE MACHINE
// ============================================================================

enum class MasterState : uint8_t {
    IDLE,
    WAIT_RESPONSE,
    PROCESS_RESPONSE
};

// ============================================================================
// RX RING BUFFER (ISR-safe)
// ============================================================================

static volatile uint8_t rxBuffer[RS485_RX_BUFFER_SIZE];
static volatile uint16_t rxHead = 0;
static volatile uint16_t rxTail = 0;

static inline bool rxEmpty() { return rxHead == rxTail; }
static inline uint16_t rxCount() { return (uint16_t)(rxHead - rxTail); }

static inline uint8_t rxGet() {
    uint8_t c = rxBuffer[rxTail % RS485_RX_BUFFER_SIZE];
    rxTail++;
    return c;
}

static inline void rxClear() { rxTail = rxHead; }

// ============================================================================
// SMART MODE: CHANGE TRACKING (only when RS485_SMART_MODE=1)
// ============================================================================

#if RS485_SMART_MODE

// DCS-BIOS export stream parser state
enum ParseState : uint8_t {
    PARSE_WAIT_SYNC,
    PARSE_ADDRESS_LOW,
    PARSE_ADDRESS_HIGH,
    PARSE_COUNT_LOW,
    PARSE_COUNT_HIGH,
    PARSE_DATA_LOW,
    PARSE_DATA_HIGH
};

static ParseState parseState = PARSE_WAIT_SYNC;
static uint8_t syncByteCount = 0;
static uint16_t parseAddress = 0;
static uint16_t parseCount = 0;
static uint16_t parseData = 0;

// Change tracking for delta compression
#if RS485_CHANGE_DETECT
static uint16_t prevExport[0x4000];  // 32KB for address range 0x0000-0x7FFF
static bool prevInitialized = false;
#endif

// Change queue
struct Change { uint16_t address; uint16_t value; };
static Change changeQueue[RS485_CHANGE_QUEUE_SIZE];
static volatile uint8_t changeHead = 0;
static volatile uint8_t changeTail = 0;
static volatile uint8_t changeCount = 0;

// Forward declaration for DcsOutputTable lookup (from DCSBIOSBridgeData.h)
struct AddressEntry;  // Forward declare the struct
extern const AddressEntry* findDcsOutputEntries(uint16_t addr);

static void initPrevValues() {
    #if RS485_CHANGE_DETECT
    for (size_t i = 0; i < 0x4000; ++i) {
        prevExport[i] = 0xFFFFu;
    }
    prevInitialized = true;
    #endif
}

static void queueChange(uint16_t address, uint16_t value) {
    if (changeCount >= RS485_CHANGE_QUEUE_SIZE) {
        // Queue full - drop oldest
        changeTail = (changeTail + 1) % RS485_CHANGE_QUEUE_SIZE;
        changeCount--;
    }
    changeQueue[changeHead].address = address;
    changeQueue[changeHead].value = value;
    changeHead = (changeHead + 1) % RS485_CHANGE_QUEUE_SIZE;
    changeCount++;
}

static void processAddressValue(uint16_t address, uint16_t value) {
    if (address >= 0x8000) return;  // Invalid address range

    // Filter by DcsOutputTable (CockpitOS label set)
    if (findDcsOutputEntries(address) == nullptr) {
        return;  // Not needed by any slave
    }

    #if RS485_CHANGE_DETECT
    uint16_t index = address >> 1;
    if (prevExport[index] == value) return;  // No change
    prevExport[index] = value;
    #endif

    queueChange(address, value);
}

static void parseExportByte(uint8_t c) {
    // Sync detection runs in parallel with parsing
    if (c == 0x55) {
        syncByteCount++;
    } else {
        syncByteCount = 0;
    }

    if (syncByteCount >= 4) {
        parseState = PARSE_ADDRESS_LOW;
        syncByteCount = 0;
        return;
    }

    switch (parseState) {
        case PARSE_WAIT_SYNC:
            break;
        case PARSE_ADDRESS_LOW:
            parseAddress = c;
            parseState = PARSE_ADDRESS_HIGH;
            break;
        case PARSE_ADDRESS_HIGH:
            parseAddress |= ((uint16_t)c << 8);
            parseState = (parseAddress != 0x5555) ? PARSE_COUNT_LOW : PARSE_WAIT_SYNC;
            break;
        case PARSE_COUNT_LOW:
            parseCount = c;
            parseState = PARSE_COUNT_HIGH;
            break;
        case PARSE_COUNT_HIGH:
            parseCount |= ((uint16_t)c << 8);
            parseState = PARSE_DATA_LOW;
            break;
        case PARSE_DATA_LOW:
            parseData = c;
            parseCount--;
            parseState = PARSE_DATA_HIGH;
            break;
        case PARSE_DATA_HIGH:
            parseData |= ((uint16_t)c << 8);
            parseCount--;
            processAddressValue(parseAddress, parseData);
            parseAddress += 2;
            parseState = (parseCount == 0) ? PARSE_ADDRESS_LOW : PARSE_DATA_LOW;
            break;
    }
}

#else
// ============================================================================
// RELAY MODE: RAW BYTE BUFFER (only when RS485_SMART_MODE=0)
// ============================================================================

static uint8_t rawBuffer[RS485_RAW_BUFFER_SIZE];
static volatile uint16_t rawHead = 0;
static volatile uint16_t rawTail = 0;

static inline uint16_t rawCount() { return (uint16_t)(rawHead - rawTail); }
static inline bool rawEmpty() { return rawHead == rawTail; }

static void bufferRawByte(uint8_t byte) {
    if (rawCount() >= RS485_RAW_BUFFER_SIZE - 1) {
        // Overflow - discard oldest
        rawTail++;
    }
    rawBuffer[rawHead % RS485_RAW_BUFFER_SIZE] = byte;
    rawHead++;
}

#endif // RS485_SMART_MODE

// ============================================================================
// STATE VARIABLES
// ============================================================================

static MasterState state = MasterState::IDLE;
static intr_handle_t intrHandle = nullptr;
static bool initialized = false;

// Slave tracking
static bool slavePresent[128];  // Which slaves have responded
static uint8_t currentPollAddr = 1;
static uint8_t discoveryCounter = 0;

// Timing
static uint32_t pollStartUs = 0;
static uint32_t lastPollUs = 0;

// Response parsing
static uint8_t responseBuffer[RS485_INPUT_BUFFER_SIZE];
static uint8_t responseLen = 0;
static uint8_t responseExpected = 0;
static uint8_t responseMsgType = 0;
static uint8_t responseState = 0;  // 0=wait_len, 1=wait_msgtype, 2=wait_data, 3=wait_checksum

// Broadcast buffer
static uint8_t broadcastBuffer[256];
static size_t broadcastLen = 0;

// Statistics
static uint32_t statPolls = 0;
static uint32_t statResponses = 0;
static uint32_t statTimeouts = 0;
static uint32_t statBroadcasts = 0;
static uint32_t statInputCmds = 0;
static uint32_t statBytesOut = 0;

// ============================================================================
// RX INTERRUPT SERVICE ROUTINE
// ============================================================================

static void IRAM_ATTR rxISR(void* arg) {
    (void)arg;

    while (uart_ll_get_rxfifo_len(RS485_UART_DEV) > 0) {
        uint8_t c;
        uart_ll_read_rxfifo(RS485_UART_DEV, &c, 1);
        RS485_RISCV_FENCE();

        // Store in ring buffer
        rxBuffer[rxHead % RS485_RX_BUFFER_SIZE] = c;
        rxHead++;
    }

    // Clear interrupt
    uart_ll_clr_intsts_mask(RS485_UART_DEV, UART_INTR_RXFIFO_FULL | UART_INTR_RXFIFO_TOUT);
}

// ============================================================================
// UART HELPERS
// ============================================================================

static inline void deAssert() {
    #if RS485_DE_PIN >= 0
    GPIO.out_w1ts = (1UL << RS485_DE_PIN);
    #endif
}

static inline void deDeassert() {
    #if RS485_DE_PIN >= 0
    GPIO.out_w1tc = (1UL << RS485_DE_PIN);
    #endif
}

static inline void disableRxInt() {
    uart_ll_disable_intr_mask(RS485_UART_DEV, UART_INTR_RXFIFO_FULL | UART_INTR_RXFIFO_TOUT);
}

static inline void enableRxInt() {
    uart_ll_clr_intsts_mask(RS485_UART_DEV, UART_INTR_RXFIFO_FULL | UART_INTR_RXFIFO_TOUT);
    uart_ll_ena_intr_mask(RS485_UART_DEV, UART_INTR_RXFIFO_FULL | UART_INTR_RXFIFO_TOUT);
}

static inline void flushRxFifo() {
    uart_ll_rxfifo_rst(RS485_UART_DEV);
    rxClear();
}

static inline bool txIdle() {
    return uart_ll_is_tx_idle(RS485_UART_DEV);
}

static void txByte(uint8_t c) {
    while (uart_ll_get_txfifo_len(RS485_UART_DEV) == 0) {}
    uart_ll_write_txfifo(RS485_UART_DEV, &c, 1);
}

static void txBytes(const uint8_t* data, size_t len) {
    for (size_t i = 0; i < len; i++) {
        txByte(data[i]);
    }
}

// Transmit with echo prevention
static void txWithEchoPrevention(const uint8_t* data, size_t len) {
    disableRxInt();
    deAssert();

    txBytes(data, len);

    // Wait for TX to complete
    while (!txIdle()) {}

    deDeassert();
    flushRxFifo();
    enableRxInt();
}

// ============================================================================
// BROADCAST FUNCTIONS
// ============================================================================

#if RS485_SMART_MODE
// SMART MODE: Build DCS-BIOS frames from change queue
static void prepareBroadcastData() {
    broadcastLen = 0;

    while (changeCount > 0 && broadcastLen < (256 - 12)) {
        Change& change = changeQueue[changeTail];

        // Build complete DCS-BIOS frame for this change
        broadcastBuffer[broadcastLen++] = 0x55;
        broadcastBuffer[broadcastLen++] = 0x55;
        broadcastBuffer[broadcastLen++] = 0x55;
        broadcastBuffer[broadcastLen++] = 0x55;
        broadcastBuffer[broadcastLen++] = change.address & 0xFF;
        broadcastBuffer[broadcastLen++] = (change.address >> 8) & 0xFF;
        broadcastBuffer[broadcastLen++] = 0x02;  // Count low
        broadcastBuffer[broadcastLen++] = 0x00;  // Count high
        broadcastBuffer[broadcastLen++] = change.value & 0xFF;
        broadcastBuffer[broadcastLen++] = (change.value >> 8) & 0xFF;

        changeTail = (changeTail + 1) % RS485_CHANGE_QUEUE_SIZE;
        changeCount--;
    }
}
#else
// RELAY MODE: Drain raw bytes
static void prepareBroadcastData() {
    broadcastLen = 0;

    uint16_t available = rawCount();
    if (available == 0) return;

    size_t toSend = (available > RS485_RELAY_CHUNK_SIZE) ? RS485_RELAY_CHUNK_SIZE : available;

    for (size_t i = 0; i < toSend; i++) {
        broadcastBuffer[broadcastLen++] = rawBuffer[rawTail % RS485_RAW_BUFFER_SIZE];
        rawTail++;
    }
}
#endif

static void sendBroadcast() {
    prepareBroadcastData();

    if (broadcastLen == 0) return;

    // Build RS485 frame: [Addr=0][MsgType=0][Length][Data...][Checksum]
    uint8_t frame[4];
    frame[0] = ADDR_BROADCAST;
    frame[1] = MSGTYPE_DCSBIOS;
    frame[2] = (uint8_t)broadcastLen;

    // Calculate checksum
    uint8_t checksum = frame[0] ^ frame[1] ^ frame[2];
    for (size_t i = 0; i < broadcastLen; i++) {
        checksum ^= broadcastBuffer[i];
    }

    // Transmit header
    txWithEchoPrevention(frame, 3);

    // Transmit data + checksum
    disableRxInt();
    deAssert();
    txBytes(broadcastBuffer, broadcastLen);
    txByte(checksum);
    while (!txIdle()) {}
    deDeassert();
    flushRxFifo();
    enableRxInt();

    statBroadcasts++;
    statBytesOut += 4 + broadcastLen;
}

// ============================================================================
// POLL FUNCTIONS
// ============================================================================

static void sendPoll(uint8_t addr) {
    // RS485 poll frame: [Addr][MsgType=0][Length=0] - NO CHECKSUM when Length=0!
    uint8_t frame[3] = { addr, MSGTYPE_DCSBIOS, 0 };

    txWithEchoPrevention(frame, 3);

    pollStartUs = micros();
    responseState = 0;
    responseLen = 0;
    responseExpected = 0;
    state = MasterState::WAIT_RESPONSE;

    statPolls++;
}

// Send 0x00 byte for timeout (maintains bus sync)
static void sendTimeoutZero() {
    uint8_t zero = 0x00;
    txWithEchoPrevention(&zero, 1);
}

// ============================================================================
// RESPONSE PROCESSING
// ============================================================================

static void processInputCommand(const uint8_t* data, size_t len) {
    if (len == 0) return;

    // Parse "LABEL VALUE\n" format
    char cmdBuf[64];
    size_t cmdLen = (len >= sizeof(cmdBuf)) ? sizeof(cmdBuf) - 1 : len;
    memcpy(cmdBuf, data, cmdLen);
    cmdBuf[cmdLen] = '\0';

    // Trim trailing newlines
    while (cmdLen > 0 && (cmdBuf[cmdLen-1] == '\n' || cmdBuf[cmdLen-1] == '\r')) {
        cmdBuf[--cmdLen] = '\0';
    }

    char* space = strchr(cmdBuf, ' ');
    if (!space) return;  // Malformed

    *space = '\0';
    const char* label = cmdBuf;
    const char* value = space + 1;

    #if RS485_DEBUG_VERBOSE
    debugPrintf("[RS485M] CMD: %s = %s (slave %d)\n", label, value, currentPollAddr);
    #endif

    statInputCmds++;

    // Send to CockpitOS
    sendCommand(label, value, false);
}

static void processResponse() {
    // Process any RX data
    while (!rxEmpty()) {
        uint8_t c = rxGet();

        switch (responseState) {
            case 0:  // Wait for Length byte
                if (c == 0x00) {
                    // Empty response - slave has no data
                    statResponses++;
                    slavePresent[currentPollAddr] = true;
                    state = MasterState::IDLE;
                    return;
                }
                responseExpected = c;
                responseLen = 0;
                responseState = 1;
                break;

            case 1:  // Wait for MsgType
                responseMsgType = c;
                if (responseExpected > 0) {
                    responseState = 2;
                } else {
                    responseState = 3;
                }
                break;

            case 2:  // Receive data
                if (responseLen < RS485_INPUT_BUFFER_SIZE) {
                    responseBuffer[responseLen] = c;
                }
                responseLen++;
                if (responseLen >= responseExpected) {
                    responseState = 3;
                }
                break;

            case 3:  // Checksum
                // Accept any checksum (Arduino uses 0x72, others use XOR)
                statResponses++;
                slavePresent[currentPollAddr] = true;

                if (responseLen > 0 && responseMsgType == 0) {
                    processInputCommand(responseBuffer, responseLen);
                }

                state = MasterState::IDLE;
                return;
        }
    }

    // Check timeout
    uint32_t elapsed = micros() - pollStartUs;
    if (elapsed > RS485_POLL_TIMEOUT_US) {
        sendTimeoutZero();
        statTimeouts++;
        state = MasterState::IDLE;
    }
}

// ============================================================================
// SLAVE DISCOVERY & POLLING LOGIC
// ============================================================================

static uint8_t advancePollAddress() {
    uint8_t startAddr = currentPollAddr;

    // Periodically scan for new slaves
    discoveryCounter++;
    if (discoveryCounter >= RS485_DISCOVERY_INTERVAL) {
        discoveryCounter = 0;

        // Find next unknown address to probe
        for (uint8_t i = 1; i <= RS485_MAX_SLAVE_ADDRESS; i++) {
            uint8_t probeAddr = (currentPollAddr % RS485_MAX_SLAVE_ADDRESS) + 1;
            if (!slavePresent[probeAddr]) {
                return probeAddr;
            }
            currentPollAddr = probeAddr;
        }
    }

    // Find next known slave
    for (uint8_t i = 0; i < RS485_MAX_SLAVE_ADDRESS; i++) {
        currentPollAddr++;
        if (currentPollAddr > RS485_MAX_SLAVE_ADDRESS) {
            currentPollAddr = 1;
        }
        if (slavePresent[currentPollAddr]) {
            return currentPollAddr;
        }
    }

    // No known slaves - scan sequentially
    currentPollAddr = startAddr + 1;
    if (currentPollAddr > RS485_MAX_SLAVE_ADDRESS) {
        currentPollAddr = 1;
    }
    return currentPollAddr;
}

// ============================================================================
// PUBLIC API
// ============================================================================

bool RS485Master_init() {
    if (initialized) return true;

    // Initialize state
    memset((void*)slavePresent, 0, sizeof(slavePresent));
    rxHead = rxTail = 0;
    state = MasterState::IDLE;
    currentPollAddr = 1;

    #if RS485_SMART_MODE
        changeHead = changeTail = changeCount = 0;
        parseState = PARSE_WAIT_SYNC;
        syncByteCount = 0;
        #if RS485_CHANGE_DETECT
        initPrevValues();
        #endif
    #else
        rawHead = rawTail = 0;
    #endif

    // Configure DE pin first (before UART)
    #if RS485_DE_PIN >= 0
    gpio_config_t de_conf = {
        .pin_bit_mask = (1ULL << RS485_DE_PIN),
        .mode = GPIO_MODE_OUTPUT,
        .pull_up_en = GPIO_PULLUP_DISABLE,
        .pull_down_en = GPIO_PULLDOWN_DISABLE,
        .intr_type = GPIO_INTR_DISABLE
    };
    gpio_config(&de_conf);
    deDeassert();  // Start in RX mode
    #endif

    // Enable UART peripheral
    periph_module_enable(RS485_UART_PERIPH);

    // Configure UART using the SAME approach as working DCS-BIOS library
    uart_config_t uart_config = {
        .baud_rate = RS485_BAUD,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .rx_flow_ctrl_thresh = 0,
        .source_clk = UART_SCLK_DEFAULT
    };
    uart_param_config((uart_port_t)RS485_UART_NUM, &uart_config);

    // Configure UART pins
    uart_set_pin((uart_port_t)RS485_UART_NUM, RS485_TX_PIN, RS485_RX_PIN,
                 UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);

    // Ensure RX pin has pullup for stable idle state
    gpio_set_pull_mode((gpio_num_t)RS485_RX_PIN, GPIO_PULLUP_ONLY);

    // Trigger interrupt on every byte for lowest latency
    uart_ll_set_rxfifo_full_thr(RS485_UART_DEV, 1);

    // Clear and enable interrupts
    uart_ll_clr_intsts_mask(RS485_UART_DEV, UART_LL_INTR_MASK);
    uart_ll_ena_intr_mask(RS485_UART_DEV, UART_INTR_RXFIFO_FULL);

    // Install RX interrupt
    esp_intr_alloc(RS485_UART_INTR_SRC,
                   ESP_INTR_FLAG_IRAM | ESP_INTR_FLAG_LEVEL1,
                   rxISR, nullptr, &intrHandle);

    initialized = true;

    debugPrintf("[RS485M] Init OK: %d baud, TX=%d, RX=%d, DE=%d\n",
                RS485_BAUD, RS485_TX_PIN, RS485_RX_PIN, RS485_DE_PIN);

    #if RS485_SMART_MODE
        #if RS485_CHANGE_DETECT
        debugPrintln("[RS485M] Mode: SMART (filtered + change detection)");
        #else
        debugPrintln("[RS485M] Mode: SMART (filtered, no delta)");
        #endif
    #else
        debugPrintln("[RS485M] Mode: RELAY (raw bytes, Arduino-compatible)");
    #endif

    return true;
}

void RS485Master_loop() {
    if (!initialized) return;
    if (!simReady()) return;

    switch (state) {
        case MasterState::IDLE: {
            uint32_t now = micros();
            uint32_t sinceLastPoll = now - lastPollUs;

            // Check if we should broadcast
            #if RS485_SMART_MODE
            bool hasBroadcastData = (changeCount > 0);
            #else
            bool hasBroadcastData = !rawEmpty();
            #endif

            // Broadcast if we have data and enough time has passed
            if (hasBroadcastData && sinceLastPoll >= RS485_MAX_POLL_INTERVAL_US) {
                sendBroadcast();
            }

            // Always poll
            uint8_t nextAddr = advancePollAddress();
            sendPoll(nextAddr);
            lastPollUs = micros();
            break;
        }

        case MasterState::WAIT_RESPONSE:
        case MasterState::PROCESS_RESPONSE:
            processResponse();
            break;
    }

    // Periodic status
    #if RS485_STATUS_INTERVAL_MS > 0
    static uint32_t lastStatusMs = 0;
    if (millis() - lastStatusMs >= RS485_STATUS_INTERVAL_MS) {
        lastStatusMs = millis();

        uint8_t onlineCount = 0;
        for (uint8_t i = 1; i <= RS485_MAX_SLAVE_ADDRESS; i++) {
            if (slavePresent[i]) onlineCount++;
        }

        float respRate = statPolls > 0 ? 100.0f * statResponses / statPolls : 0;

        #if RS485_SMART_MODE
        debugPrintf("[RS485M] Polls=%lu Resp=%.1f%% Bcasts=%lu Cmds=%lu Slaves=%d Queue=%d\n",
                    statPolls, respRate, statBroadcasts, statInputCmds, onlineCount, changeCount);
        #else
        debugPrintf("[RS485M] Polls=%lu Resp=%.1f%% Bcasts=%lu Cmds=%lu Slaves=%d Raw=%d\n",
                    statPolls, respRate, statBroadcasts, statInputCmds, onlineCount, rawCount());
        #endif
    }
    #endif
}

void RS485Master_feedExportData(const uint8_t* data, size_t len) {
    if (!initialized) return;

    #if RS485_SMART_MODE
    // Parse and queue changes
    for (size_t i = 0; i < len; i++) {
        parseExportByte(data[i]);
    }
    #else
    // Buffer raw bytes
    for (size_t i = 0; i < len; i++) {
        bufferRawByte(data[i]);
    }
    #endif
}

void RS485Master_forceFullSync() {
    #if RS485_SMART_MODE
        #if RS485_CHANGE_DETECT
        initPrevValues();
        #endif
        changeHead = changeTail = changeCount = 0;
    #else
        rawHead = rawTail = 0;
    #endif
    debugPrintln("[RS485M] Forced full sync");
}

bool RS485Master_isSlaveOnline(uint8_t addr) {
    if (addr < 1 || addr > 127) return false;
    return slavePresent[addr];
}

uint8_t RS485Master_getOnlineSlaveCount() {
    uint8_t count = 0;
    for (uint8_t i = 1; i <= RS485_MAX_SLAVE_ADDRESS; i++) {
        if (slavePresent[i]) count++;
    }
    return count;
}

void RS485Master_printStatus() {
    debugPrintln("\n[RS485M] ========== STATUS ==========");

    #if RS485_SMART_MODE
        #if RS485_CHANGE_DETECT
        debugPrintln("[RS485M] Mode: SMART (filtered + change detection)");
        #else
        debugPrintln("[RS485M] Mode: SMART (filtered, no delta)");
        #endif
        debugPrintf("[RS485M] Change queue: %d/%d\n", changeCount, RS485_CHANGE_QUEUE_SIZE);
    #else
        debugPrintln("[RS485M] Mode: RELAY (raw bytes)");
        debugPrintf("[RS485M] Raw buffer: %d/%d\n", rawCount(), RS485_RAW_BUFFER_SIZE);
    #endif

    debugPrint("[RS485M] Online slaves: ");
    bool first = true;
    for (uint8_t i = 1; i <= RS485_MAX_SLAVE_ADDRESS; i++) {
        if (slavePresent[i]) {
            if (!first) debugPrint(", ");
            debugPrintf("%d", i);
            first = false;
        }
    }
    if (first) debugPrint("(none)");
    debugPrintln("");

    float respRate = statPolls > 0 ? 100.0f * statResponses / statPolls : 0;
    debugPrintf("[RS485M] Polls: %lu, Responses: %lu (%.1f%%)\n", statPolls, statResponses, respRate);
    debugPrintf("[RS485M] Timeouts: %lu\n", statTimeouts);
    debugPrintf("[RS485M] Broadcasts: %lu, Bytes out: %lu\n", statBroadcasts, statBytesOut);
    debugPrintf("[RS485M] Input commands: %lu\n", statInputCmds);
    debugPrintln("[RS485M] ================================\n");
}

#endif // RS485_MASTER_ENABLED
