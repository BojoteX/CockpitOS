/**
 * @file RS485Slave.cpp
 * @brief RS-485 Slave Driver for CockpitOS (CUtils internal module)
 *
 * Implements the DCS-BIOS RS-485 slave protocol, allowing an ESP32 running
 * CockpitOS to operate as a slave on an RS-485 bus alongside Arduino slaves.
 *
 * FULLY COMPATIBLE WITH:
 *   - Arduino DCS-BIOS RS485 Master (DcsBiosNgRS485Master)
 *   - CockpitOS RS485 Master (both SMART and DUMB modes)
 *   - ESP32 RS485 Master reference implementation
 *
 * Integration: Include this from CUtils.cpp via:
 *   #if RS485_SLAVE_ENABLED
 *   #include "internal/RS485Slave.cpp"
 *   #endif
 *
 * The slave:
 * - Listens for broadcast packets (address 0) with export data
 * - Listens for poll packets addressed to RS485_SLAVE_ADDRESS
 * - Feeds received export data to DcsBios::parser (same as UDP/USB)
 * - Queues input commands and sends them when polled
 *
 * Protocol Details (DCS-BIOS RS485 Standard):
 * - Baud: 250000
 * - Broadcast:   [Addr=0][MsgType=0][Length][ExportData...][Checksum]
 * - Poll:        [Addr=N][MsgType=0][Length=0]
 * - Response:    [Length][MsgType=0][InputData...][Checksum]
 * - No data response: [0x00] (single byte)
 */

#if RS485_SLAVE_ENABLED

// Mutual exclusion check
#if RS485_MASTER_ENABLED
#error "RS485_MASTER_ENABLED and RS485_SLAVE_ENABLED are mutually exclusive! Choose one."
#endif

#include <driver/uart.h>
#include "../RS485SlaveConfig.h"

// ============================================================================
// PROTOCOL CONSTANTS
// ============================================================================

static const uint8_t RS485_ADDR_BROADCAST = 0;
static const uint8_t RS485_MSGTYPE_EXPORT = 0;
static const uint8_t RS485_CHECKSUM_FIXED = 0x72;  // Arduino compatibility

// Timing constants from config (with defaults if not specified)
#ifndef RS485_SLAVE_SYNC_GAP_US
#define RS485_SLAVE_SYNC_GAP_US     500
#endif

#ifndef RS485_SLAVE_RX_TIMEOUT_US
#define RS485_SLAVE_RX_TIMEOUT_US   5000
#endif

// ============================================================================
// STATE MACHINE
// ============================================================================

enum class RS485SlaveState : uint8_t {
    // Sync states
    SYNC,                       // Waiting for bus idle gap

    // RX states - receiving from master
    RX_WAIT_ADDRESS,            // Waiting for address byte
    RX_WAIT_MSGTYPE,            // Waiting for message type byte
    RX_WAIT_LENGTH,             // Waiting for data length byte
    RX_WAIT_DATA,               // Receiving data bytes
    RX_WAIT_CHECKSUM,           // Waiting for checksum byte

    // Skip states - another slave is responding
    RX_SKIP_RESPONSE_LENGTH,    // Skip other slave's response length
    RX_SKIP_RESPONSE_MSGTYPE,   // Skip other slave's response msgtype
    RX_SKIP_RESPONSE_DATA,      // Skip other slave's response data
    RX_SKIP_RESPONSE_CHECKSUM,  // Skip other slave's response checksum

    // TX states - sending our response
    TX_SEND_LENGTH,             // Sending response length
    TX_SEND_MSGTYPE,            // Sending message type
    TX_SEND_DATA,               // Sending command data
    TX_SEND_CHECKSUM            // Sending checksum
};

static RS485SlaveState rs485s_state = RS485SlaveState::SYNC;

// ============================================================================
// RX STATE
// ============================================================================

// Current packet info
static uint8_t rs485s_rxAddress = 0;
static uint8_t rs485s_rxMsgType = 0;
static uint8_t rs485s_rxLength = 0;

// RX buffer for export data
static uint8_t rs485s_rxBuffer[512];
static size_t rs485s_rxLen = 0;
static uint8_t rs485s_rxChecksum = 0;

// Skip state counter
static uint8_t rs485s_skipLength = 0;

// ============================================================================
// TX STATE (ring buffer for input commands)
// ============================================================================

static uint8_t rs485s_txBuffer[RS485_TX_BUFFER_SIZE];
static volatile size_t rs485s_txHead = 0;
static volatile size_t rs485s_txTail = 0;
static volatile size_t rs485s_txCount = 0;

// TX state during response
static size_t rs485s_txSendIdx = 0;
static size_t rs485s_txSendLen = 0;
static uint8_t rs485s_txChecksum = 0;

// ============================================================================
// STATISTICS
// ============================================================================

static uint32_t rs485s_pollsReceived = 0;
static uint32_t rs485s_broadcastsReceived = 0;
static uint32_t rs485s_pollsIgnored = 0;     // For other addresses
static uint32_t rs485s_exportBytesRx = 0;
static uint32_t rs485s_commandsSent = 0;
static uint32_t rs485s_checksumErrors = 0;
static uint32_t rs485s_syncResets = 0;

// DIAGNOSTIC COUNTERS (for comparing good.txt vs bad.txt)
static uint32_t rs485s_bcastWithData = 0;    // addr=0, len>0 (EXPECTED)
static uint32_t rs485s_pollWithData = 0;     // addr>0, len>0 (BUG!)
static uint32_t rs485s_pollEmpty = 0;        // addr>0, len=0 (normal)
static uint32_t rs485s_diagLastPrint = 0;

// ============================================================================
// TIMING
// ============================================================================

static uint32_t rs485s_lastByteTime = 0;
static uint32_t rs485s_lastPollTime = 0;
static uint32_t rs485s_rxStartTime = 0;

// ============================================================================
// FLAGS
// ============================================================================

static bool rs485s_initialized = false;
static bool rs485s_enabled = true;

// UART
static const uart_port_t RS485S_UART_NUM = UART_NUM_1;

// ============================================================================
// FORWARD DECLARATIONS (for parser integration)
// ============================================================================

// From DCSBIOSBridge - we feed received export data here
extern void parseDcsBiosUdpPacket(const uint8_t* data, size_t len);

// ============================================================================
// SYNC HELPERS
// ============================================================================

/**
 * @brief Reset to sync state - used on errors or timeouts
 */
static void rs485s_resetToSync() {
    rs485s_state = RS485SlaveState::SYNC;
    rs485s_syncResets++;
    rs485s_lastByteTime = micros();
}

/**
 * @brief Check for RX timeout and reset if needed
 * @return true if timeout occurred
 */
static bool rs485s_checkRxTimeout() {
    if (rs485s_state != RS485SlaveState::SYNC &&
        rs485s_state != RS485SlaveState::RX_WAIT_ADDRESS) {
        uint32_t elapsed = micros() - rs485s_rxStartTime;
        if (elapsed > RS485_SLAVE_RX_TIMEOUT_US) {
            #if RS485_SLAVE_DEBUG_VERBOSE
            debugPrintf("[RS485S] ‚ö†Ô∏è RX timeout in state %d, resync\n", (int)rs485s_state);
            #endif
            rs485s_resetToSync();
            return true;
        }
    }
    return false;
}

// ============================================================================
// TX BUFFER FUNCTIONS
// ============================================================================

/**
 * @brief Queue a command to be sent when polled
 * Format: "LABEL VALUE\n"
 */
static bool rs485s_queueCommandInternal(const char* label, const char* value) {
    // Calculate needed space: label + space + value + newline
    size_t labelLen = strlen(label);
    size_t valueLen = strlen(value);
    size_t needed = labelLen + 1 + valueLen + 1;  // +1 space, +1 newline

    if (needed > RS485_TX_BUFFER_SIZE - rs485s_txCount) {
        debugPrintf("[RS485S] ‚ö†Ô∏è TX buffer full, dropping: %s %s\n", label, value);
        return false;
    }

    // Add to ring buffer
    noInterrupts();
    for (size_t i = 0; i < labelLen; i++) {
        rs485s_txBuffer[rs485s_txHead] = label[i];
        rs485s_txHead = (rs485s_txHead + 1) % RS485_TX_BUFFER_SIZE;
    }
    rs485s_txBuffer[rs485s_txHead] = ' ';
    rs485s_txHead = (rs485s_txHead + 1) % RS485_TX_BUFFER_SIZE;
    for (size_t i = 0; i < valueLen; i++) {
        rs485s_txBuffer[rs485s_txHead] = value[i];
        rs485s_txHead = (rs485s_txHead + 1) % RS485_TX_BUFFER_SIZE;
    }
    rs485s_txBuffer[rs485s_txHead] = '\n';
    rs485s_txHead = (rs485s_txHead + 1) % RS485_TX_BUFFER_SIZE;
    rs485s_txCount += needed;
    interrupts();

    return true;
}

/**
 * @brief Process received export data
 */
static void rs485s_processExportData() {
    if (rs485s_rxLen == 0) return;

    rs485s_exportBytesRx += rs485s_rxLen;

    // Feed to CockpitOS DCS-BIOS parser (same path as UDP/USB!)
    parseDcsBiosUdpPacket(rs485s_rxBuffer, rs485s_rxLen);

    #if RS485_SLAVE_DEBUG_VERBOSE
    debugPrintf("[RS485S] üì• Received %d export bytes\n", rs485s_rxLen);
    #endif
}

/**
 * @brief Prepare response data from TX buffer
 */
static void rs485s_prepareResponse() {
    // Snapshot current TX buffer for sending
    noInterrupts();
    rs485s_txSendLen = rs485s_txCount;
    rs485s_txSendIdx = 0;

    // Limit to 253 bytes (length byte includes msgtype, so max data = 254 - 1)
    if (rs485s_txSendLen > 253) {
        rs485s_txSendLen = 253;
    }
    interrupts();
}

/**
 * @brief Called after successful response transmission
 */
static void rs485s_responseComplete() {
    // Remove sent bytes from TX buffer
    noInterrupts();
    rs485s_txTail = (rs485s_txTail + rs485s_txSendLen) % RS485_TX_BUFFER_SIZE;
    rs485s_txCount -= rs485s_txSendLen;
    interrupts();

    if (rs485s_txSendLen > 0) {
        rs485s_commandsSent++;
        #if RS485_SLAVE_DEBUG_VERBOSE
        debugPrintf("[RS485S] üì§ Sent %d bytes in response\n", rs485s_txSendLen);
        #endif
    }
}

/**
 * @brief Process incoming bytes (RX state machine)
 *
 * Protocol: [Address][MsgType][Length][Data...][Checksum]
 *
 * Address = 0: Broadcast (export data to all slaves, no response)
 * Address = N: Poll for slave N (slave N must respond)
 *
 * After a poll for another slave, we must skip their response before
 * we can receive the next packet.
 */
static void rs485s_processRx() {
    size_t available = 0;
    uart_get_buffered_data_len(RS485S_UART_NUM, &available);

    // Check for timeout if we're mid-packet
    if (available == 0) {
        rs485s_checkRxTimeout();
        return;
    }

    uint8_t byte;
    uint32_t now = micros();

    while (available > 0) {
        uart_read_bytes(RS485S_UART_NUM, &byte, 1, 0);
        available--;

        // Track byte timing for sync detection
        uint32_t gap = now - rs485s_lastByteTime;
        rs485s_lastByteTime = now;

        switch (rs485s_state) {
            // ==============================================================
            // SYNC STATE - Wait for bus idle gap before accepting packets
            // ==============================================================
            case RS485SlaveState::SYNC: {
                if (gap >= RS485_SLAVE_SYNC_GAP_US) {
                    // Gap detected - this byte is start of new packet (address)
                    rs485s_rxAddress = byte;
                    rs485s_rxChecksum = byte;
                    rs485s_rxStartTime = now;
                    rs485s_state = RS485SlaveState::RX_WAIT_MSGTYPE;

                    #if RS485_SLAVE_DEBUG_VERBOSE
                    debugPrintf("[RS485S] SYNC: New packet, addr=%d\n", byte);
                    #endif
                }
                // else: still in rapid data stream, stay in SYNC
                break;
            }

            // ==============================================================
            // RX_WAIT_ADDRESS - First byte of packet
            // ==============================================================
            case RS485SlaveState::RX_WAIT_ADDRESS: {
                rs485s_rxAddress = byte;
                rs485s_rxChecksum = byte;
                rs485s_rxStartTime = now;
                rs485s_state = RS485SlaveState::RX_WAIT_MSGTYPE;
                break;
            }

            // ==============================================================
            // RX_WAIT_MSGTYPE - Second byte of packet
            // ==============================================================
            case RS485SlaveState::RX_WAIT_MSGTYPE: {
                rs485s_rxMsgType = byte;
                rs485s_rxChecksum ^= byte;
                rs485s_state = RS485SlaveState::RX_WAIT_LENGTH;
                break;
            }

            // ==============================================================
            // RX_WAIT_LENGTH - Third byte of packet
            // ==============================================================
            case RS485SlaveState::RX_WAIT_LENGTH: {
                rs485s_rxLength = byte;
                rs485s_rxChecksum ^= byte;
                rs485s_rxLen = 0;

                if (rs485s_rxLength > 0) {
                    rs485s_state = RS485SlaveState::RX_WAIT_DATA;
                } else {
                    // Length = 0, skip to checksum
                    rs485s_state = RS485SlaveState::RX_WAIT_CHECKSUM;
                }
                break;
            }

            // ==============================================================
            // RX_WAIT_DATA - Receive data bytes
            // ==============================================================
            case RS485SlaveState::RX_WAIT_DATA: {
                // Only buffer if this is a broadcast or poll for us
                if (rs485s_rxAddress == RS485_ADDR_BROADCAST ||
                    rs485s_rxAddress == RS485_SLAVE_ADDRESS) {
                    if (rs485s_rxLen < sizeof(rs485s_rxBuffer)) {
                        rs485s_rxBuffer[rs485s_rxLen] = byte;
                    }
                }
                rs485s_rxLen++;
                rs485s_rxChecksum ^= byte;

                if (rs485s_rxLen >= rs485s_rxLength) {
                    rs485s_state = RS485SlaveState::RX_WAIT_CHECKSUM;
                }
                break;
            }

            // ==============================================================
            // RX_WAIT_CHECKSUM - Verify and process packet
            // ==============================================================
            case RS485SlaveState::RX_WAIT_CHECKSUM: {
                // Validate checksum
                if (byte != rs485s_rxChecksum) {
                    #if RS485_SLAVE_DEBUG_VERBOSE
                    debugPrintf("[RS485S] ‚ö†Ô∏è Checksum error: got 0x%02X, expected 0x%02X\n",
                               byte, rs485s_rxChecksum);
                    #endif
                    rs485s_checksumErrors++;
                    // Still process the packet, but log the error
                }

                // Determine what to do based on address
                if (rs485s_rxAddress == RS485_ADDR_BROADCAST) {
                    // BROADCAST: Process export data, no response
                    rs485s_broadcastsReceived++;

                    if (rs485s_rxMsgType == RS485_MSGTYPE_EXPORT && rs485s_rxLen > 0) {
                        rs485s_bcastWithData++;  // DIAGNOSTIC
                        // Log broadcast with data (EXPECTED for export)
                        debugPrintf("[BCAST] len=%d first=[%02X %02X %02X %02X]\n",
                                   rs485s_rxLen,
                                   rs485s_rxLen > 0 ? rs485s_rxBuffer[0] : 0,
                                   rs485s_rxLen > 1 ? rs485s_rxBuffer[1] : 0,
                                   rs485s_rxLen > 2 ? rs485s_rxBuffer[2] : 0,
                                   rs485s_rxLen > 3 ? rs485s_rxBuffer[3] : 0);
                        // Clamp to buffer size
                        if (rs485s_rxLen > sizeof(rs485s_rxBuffer)) {
                            rs485s_rxLen = sizeof(rs485s_rxBuffer);
                        }
                        rs485s_processExportData();
                    }

                    // Ready for next packet
                    rs485s_state = RS485SlaveState::RX_WAIT_ADDRESS;

                } else if (rs485s_rxAddress == RS485_SLAVE_ADDRESS) {
                    // POLL FOR US: Process any data, then respond
                    rs485s_pollsReceived++;
                    rs485s_lastPollTime = millis();

                    // DIAGNOSTIC: Track poll type
                    if (rs485s_rxLen > 0) {
                        rs485s_pollWithData++;  // THIS IS THE BUG INDICATOR!
                        debugPrintf("[POLL+DATA] addr=%d len=%d first=[%02X %02X %02X %02X]\n",
                                   rs485s_rxAddress, rs485s_rxLen,
                                   rs485s_rxLen > 0 ? rs485s_rxBuffer[0] : 0,
                                   rs485s_rxLen > 1 ? rs485s_rxBuffer[1] : 0,
                                   rs485s_rxLen > 2 ? rs485s_rxBuffer[2] : 0,
                                   rs485s_rxLen > 3 ? rs485s_rxBuffer[3] : 0);
                    } else {
                        rs485s_pollEmpty++;  // Normal - polls should be empty
                    }

                    // Process export data if present (some masters send data with poll)
                    if (rs485s_rxMsgType == RS485_MSGTYPE_EXPORT && rs485s_rxLen > 0) {
                        if (rs485s_rxLen > sizeof(rs485s_rxBuffer)) {
                            rs485s_rxLen = sizeof(rs485s_rxBuffer);
                        }
                        rs485s_processExportData();
                    }

                    // Prepare and send response
                    rs485s_prepareResponse();
                    rs485s_state = RS485SlaveState::TX_SEND_LENGTH;

                    // Small delay before responding (let bus settle, ~50¬µs)
                    delayMicroseconds(50);

                } else {
                    // POLL FOR ANOTHER SLAVE: Skip their response
                    rs485s_pollsIgnored++;
                    rs485s_state = RS485SlaveState::RX_SKIP_RESPONSE_LENGTH;
                }
                break;
            }

            // ==============================================================
            // SKIP STATES - Skip another slave's response
            // ==============================================================
            case RS485SlaveState::RX_SKIP_RESPONSE_LENGTH: {
                rs485s_skipLength = byte;
                if (rs485s_skipLength == 0) {
                    // Other slave had no data, ready for next packet
                    rs485s_state = RS485SlaveState::RX_WAIT_ADDRESS;
                } else {
                    rs485s_state = RS485SlaveState::RX_SKIP_RESPONSE_MSGTYPE;
                }
                break;
            }

            case RS485SlaveState::RX_SKIP_RESPONSE_MSGTYPE: {
                // Just skip this byte
                rs485s_state = RS485SlaveState::RX_SKIP_RESPONSE_DATA;
                break;
            }

            case RS485SlaveState::RX_SKIP_RESPONSE_DATA: {
                rs485s_skipLength--;
                if (rs485s_skipLength == 0) {
                    rs485s_state = RS485SlaveState::RX_SKIP_RESPONSE_CHECKSUM;
                }
                break;
            }

            case RS485SlaveState::RX_SKIP_RESPONSE_CHECKSUM: {
                // Skip checksum, ready for next packet
                rs485s_state = RS485SlaveState::RX_WAIT_ADDRESS;
                break;
            }

            default:
                // Unknown state, resync
                rs485s_resetToSync();
                break;
        }

        // Update timestamp for next iteration
        now = micros();
    }
}

/**
 * @brief Process outgoing response (TX state machine)
 *
 * Response format:
 * - No data:   [0x00] (single byte, no checksum)
 * - With data: [Length][MsgType=0][Data...][Checksum]
 *
 * Where Length = number of data bytes + 1 (for MsgType)
 *
 * For Arduino compatibility, we use 0x72 as checksum placeholder
 * when RS485_SLAVE_ARDUINO_COMPAT is enabled.
 */
static void rs485s_processTx() {
    switch (rs485s_state) {
        case RS485SlaveState::TX_SEND_LENGTH: {
            // Length byte: includes MsgType + data bytes
            // If no data: send 0x00 and we're done (no checksum needed)
            uint8_t len = (rs485s_txSendLen > 0) ? (uint8_t)(rs485s_txSendLen + 1) : 0;
            uart_write_bytes(RS485S_UART_NUM, (const char*)&len, 1);
            rs485s_txChecksum = len;

            if (len > 0) {
                rs485s_state = RS485SlaveState::TX_SEND_MSGTYPE;
            } else {
                // No data - single 0x00 byte response, no checksum
                uart_wait_tx_done(RS485S_UART_NUM, 10);
                rs485s_state = RS485SlaveState::RX_WAIT_ADDRESS;
            }
            break;
        }

        case RS485SlaveState::TX_SEND_MSGTYPE: {
            uint8_t msgType = 0;  // 0 = input command data
            uart_write_bytes(RS485S_UART_NUM, (const char*)&msgType, 1);
            rs485s_txChecksum ^= msgType;
            rs485s_txSendIdx = 0;

            if (rs485s_txSendLen > 0) {
                rs485s_state = RS485SlaveState::TX_SEND_DATA;
            } else {
                rs485s_state = RS485SlaveState::TX_SEND_CHECKSUM;
            }
            break;
        }

        case RS485SlaveState::TX_SEND_DATA: {
            // Send data from ring buffer
            while (rs485s_txSendIdx < rs485s_txSendLen) {
                size_t bufIdx = (rs485s_txTail + rs485s_txSendIdx) % RS485_TX_BUFFER_SIZE;
                uint8_t byte = rs485s_txBuffer[bufIdx];
                uart_write_bytes(RS485S_UART_NUM, (const char*)&byte, 1);
                rs485s_txChecksum ^= byte;
                rs485s_txSendIdx++;
            }
            rs485s_state = RS485SlaveState::TX_SEND_CHECKSUM;
            break;
        }

        case RS485SlaveState::TX_SEND_CHECKSUM: {
            // Send checksum
            #if RS485_SLAVE_ARDUINO_COMPAT
            // Arduino DCS-BIOS uses fixed 0x72 placeholder
            uint8_t checksum = RS485_CHECKSUM_FIXED;
            #else
            // Use calculated XOR checksum
            uint8_t checksum = rs485s_txChecksum;
            #endif

            uart_write_bytes(RS485S_UART_NUM, (const char*)&checksum, 1);
            uart_wait_tx_done(RS485S_UART_NUM, 10);

            rs485s_responseComplete();

            // Ready for next packet
            rs485s_state = RS485SlaveState::RX_WAIT_ADDRESS;
            break;
        }

        default:
            // Shouldn't be in TX states without proper setup
            rs485s_resetToSync();
            break;
    }
}

// ============================================================================
// PUBLIC API
// ============================================================================

bool RS485Slave_init() {
    if (rs485s_initialized) {
        debugPrintln("[RS485S] Already initialized");
        return true;
    }

    debugPrintf("[RS485S] Initializing RS-485 Slave (address %d)...\n", RS485_SLAVE_ADDRESS);

    // Validate address range
    if (RS485_SLAVE_ADDRESS < 1 || RS485_SLAVE_ADDRESS > 126) {
        debugPrintf("[RS485S] ‚ùå Invalid address %d (must be 1-126)\n", RS485_SLAVE_ADDRESS);
        return false;
    }

    uart_config_t uart_config = {
        .baud_rate = RS485_BAUD,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .rx_flow_ctrl_thresh = 0,
        .source_clk = UART_SCLK_DEFAULT,
    };

    esp_err_t err = uart_driver_install(RS485S_UART_NUM, 512, 256, 0, NULL, 0);
    if (err != ESP_OK) {
        debugPrintf("[RS485S] ‚ùå UART driver install failed: %d\n", err);
        return false;
    }

    err = uart_param_config(RS485S_UART_NUM, &uart_config);
    if (err != ESP_OK) {
        debugPrintf("[RS485S] ‚ùå UART config failed: %d\n", err);
        return false;
    }

    err = uart_set_pin(RS485S_UART_NUM, RS485_TX_PIN, RS485_RX_PIN, RS485_EN_PIN, UART_PIN_NO_CHANGE);
    if (err != ESP_OK) {
        debugPrintf("[RS485S] ‚ùå UART set pin failed: %d\n", err);
        return false;
    }

    err = uart_set_mode(RS485S_UART_NUM, UART_MODE_RS485_HALF_DUPLEX);
    if (err != ESP_OK) {
        debugPrintf("[RS485S] ‚ùå RS-485 mode failed: %d\n", err);
        return false;
    }

    // Clear buffers
    rs485s_txHead = 0;
    rs485s_txTail = 0;
    rs485s_txCount = 0;
    rs485s_rxLen = 0;

    // Reset statistics
    rs485s_pollsReceived = 0;
    rs485s_broadcastsReceived = 0;
    rs485s_pollsIgnored = 0;
    rs485s_exportBytesRx = 0;
    rs485s_commandsSent = 0;
    rs485s_checksumErrors = 0;
    rs485s_syncResets = 0;

    // Initialize timing
    rs485s_lastByteTime = micros();
    rs485s_lastPollTime = 0;
    rs485s_rxStartTime = 0;

    rs485s_initialized = true;
    rs485s_enabled = true;
    rs485s_state = RS485SlaveState::SYNC;  // Start in SYNC to detect first packet

    debugPrintf("[RS485S] ‚úÖ Initialized: addr=%d, %d baud, TX=%d, RX=%d, EN=%d\n",
                RS485_SLAVE_ADDRESS, RS485_BAUD, RS485_TX_PIN, RS485_RX_PIN, RS485_EN_PIN);
    #if RS485_SLAVE_ARDUINO_COMPAT
    debugPrintln("[RS485S] Mode: Arduino-compatible (fixed 0x72 checksum)");
    #else
    debugPrintln("[RS485S] Mode: Full protocol (calculated XOR checksum)");
    #endif

    return true;
}

void RS485Slave_loop() {
    if (!rs485s_initialized || !rs485s_enabled) return;

    switch (rs485s_state) {
        // RX states
        case RS485SlaveState::SYNC:
        case RS485SlaveState::RX_WAIT_ADDRESS:
        case RS485SlaveState::RX_WAIT_MSGTYPE:
        case RS485SlaveState::RX_WAIT_LENGTH:
        case RS485SlaveState::RX_WAIT_DATA:
        case RS485SlaveState::RX_WAIT_CHECKSUM:
        case RS485SlaveState::RX_SKIP_RESPONSE_LENGTH:
        case RS485SlaveState::RX_SKIP_RESPONSE_MSGTYPE:
        case RS485SlaveState::RX_SKIP_RESPONSE_DATA:
        case RS485SlaveState::RX_SKIP_RESPONSE_CHECKSUM:
            rs485s_processRx();
            break;

        // TX states
        case RS485SlaveState::TX_SEND_LENGTH:
        case RS485SlaveState::TX_SEND_MSGTYPE:
        case RS485SlaveState::TX_SEND_DATA:
        case RS485SlaveState::TX_SEND_CHECKSUM:
            rs485s_processTx();
            break;

        default:
            // Unknown state, reset
            rs485s_resetToSync();
            break;
    }

    // 5-SECOND DIAGNOSTIC SUMMARY (always prints - for good.txt vs bad.txt comparison)
    if (millis() - rs485s_diagLastPrint >= 5000) {
        rs485s_diagLastPrint = millis();
        debugPrintln("--- 5-SEC SUMMARY ---");
        debugPrintf("BCAST+data: %lu | POLL+data: %lu | POLL empty: %lu\n",
                   rs485s_bcastWithData, rs485s_pollWithData, rs485s_pollEmpty);
        debugPrintf("Export bytes: %lu | ChkErr: %lu\n",
                   rs485s_exportBytesRx, rs485s_checksumErrors);
        debugPrintln("---------------------");
    }

    // Periodic status (every 10 seconds, if debug verbose)
    #if RS485_SLAVE_DEBUG_VERBOSE
    static uint32_t lastStatusTime = 0;
    if (millis() - lastStatusTime > 10000) {
        lastStatusTime = millis();
        debugPrintf("[RS485S] üìä Polls=%lu | Bcasts=%lu | Export=%lu bytes | Cmds=%lu | Errs=%lu\n",
            rs485s_pollsReceived, rs485s_broadcastsReceived,
            rs485s_exportBytesRx, rs485s_commandsSent, rs485s_checksumErrors);
    }
    #endif
}

/**
 * @brief Queue an input command to be sent when polled
 *
 * Call this instead of sendCommand() when in slave mode.
 * Format on wire: "LABEL VALUE\n"
 *
 * @param label Control label (e.g., "UFC_MASTER_CAUTION")
 * @param value Value string (e.g., "1")
 * @return true if queued successfully
 */
bool RS485Slave_queueCommand(const char* label, const char* value) {
    if (!rs485s_initialized) return false;

    #if RS485_SLAVE_DEBUG_VERBOSE
    debugPrintf("[RS485S] üìù Queuing: %s %s\n", label, value);
    #endif

    return rs485s_queueCommandInternal(label, value);
}

void RS485Slave_setEnabled(bool en) {
    rs485s_enabled = en;
    if (!en) {
        // Reset to sync when disabled
        rs485s_state = RS485SlaveState::SYNC;
    }
    debugPrintf("[RS485S] %s\n", rs485s_enabled ? "Enabled" : "Disabled");
}

bool RS485Slave_isEnabled() {
    return rs485s_enabled;
}

bool RS485Slave_isInitialized() {
    return rs485s_initialized;
}

uint32_t RS485Slave_getPollCount() {
    return rs485s_pollsReceived;
}

uint32_t RS485Slave_getBroadcastCount() {
    return rs485s_broadcastsReceived;
}

uint32_t RS485Slave_getExportBytesReceived() {
    return rs485s_exportBytesRx;
}

uint32_t RS485Slave_getCommandsSent() {
    return rs485s_commandsSent;
}

uint32_t RS485Slave_getChecksumErrors() {
    return rs485s_checksumErrors;
}

size_t RS485Slave_getTxBufferPending() {
    return rs485s_txCount;
}

uint32_t RS485Slave_getTimeSinceLastPoll() {
    if (rs485s_lastPollTime == 0) return UINT32_MAX;
    return millis() - rs485s_lastPollTime;
}

void RS485Slave_printStatus() {
    debugPrintln("\n[RS485S] ========== SLAVE STATUS ==========");
    debugPrintf("[RS485S] Address: %d (0x%02X)\n", RS485_SLAVE_ADDRESS, RS485_SLAVE_ADDRESS);
    debugPrintf("[RS485S] Initialized: %s\n", rs485s_initialized ? "Yes" : "No");
    debugPrintf("[RS485S] Enabled: %s\n", rs485s_enabled ? "Yes" : "No");
    debugPrintf("[RS485S] State: %d\n", (int)rs485s_state);
    #if RS485_SLAVE_ARDUINO_COMPAT
    debugPrintln("[RS485S] Checksum mode: Arduino-compat (0x72)");
    #else
    debugPrintln("[RS485S] Checksum mode: Calculated XOR");
    #endif
    debugPrintln("[RS485S] ---------- Statistics ----------");
    debugPrintf("[RS485S] Polls received: %lu\n", rs485s_pollsReceived);
    debugPrintf("[RS485S] Broadcasts received: %lu\n", rs485s_broadcastsReceived);
    debugPrintf("[RS485S] Polls ignored (other addr): %lu\n", rs485s_pollsIgnored);
    debugPrintf("[RS485S] Export bytes RX: %lu\n", rs485s_exportBytesRx);
    debugPrintf("[RS485S] Commands sent: %lu\n", rs485s_commandsSent);
    debugPrintf("[RS485S] Checksum errors: %lu\n", rs485s_checksumErrors);
    debugPrintf("[RS485S] Sync resets: %lu\n", rs485s_syncResets);
    debugPrintf("[RS485S] TX buffer pending: %d bytes\n", rs485s_txCount);
    if (rs485s_lastPollTime > 0) {
        debugPrintf("[RS485S] Last poll: %lu ms ago\n", millis() - rs485s_lastPollTime);
    } else {
        debugPrintln("[RS485S] Last poll: Never");
    }
    debugPrintln("[RS485S] ========================================\n");
}

#endif // RS485_SLAVE_ENABLED
