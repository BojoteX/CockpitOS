/**
 * @file RS485Master.cpp
 * @brief RS-485 Master Driver for CockpitOS (OpenHornet ABSIS Compatible)
 * 
 * PROTOCOL DERIVED FROM ACTUAL ARDUINO DCS-BIOS LIBRARY SOURCE CODE:
 *   - DcsBiosNgRS485Slave.cpp.inc
 *   - DcsBiosNgRS485Master.cpp.inc
 * 
 * ==========================================================================
 * PROTOCOL SUMMARY:
 * ==========================================================================
 * 
 * PACKET FORMAT:
 *   [Address] [MsgType] [DataLength] [Data...] [Checksum]
 * 
 * TWO-PHASE POLLING:
 *   1. BROADCAST: Address=0 - All slaves receive export data, none respond
 *   2. POLL: Address=N - Only slave N responds with input commands
 * 
 * SLAVE RESPONSE:
 *   - No data:  [0x00] (single byte, NO checksum)
 *   - Has data: [Length] [MsgType=0] [Data...] [0x72]
 * 
 * ==========================================================================
 * BROADCAST MODES:
 * ==========================================================================
 * 
 * RS485_SMART_MODE = 0 (DUMB MODE - default):
 *   - Relays raw DCS-BIOS export stream exactly like Arduino Mega master
 *   - No change detection, no filtering
 *   - Slaves use their local ExportStreamListener to filter
 *   - ~128 bytes max per broadcast (matches Arduino ring buffer size)
 *   - Broadcasts once per poll cycle (after polling all slaves)
 * 
 * RS485_SMART_MODE = 1 (SMART MODE):
 *   - Change detection + address filtering
 *   - Only broadcasts addresses present in DCSBIOSBridgeData.h
 *   - ~10-50 bytes/broadcast, massive bandwidth savings
 * 
 * ==========================================================================
 */

#if RS485_MASTER_ENABLED

#include <driver/uart.h>
#include "../RS485Config.h"

// ============================================================================
// PROTOCOL CONSTANTS
// ============================================================================

static const uint8_t RS485_ADDR_BROADCAST = 0;
static const uint8_t RS485_MSGTYPE_POLL = 0;
static const uint8_t RS485_CHECKSUM_PLACEHOLDER = 0x72;

// Timeout initialization
static uint8_t rs485_skipTimeoutsAfterBroadcast = 0;

// ============================================================================
// STATE MACHINE
// ============================================================================

enum class RS485State : uint8_t {
    IDLE,
    BROADCAST_MSGTYPE, BROADCAST_LENGTH, BROADCAST_DATA, 
    BROADCAST_CHECKSUM, BROADCAST_WAIT_COMPLETE,
    POLL_MSGTYPE, POLL_LENGTH, POLL_WAIT_COMPLETE,
    RX_WAIT_LENGTH, RX_WAIT_MSGTYPE, RX_WAIT_DATA, RX_WAIT_CHECKSUM
};

// ============================================================================
// INTERNAL STRUCTURES
// ============================================================================

struct SlaveStatus {
    bool     online;
    uint32_t responseCount;
    uint32_t timeoutCount;
    uint32_t lastResponseUs;
};

struct MasterStats {
    uint32_t broadcastCount;
    uint32_t pollCount;
    uint32_t responseCount;
    uint32_t timeoutCount;
    uint32_t inputCmdCount;
    uint32_t checksumErrors;
    uint32_t exportBytesSent;
    uint32_t pollCycles;
    uint32_t changesDetected;
    uint32_t framesSkipped;
    uint32_t expectedTimeouts;  // Timeouts after receiving data (expected behavior)
};

// ============================================================================
// SMART MODE: CHANGE DETECTION PARSER (only used when RS485_SMART_MODE=1)
// ============================================================================

#if RS485_SMART_MODE

enum RS485ParseState : uint8_t {
    RS485_PARSE_WAIT_FOR_SYNC,
    RS485_PARSE_ADDRESS_LOW, RS485_PARSE_ADDRESS_HIGH,
    RS485_PARSE_COUNT_LOW, RS485_PARSE_COUNT_HIGH,
    RS485_PARSE_DATA_LOW, RS485_PARSE_DATA_HIGH
};

static RS485ParseState rs485_parseState = RS485_PARSE_WAIT_FOR_SYNC;
static uint8_t  rs485_syncByteCount = 0;
static uint16_t rs485_parseAddress = 0;
static uint16_t rs485_parseCount = 0;
static uint16_t rs485_parseData = 0;

// Change tracking
static uint16_t rs485_prevExport[0x4000];  // 32KB for address range 0x0000-0x7FFF
static bool rs485_prevInitialized = false;

// Change queue
#define RS485_CHANGE_QUEUE_SIZE 128
struct RS485Change { uint16_t address; uint16_t value; };
static RS485Change rs485_changeQueue[RS485_CHANGE_QUEUE_SIZE];
static volatile uint8_t rs485_changeQueueHead = 0;
static volatile uint8_t rs485_changeQueueTail = 0;
static volatile uint8_t rs485_changeCount = 0;
static bool rs485_frameHasChanges = false;

#endif // RS485_SMART_MODE

// ============================================================================
// DUMB MODE: RAW EXPORT FIFO BUFFER (only used when RS485_SMART_MODE=0)
// ============================================================================

#if !RS485_SMART_MODE

// FIFO buffer for raw export data
// Size: 16KB to handle bursty UDP arrivals
#define RS485_RAW_FIFO_SIZE 16384
static uint8_t rs485_rawFifo[RS485_RAW_FIFO_SIZE];
static volatile size_t rs485_rawHead = 0;   // Write position
static volatile size_t rs485_rawTail = 0;   // Read position  
static volatile size_t rs485_rawCount = 0;  // Bytes in buffer
static uint32_t rs485_fifoOverflows = 0;    // Track overflows for debugging

#endif // !RS485_SMART_MODE

// ============================================================================
// INTERNAL STATE
// ============================================================================

static RS485State rs485_state = RS485State::IDLE;
static SlaveStatus rs485_slaves[RS485_MAX_SLAVES];
static MasterStats rs485_stats = {0};

// Polling control
static uint8_t rs485_currentPollAddr = 0;
static uint8_t rs485_minPollAddr = RS485_MIN_POLL_ADDR;
static uint8_t rs485_maxPollAddr = RS485_MAX_POLL_ADDR;
static bool rs485_broadcastPending = false;

// Export data ring buffer (used for overflow protection in dumb mode)
static uint8_t rs485_exportRing[RS485_EXPORT_BUFFER_SIZE];
static volatile size_t rs485_exportHead = 0;
static volatile size_t rs485_exportTail = 0;
static volatile size_t rs485_exportCount = 0;

// TX state
static uint8_t rs485_txExportData[512];
static size_t rs485_txExportLen = 0;
static size_t rs485_txExportIdx = 0;
static uint8_t rs485_txChecksum = 0;

// RX state
static uint8_t rs485_rxBuffer[RS485_INPUT_BUFFER_SIZE];
static size_t rs485_rxLen = 0;
static size_t rs485_rxExpected = 0;
static uint8_t rs485_rxMsgType = 0;

// Timing
static uint32_t rs485_opStartUs = 0;
static uint32_t rs485_lastPollCompleteUs = 0;
static uint32_t rs485_lastBroadcastMs = 0;

// Slave tracking
static uint8_t rs485_consecutiveTimeouts[RS485_MAX_SLAVES] = {0};
static uint32_t rs485_lastResponseTime[RS485_MAX_SLAVES] = {0};
static bool rs485_offlineReported[RS485_MAX_SLAVES] = {false};
static const uint32_t RS485_OFFLINE_TIME_MS = 1000;

// Expected timeout tracking - Arduino slave misses one poll after sending data
static bool rs485_expectTimeoutAfterData = false;

// Flags
static bool rs485_initialized = false;
static bool rs485_enabled = true;

// UART
static const uart_port_t RS485_UART_NUM = UART_NUM_1;

// ============================================================================
// SMART MODE: CHANGE DETECTION FUNCTIONS
// ============================================================================

#if RS485_SMART_MODE

static void rs485_initPrevValues() {
    for (size_t i = 0; i < 0x4000; ++i) {
        rs485_prevExport[i] = 0xFFFFu;
    }
    rs485_prevInitialized = true;
    debugPrint("[RS485] üîÑ Prev values initialized (SMART MODE)\n");
}

static void rs485_queueChange(uint16_t address, uint16_t value) {
    if (rs485_changeCount >= RS485_CHANGE_QUEUE_SIZE) {
        rs485_changeQueueTail = (rs485_changeQueueTail + 1) % RS485_CHANGE_QUEUE_SIZE;
        rs485_changeCount--;
    }
    uint8_t head = rs485_changeQueueHead;
    rs485_changeQueue[head].address = address;
    rs485_changeQueue[head].value = value;
    rs485_changeQueueHead = (head + 1) % RS485_CHANGE_QUEUE_SIZE;
    rs485_changeCount++;
    rs485_frameHasChanges = true;
    rs485_stats.changesDetected++;
}

static void rs485_processAddressValue(uint16_t address, uint16_t value) {
    if (address >= 0x8000) return;
    
    // FILTER: Only queue addresses that exist in DcsOutputTable
    // This prevents gauge data from flooding the queue
    if (findDcsOutputEntries(address) == nullptr) return;
    
    uint16_t index = address >> 1;
    if (rs485_prevExport[index] == value) return;
    rs485_prevExport[index] = value;
    rs485_queueChange(address, value);
}

static void rs485_parseChar(uint8_t c) {
    switch (rs485_parseState) {
        case RS485_PARSE_WAIT_FOR_SYNC:
            break;
        case RS485_PARSE_ADDRESS_LOW:
            rs485_parseAddress = c;
            rs485_parseState = RS485_PARSE_ADDRESS_HIGH;
            break;
        case RS485_PARSE_ADDRESS_HIGH:
            rs485_parseAddress |= ((uint16_t)c << 8);
            rs485_parseState = (rs485_parseAddress != 0x5555) ? RS485_PARSE_COUNT_LOW : RS485_PARSE_WAIT_FOR_SYNC;
            break;
        case RS485_PARSE_COUNT_LOW:
            rs485_parseCount = c;
            rs485_parseState = RS485_PARSE_COUNT_HIGH;
            break;
        case RS485_PARSE_COUNT_HIGH:
            rs485_parseCount |= ((uint16_t)c << 8);
            rs485_parseState = RS485_PARSE_DATA_LOW;
            break;
        case RS485_PARSE_DATA_LOW:
            rs485_parseData = c;
            rs485_parseCount--;
            rs485_parseState = RS485_PARSE_DATA_HIGH;
            break;
        case RS485_PARSE_DATA_HIGH:
            rs485_parseData |= ((uint16_t)c << 8);
            rs485_parseCount--;
            rs485_processAddressValue(rs485_parseAddress, rs485_parseData);
            rs485_parseAddress += 2;
            rs485_parseState = (rs485_parseCount == 0) ? RS485_PARSE_ADDRESS_LOW : RS485_PARSE_DATA_LOW;
            break;
    }
    
    if (c == 0x55) {
        rs485_syncByteCount++;
    } else {
        rs485_syncByteCount = 0;
    }
    
    if (rs485_syncByteCount >= 4) {
        rs485_parseState = RS485_PARSE_ADDRESS_LOW;
        rs485_syncByteCount = 0;
        
        if (rs485_frameHasChanges) {
            rs485_broadcastPending = true;
            rs485_frameHasChanges = false;
        }
    }
}

// SMART MODE: Prepare export data from change queue
static void rs485_prepareExportData() {
    rs485_txExportLen = 0;
    
    while (rs485_changeCount > 0 && rs485_txExportLen < 240) {
        RS485Change& change = rs485_changeQueue[rs485_changeQueueTail];
        
        // Format: [0x55 0x55 0x55 0x55] [AddrLo AddrHi] [0x02 0x00] [ValLo ValHi]
        rs485_txExportData[rs485_txExportLen++] = 0x55;
        rs485_txExportData[rs485_txExportLen++] = 0x55;
        rs485_txExportData[rs485_txExportLen++] = 0x55;
        rs485_txExportData[rs485_txExportLen++] = 0x55;
        rs485_txExportData[rs485_txExportLen++] = change.address & 0xFF;
        rs485_txExportData[rs485_txExportLen++] = (change.address >> 8) & 0xFF;
        rs485_txExportData[rs485_txExportLen++] = 0x02;
        rs485_txExportData[rs485_txExportLen++] = 0x00;
        rs485_txExportData[rs485_txExportLen++] = change.value & 0xFF;
        rs485_txExportData[rs485_txExportLen++] = (change.value >> 8) & 0xFF;
        
        rs485_changeQueueTail = (rs485_changeQueueTail + 1) % RS485_CHANGE_QUEUE_SIZE;
        rs485_changeCount--;
    }
    
    rs485_stats.exportBytesSent += rs485_txExportLen;
}

#endif // RS485_SMART_MODE

// ============================================================================
// DUMB MODE: RAW RELAY FUNCTIONS (FIFO - preserves stream order)
// ============================================================================

#if !RS485_SMART_MODE

// DUMB MODE: Buffer raw DCS-BIOS byte into FIFO
// Simple circular buffer - when full, discard oldest to make room for newest
// No sync detection needed - we're a dumb pipe, slave handles parsing
static void rs485_bufferRawByte(uint8_t byte) {
    // Keep buffer bounded - discard oldest if approaching full
    // Use 512 as soft limit to leave headroom
    while (rs485_rawCount >= 512) {
        rs485_rawTail = (rs485_rawTail + 1) % RS485_RAW_FIFO_SIZE;
        rs485_rawCount--;
        rs485_fifoOverflows++;
    }

    // Add new byte at head
    rs485_rawFifo[rs485_rawHead] = byte;
    rs485_rawHead = (rs485_rawHead + 1) % RS485_RAW_FIFO_SIZE;
    rs485_rawCount++;
}

// DUMB MODE: Prepare export data - FIFO drain, NO sync scanning!
// Arduino master is a dumb byte pump: bytes in ‚Üí bytes out, in order.
// Slave parsers handle synchronization - that's their job, not ours.
// 
// CRITICAL FIX: Previous implementation scanned for sync pattern and DISCARDED
// all bytes before it. This threw away HIGH addresses (0x7400+ = LEDs/outputs)
// which appear at the END of frames, right before the next sync.
static void rs485_prepareExportData() {
    rs485_txExportLen = 0;
    
    if (rs485_rawCount == 0) {
        return;
    }

    // Drain FIFO in order, cap at ~250 bytes per broadcast (like Arduino's 128-byte buffer)
    // No sync scanning! Just send bytes in the order they arrived.
    size_t bytesToSend = (rs485_rawCount > 250) ? 250 : rs485_rawCount;
    
    for (size_t i = 0; i < bytesToSend; i++) {
        rs485_txExportData[rs485_txExportLen++] = rs485_rawFifo[rs485_rawTail];
        rs485_rawTail = (rs485_rawTail + 1) % RS485_RAW_FIFO_SIZE;
        rs485_rawCount--;
    }

    rs485_stats.exportBytesSent += rs485_txExportLen;
}

#endif // !RS485_SMART_MODE

// ============================================================================
// INPUT COMMAND PROCESSING
// ============================================================================

static void rs485_processInputCommand(const uint8_t* data, size_t len) {
    if (len == 0) return;
    
    char cmdBuf[64];
    size_t cmdLen = (len >= sizeof(cmdBuf)) ? sizeof(cmdBuf) - 1 : len;
    memcpy(cmdBuf, data, cmdLen);
    cmdBuf[cmdLen] = '\0';
    
    // Strip trailing newline
    while (cmdLen > 0 && (cmdBuf[cmdLen-1] == '\n' || cmdBuf[cmdLen-1] == '\r')) {
        cmdBuf[--cmdLen] = '\0';
    }
    
    char* space = strchr(cmdBuf, ' ');
    if (!space) {
        debugPrintf("[RS485] ‚ö†Ô∏è Malformed cmd: %s\n", cmdBuf);
        return;
    }
    
    *space = '\0';
    const char* label = cmdBuf;
    const char* value = space + 1;
    
    debugPrintf("[RS485] üéöÔ∏è SWITCH: %s = %s (from slave %d)\n", label, value, rs485_currentPollAddr);
    rs485_stats.inputCmdCount++;
    
    sendCommand(label, value, false);
}

// ============================================================================
// RESPONSE HANDLERS
// ============================================================================

static void rs485_handleResponse() {
    uint8_t idx = rs485_currentPollAddr - 1;
    if (idx < RS485_MAX_SLAVES) {
        if (rs485_offlineReported[idx]) {
            debugPrintf("[RS485] ‚úÖ Slave %d is ONLINE\n", rs485_currentPollAddr);
            rs485_offlineReported[idx] = false;
        }
        rs485_slaves[idx].online = true;
        rs485_slaves[idx].responseCount++;
        rs485_slaves[idx].lastResponseUs = micros() - rs485_opStartUs;
        rs485_consecutiveTimeouts[idx] = 0;
        rs485_lastResponseTime[idx] = millis();
    }
    
    rs485_stats.responseCount++;
    
    // Process input command if present
    if (rs485_rxLen > 0 && rs485_rxMsgType == 0) {
        rs485_processInputCommand(rs485_rxBuffer, rs485_rxLen);
        // After receiving data, slave will miss next poll (expected Arduino behavior)
        rs485_expectTimeoutAfterData = true;
    }
}

static void rs485_handleTimeout() {
    // Expected timeout after receiving data - don't count as error
    if (rs485_expectTimeoutAfterData) {
        rs485_expectTimeoutAfterData = false;
        rs485_stats.expectedTimeouts++;
        rs485_stats.responseCount++;  // Count as "response" since it's expected behavior
        return;
    }
    else if (rs485_skipTimeoutsAfterBroadcast > 0) {
        rs485_skipTimeoutsAfterBroadcast--;
        rs485_stats.expectedTimeouts++;
        rs485_stats.responseCount++;
        return;
    }
    
    uint8_t idx = rs485_currentPollAddr - 1;
    if (idx < RS485_MAX_SLAVES) {
        rs485_slaves[idx].timeoutCount++;
        rs485_consecutiveTimeouts[idx]++;
        
        uint32_t timeSinceResponse = millis() - rs485_lastResponseTime[idx];
        if (timeSinceResponse > RS485_OFFLINE_TIME_MS && 
            rs485_lastResponseTime[idx] != 0 &&
            !rs485_offlineReported[idx]) {
            rs485_slaves[idx].online = false;
            rs485_offlineReported[idx] = true;
            debugPrintf("[RS485] ‚ö†Ô∏è Slave %d OFFLINE (no response for %lu ms)\n", 
                       rs485_currentPollAddr, timeSinceResponse);
        }
    }
    
    rs485_stats.timeoutCount++;
}

static void rs485_advanceToNextSlave() {
    rs485_currentPollAddr++;
    if (rs485_currentPollAddr > rs485_maxPollAddr) {
        rs485_currentPollAddr = rs485_minPollAddr;
        rs485_stats.pollCycles++;
        
        // Poll cycle complete - schedule broadcast if data available
        // This is the ONLY place broadcastPending should be set (besides SMART mode's frame detection)
        #if RS485_SMART_MODE
        if (rs485_changeCount > 0) {
            rs485_broadcastPending = true;
        }
        #else
        // DUMB MODE: Broadcast after completing poll cycle if data available
        // This matches Arduino master behavior: poll all slaves, then broadcast, repeat
        if (rs485_rawCount > 0) {
            rs485_broadcastPending = true;
        }
        #endif
    }
    rs485_lastPollCompleteUs = micros();
    rs485_state = RS485State::IDLE;
}

// ============================================================================
// BROADCAST STATE MACHINE
// ============================================================================

static void rs485_startBroadcast() {
    rs485_prepareExportData();
    
    if (rs485_txExportLen == 0) {
        rs485_broadcastPending = false;
        rs485_state = RS485State::IDLE;
        return;
    }
    
    rs485_opStartUs = micros();
    rs485_broadcastPending = false;
    
    rs485_txChecksum = RS485_ADDR_BROADCAST ^ RS485_MSGTYPE_POLL ^ (uint8_t)rs485_txExportLen;
    for (size_t i = 0; i < rs485_txExportLen; i++) {
        rs485_txChecksum ^= rs485_txExportData[i];
    }
    
    // DEBUG: Log broadcast packet details
#if DEBUG_ENABLED
    #if RS485_SMART_MODE
    debugPrintf("[RS485-BCAST] üì° SMART: Sending %d bytes, checksum=0x%02X\n", rs485_txExportLen, rs485_txChecksum);
    // Show first few addresses from change queue format
    int shown = 0;
    for (size_t i = 0; i + 9 < rs485_txExportLen && shown < 3; i += 10) {
        if (rs485_txExportData[i] == 0x55 && rs485_txExportData[i+1] == 0x55) {
            uint16_t addr = rs485_txExportData[i+4] | (rs485_txExportData[i+5] << 8);
            uint16_t val  = rs485_txExportData[i+8] | (rs485_txExportData[i+9] << 8);
            debugPrintf("[RS485-BCAST]   -> Addr=0x%04X Val=0x%04X\n", addr, val);
            shown++;
        }
    }
    #else
    // DUMB mode: Just show raw byte range (don't try to parse)

    /*
    debugPrintf("[RS485-BCAST] üì° DUMB: Relaying %d raw bytes (first 8: %02X %02X %02X %02X %02X %02X %02X %02X)\n", 
        rs485_txExportLen,
        rs485_txExportLen > 0 ? rs485_txExportData[0] : 0,
        rs485_txExportLen > 1 ? rs485_txExportData[1] : 0,
        rs485_txExportLen > 2 ? rs485_txExportData[2] : 0,
        rs485_txExportLen > 3 ? rs485_txExportData[3] : 0,
        rs485_txExportLen > 4 ? rs485_txExportData[4] : 0,
        rs485_txExportLen > 5 ? rs485_txExportData[5] : 0,
        rs485_txExportLen > 6 ? rs485_txExportData[6] : 0,
        rs485_txExportLen > 7 ? rs485_txExportData[7] : 0);
    */

    #endif
#endif
    
    uint8_t addr = RS485_ADDR_BROADCAST;
    uart_write_bytes(RS485_UART_NUM, (const char*)&addr, 1);
    rs485_state = RS485State::BROADCAST_MSGTYPE;
    rs485_stats.broadcastCount++;
    rs485_lastBroadcastMs = millis();

    rs485_skipTimeoutsAfterBroadcast = 10;  // Skip next 10 timeouts
}

static void rs485_processBroadcastTx() {
    switch (rs485_state) {
        case RS485State::BROADCAST_MSGTYPE: {
            uint8_t msgtype = RS485_MSGTYPE_POLL;
            uart_write_bytes(RS485_UART_NUM, (const char*)&msgtype, 1);
            rs485_state = RS485State::BROADCAST_LENGTH;
            break;
        }
        case RS485State::BROADCAST_LENGTH: {
            uint8_t len = (uint8_t)rs485_txExportLen;
            uart_write_bytes(RS485_UART_NUM, (const char*)&len, 1);
            rs485_txExportIdx = 0;
            rs485_state = RS485State::BROADCAST_DATA;
            break;
        }
        case RS485State::BROADCAST_DATA: {
            size_t txFree = 0;
            uart_get_tx_buffer_free_size(RS485_UART_NUM, &txFree);
            while (rs485_txExportIdx < rs485_txExportLen && txFree > 1) {
                uart_write_bytes(RS485_UART_NUM, (const char*)&rs485_txExportData[rs485_txExportIdx], 1);
                rs485_txExportIdx++;
                txFree--;
            }
            if (rs485_txExportIdx >= rs485_txExportLen) {
                rs485_state = RS485State::BROADCAST_CHECKSUM;
            }
            break;
        }
        case RS485State::BROADCAST_CHECKSUM: {
            uart_write_bytes(RS485_UART_NUM, (const char*)&rs485_txChecksum, 1);
            rs485_state = RS485State::BROADCAST_WAIT_COMPLETE;
            break;
        }
        case RS485State::BROADCAST_WAIT_COMPLETE: {
            uart_wait_tx_done(RS485_UART_NUM, 1);
            #if RS485_POST_BROADCAST_DELAY_US > 0
            delayMicroseconds(RS485_POST_BROADCAST_DELAY_US);
            #endif
            rs485_state = RS485State::IDLE;
            break;
        }
        default:
            break;
    }
}

// ============================================================================
// POLL STATE MACHINE
// ============================================================================

static void rs485_startPoll(uint8_t addr) {
    rs485_currentPollAddr = addr;
    rs485_opStartUs = micros();
    
    // BOTH MODES: Polls are EMPTY (len=0), no data attached
    // Export data goes via BROADCAST (addr=0) separately
    uart_write_bytes(RS485_UART_NUM, (const char*)&addr, 1);
    rs485_state = RS485State::POLL_MSGTYPE;
    rs485_stats.pollCount++;
}

static void rs485_processPollTx() {
    switch (rs485_state) {
        case RS485State::POLL_MSGTYPE: {
            uint8_t msgtype = RS485_MSGTYPE_POLL;
            uart_write_bytes(RS485_UART_NUM, (const char*)&msgtype, 1);
            rs485_state = RS485State::POLL_LENGTH;
            break;
        }
        case RS485State::POLL_LENGTH: {
            // BOTH MODES: Polls have NO data (len=0)
            // Export data goes via BROADCAST (addr=0) separately
            uint8_t len = 0;
            uart_write_bytes(RS485_UART_NUM, (const char*)&len, 1);
            rs485_state = RS485State::POLL_WAIT_COMPLETE;
            break;
        }
        case RS485State::POLL_WAIT_COMPLETE: {
            uart_wait_tx_done(RS485_UART_NUM, 1);
            rs485_rxLen = 0;
            rs485_rxExpected = 0;
            rs485_rxMsgType = 0;
            rs485_opStartUs = micros();  // Reset timer for RX timeout
            rs485_state = RS485State::RX_WAIT_LENGTH;
            break;
        }
        default:
            break;
    }
}

// ============================================================================
// RESPONSE STATE MACHINE
// ============================================================================

static void rs485_processRx() {
    size_t available = 0;
    uart_get_buffered_data_len(RS485_UART_NUM, &available);

    if (available == 0) {
        uint32_t elapsed = micros() - rs485_opStartUs;
        if (elapsed > RS485_POLL_TIMEOUT_US) {
            rs485_handleTimeout();
            rs485_advanceToNextSlave();
        }
        return;
    }

    // Data available - process it
    uint8_t byte;

    switch (rs485_state) {
        case RS485State::RX_WAIT_LENGTH: {
            uart_read_bytes(RS485_UART_NUM, &byte, 1, 0);
            
            if (byte == 0x00) {
                // Empty response - slave has no data
                rs485_handleResponse();
                rs485_advanceToNextSlave();
                return;
            }
            
            // Non-zero length means data follows
            rs485_rxExpected = byte;
            rs485_rxLen = 0;
            rs485_state = RS485State::RX_WAIT_MSGTYPE;
            break;
        }
        
        case RS485State::RX_WAIT_MSGTYPE: {
            uart_read_bytes(RS485_UART_NUM, &byte, 1, 0);
            rs485_rxMsgType = byte;
            rs485_state = RS485State::RX_WAIT_DATA;
            break;
        }
        
        case RS485State::RX_WAIT_DATA: {
            while (available > 0 && rs485_rxLen < rs485_rxExpected) {
                uart_read_bytes(RS485_UART_NUM, &byte, 1, 0);
                if (rs485_rxLen < RS485_INPUT_BUFFER_SIZE) {
                    rs485_rxBuffer[rs485_rxLen] = byte;
                }
                rs485_rxLen++;
                available--;
            }
            
            if (rs485_rxLen >= rs485_rxExpected) {
                rs485_state = RS485State::RX_WAIT_CHECKSUM;
            }
            break;
        }
        
        case RS485State::RX_WAIT_CHECKSUM: {
            uart_read_bytes(RS485_UART_NUM, &byte, 1, 0);
            
            // Verify checksum (0x72 placeholder for now)
            if (byte == RS485_CHECKSUM_PLACEHOLDER) {
                rs485_handleResponse();
            } else {
                rs485_stats.checksumErrors++;

                /*
                debugPrintf("[RS485] ‚ö†Ô∏è Checksum error from slave %d: got 0x%02X\n", 
                           rs485_currentPollAddr, byte);
                */
            }
            
            rs485_advanceToNextSlave();
            break;
        }
        
        default:
            rs485_state = RS485State::IDLE;
            break;
    }
}

// ============================================================================
// PUBLIC INTERFACE
// ============================================================================

bool RS485Master_init() {
    if (rs485_initialized) return true;
    
    uart_config_t uart_config = {
        .baud_rate = RS485_BAUD,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .rx_flow_ctrl_thresh = 0,
        .source_clk = UART_SCLK_DEFAULT
    };
    
    esp_err_t err = uart_driver_install(RS485_UART_NUM, 256, 256, 0, NULL, 0);
    if (err != ESP_OK) {
        debugPrintf("[RS485] ‚ùå UART driver install failed: %d\n", err);
        return false;
    }
    
    err = uart_param_config(RS485_UART_NUM, &uart_config);
    if (err != ESP_OK) {
        debugPrintf("[RS485] ‚ùå UART param config failed: %d\n", err);
        return false;
    }
    
    err = uart_set_pin(RS485_UART_NUM, RS485_TX_PIN, RS485_RX_PIN, RS485_EN_PIN, UART_PIN_NO_CHANGE);
    if (err != ESP_OK) {
        debugPrintf("[RS485] ‚ùå UART set pin failed: %d\n", err);
        return false;
    }
    
    err = uart_set_mode(RS485_UART_NUM, UART_MODE_RS485_HALF_DUPLEX);
    if (err != ESP_OK) {
        debugPrintf("[RS485] ‚ùå RS-485 mode failed: %d\n", err);
        return false;
    }
    
    // Initialize slave tracking
    for (int i = 0; i < RS485_MAX_SLAVES; i++) {
        rs485_slaves[i] = {false, 0, 0, 0};
        rs485_consecutiveTimeouts[i] = 0;
        rs485_lastResponseTime[i] = 0;
        rs485_offlineReported[i] = false;
    }
    
    rs485_exportHead = rs485_exportTail = rs485_exportCount = 0;
    
    #if RS485_SMART_MODE
    rs485_changeQueueHead = rs485_changeQueueTail = rs485_changeCount = 0;
    #else
    rs485_rawHead = rs485_rawTail = rs485_rawCount = 0;
    rs485_fifoOverflows = 0;
    #endif
    
    rs485_initialized = true;
    rs485_enabled = true;
    rs485_state = RS485State::IDLE;
    rs485_currentPollAddr = rs485_minPollAddr;
    rs485_broadcastPending = false;
    rs485_lastPollCompleteUs = micros();
    rs485_lastBroadcastMs = 0;
    rs485_expectTimeoutAfterData = false;
    
    debugPrintf("[RS485] ‚úÖ Init OK: %d baud, TX=%d, RX=%d, EN=%d\n",
                RS485_BAUD, RS485_TX_PIN, RS485_RX_PIN, RS485_EN_PIN);
    debugPrintf("[RS485] Poll range: %d-%d\n", rs485_minPollAddr, rs485_maxPollAddr);
    #if RS485_SMART_MODE
    debugPrintln("[RS485] Mode: SMART (change detection + filtering)");
    #else
    debugPrintln("[RS485] Mode: DUMB (raw relay, Arduino-compatible)");
    #endif
    
    return true;
}

void RS485Master_loop() {
    if (!rs485_initialized || !rs485_enabled) return;

    // Don't poll unless DCS-BIOS is active - follows CockpitOS pattern
    if (!simReady()) return;
    
    // Status every 10 seconds
    static uint32_t lastStatusPrint = 0;
    if (millis() - lastStatusPrint > 10000) {
        lastStatusPrint = millis();
        uint32_t missed = rs485_stats.pollCount - rs485_stats.responseCount;
        float responseRate = rs485_stats.pollCount > 0 ?
            100.0f * rs485_stats.responseCount / rs485_stats.pollCount : 0;
        #if RS485_SMART_MODE
        debugPrintf("[RS485] üìä SMART: Polls=%lu | Resp=%lu (%.1f%%) | Missed=%lu | Bcasts=%lu | Changes=%lu | Bytes=%lu\n",
            rs485_stats.pollCount, rs485_stats.responseCount, responseRate, missed,
            rs485_stats.broadcastCount, rs485_stats.changesDetected, rs485_stats.exportBytesSent);
        #else
        debugPrintf("[RS485] üìä DUMB: Polls=%lu | Resp=%lu (%.1f%%) | Bcasts=%lu | Bytes=%lu | FIFO=%u | Overflow=%lu\n",
            rs485_stats.pollCount, rs485_stats.responseCount, responseRate,
            rs485_stats.broadcastCount, rs485_stats.exportBytesSent, 
            (unsigned)rs485_rawCount, rs485_fifoOverflows);
        #endif
    }
    
    switch (rs485_state) {
        case RS485State::IDLE: {
            #if RS485_SMART_MODE
            // SMART MODE: Separate broadcast (addr=0) from poll (addr=N)
            bool canBroadcast = rs485_broadcastPending && rs485_changeCount > 0;
            
            #ifdef RS485_DISABLE_BROADCASTS
            canBroadcast = false;
            rs485_changeCount = 0;
            #endif
            
            #if RS485_MIN_BROADCAST_INTERVAL_MS > 0
            if (canBroadcast && (millis() - rs485_lastBroadcastMs < RS485_MIN_BROADCAST_INTERVAL_MS)) {
                canBroadcast = false;
            }
            #endif
            
            if (canBroadcast) {
                rs485_startBroadcast();
            } else {
                rs485_broadcastPending = false;
                rs485_startPoll(rs485_currentPollAddr);
            }
            #else
            // DUMB MODE: Match Arduino master behavior exactly!
            // 1. If there's export data in FIFO ‚Üí BROADCAST first (addr=0)
            // 2. Only poll (with len=0) when FIFO is empty
            if (rs485_rawCount > 0) {
                rs485_startBroadcast();  // Send via addr=0, just like Arduino!
            } else {
                rs485_startPoll(rs485_currentPollAddr);  // Empty poll (len=0)
            }
            #endif
            break;
        }
        case RS485State::BROADCAST_MSGTYPE:
        case RS485State::BROADCAST_LENGTH:
        case RS485State::BROADCAST_DATA:
        case RS485State::BROADCAST_CHECKSUM:
        case RS485State::BROADCAST_WAIT_COMPLETE:
            rs485_processBroadcastTx();
            break;
        case RS485State::POLL_MSGTYPE:
        case RS485State::POLL_LENGTH:
        case RS485State::POLL_WAIT_COMPLETE:
            rs485_processPollTx();
            break;
        case RS485State::RX_WAIT_LENGTH:
        case RS485State::RX_WAIT_MSGTYPE:
        case RS485State::RX_WAIT_DATA:
        case RS485State::RX_WAIT_CHECKSUM:
            rs485_processRx();
            break;
        default:
            rs485_state = RS485State::IDLE;
            break;
    }
}

void RS485Master_feedExportData(const uint8_t* data, size_t len) {
    if (!rs485_initialized) return;
    
    #ifdef RS485_DISABLE_BROADCASTS
    (void)data; (void)len;
    return;
    #endif
    
    #if RS485_SMART_MODE
    // SMART MODE: Parse and detect changes
    if (!rs485_prevInitialized) rs485_initPrevValues();
    for (size_t i = 0; i < len; i++) {
        rs485_parseChar(data[i]);
    }
    #else
    // DUMB MODE: Buffer raw bytes for relay
    for (size_t i = 0; i < len; i++) {
        rs485_bufferRawByte(data[i]);
    }
    #endif
}

void RS485Master_forceFullSync() {
    #if RS485_SMART_MODE
    rs485_initPrevValues();
    #else
    rs485_rawHead = rs485_rawTail = rs485_rawCount = 0;
    rs485_fifoOverflows = 0;
    #endif
    rs485_broadcastPending = true;
    debugPrint("[RS485] üîÑ Forced full sync\n");
}

void RS485Master_setPollingRange(uint8_t minAddr, uint8_t maxAddr) {
    rs485_minPollAddr = constrain(minAddr, 1, RS485_MAX_SLAVES);
    rs485_maxPollAddr = constrain(maxAddr, rs485_minPollAddr, RS485_MAX_SLAVES);
    rs485_currentPollAddr = rs485_minPollAddr;
    debugPrintf("[RS485] Poll range: %d-%d\n", rs485_minPollAddr, rs485_maxPollAddr);
}

void RS485Master_setEnabled(bool en) {
    rs485_enabled = en;
    debugPrintf("[RS485] %s\n", en ? "Enabled" : "Disabled");
}

bool RS485Master_isSlaveOnline(uint8_t address) {
    if (address < 1 || address > RS485_MAX_SLAVES) return false;
    return rs485_slaves[address - 1].online;
}

uint8_t RS485Master_getOnlineSlaveCount() {
    uint8_t count = 0;
    for (uint8_t i = rs485_minPollAddr; i <= rs485_maxPollAddr; i++) {
        if (rs485_slaves[i - 1].online) count++;
    }
    return count;
}

void RS485Master_printStatus() {
    debugPrintln("\n[RS485] ========== STATUS ==========");
    #if RS485_SMART_MODE
    debugPrintln("[RS485] Mode: SMART (change detection)");
    #else
    debugPrintln("[RS485] Mode: DUMB (raw relay, Arduino-compatible)");
    #endif
    float responseRate = rs485_stats.pollCount > 0 ? 
        100.0f * rs485_stats.responseCount / rs485_stats.pollCount : 0;
    debugPrintf("[RS485] Polls: %lu, Responses: %lu (%.1f%%)\n",
                rs485_stats.pollCount, rs485_stats.responseCount, responseRate);
    debugPrintf("[RS485] Timeouts: %lu (+ %lu expected)\n", 
                rs485_stats.timeoutCount, rs485_stats.expectedTimeouts);
    debugPrintf("[RS485] Input cmds: %lu\n", rs485_stats.inputCmdCount);
    debugPrintf("[RS485] Broadcasts: %lu, Bytes sent: %lu\n", 
                rs485_stats.broadcastCount, rs485_stats.exportBytesSent);
    debugPrintln("[RS485] ================================\n");
}

#endif // RS485_MASTER_ENABLED
