/**
 * @file RS485Master.cpp
 * @brief RS-485 Master Driver for CockpitOS (OpenHornet ABSIS Compatible)
 * @version 2.0.0
 * 
 * PROTOCOL: DCS-BIOS RS-485 (100% compatible with DCS-Skunkworks Arduino library)
 * SOURCE:   github.com/DCS-Skunkworks/dcs-bios-arduino-library
 *           - DcsBiosNgRS485Master.cpp.inc
 *           - DcsBiosNgRS485Slave.cpp.inc
 * 
 * ==========================================================================
 * PROTOCOL SUMMARY:
 * ==========================================================================
 * 
 * MASTER -> SLAVE (Poll Request):
 *   [Address] [MsgType=0] [Length=0]     (3 bytes, NO checksum)
 * 
 * MASTER -> ALL (Broadcast with export data):
 *   [Address=0] [MsgType=0] [Length] [Data...] [XOR Checksum]
 * 
 * SLAVE -> MASTER (Response):
 *   No data:   [0x00]                              (1 byte only)
 *   Has data:  [Length] [MsgType=0] [Data...] [0x72]
 *              Length = DATA bytes only (NOT including MsgType or checksum)
 * 
 * TIMING (from Arduino library):
 *   - 1ms timeout for no response (device not present)
 *   - 5ms timeout for incomplete message (started but stopped)
 * 
 * ==========================================================================
 * IMPROVEMENTS OVER ARDUINO IMPLEMENTATION:
 * ==========================================================================
 * 
 * 1. CHANGE DETECTION: Only broadcasts values that actually changed,
 *    reducing bus traffic by 90%+ compared to Arduino's full-stream relay.
 * 
 * 2. EXPECTED TIMEOUT HANDLING: Understands Arduino slave behavior where
 *    they miss polls after transmitting data or receiving broadcasts.
 * 
 * 3. NATIVE RS-485: Uses ESP32's hardware RS-485 mode with automatic
 *    direction control - no manual pin toggling required.
 * 
 * 4. COMPREHENSIVE STATS: Tracks polls, responses, timeouts, commands,
 *    expected timeouts, and per-slave status.
 * 
 * ==========================================================================
 */

#if RS485_MASTER_ENABLED

#include <driver/uart.h>
#include "../RS485Config.h"

// ============================================================================
// PROTOCOL CONSTANTS (from DCS-BIOS Arduino library)
// ============================================================================

static const uint8_t RS485_ADDR_BROADCAST = 0;
static const uint8_t RS485_MSGTYPE_POLL = 0;
static const uint8_t RS485_SLAVE_CHECKSUM = 0x72;  // Hardcoded in Arduino slave

// ============================================================================
// STATE MACHINE
// ============================================================================

enum class RS485State : uint8_t {
    IDLE,
    // Broadcast TX states
    BROADCAST_MSGTYPE, 
    BROADCAST_LENGTH, 
    BROADCAST_DATA, 
    BROADCAST_CHECKSUM, 
    BROADCAST_WAIT_COMPLETE,
    // Poll TX states
    POLL_MSGTYPE, 
    POLL_LENGTH, 
    POLL_WAIT_COMPLETE,
    // RX states
    RX_WAIT_LENGTH,     // Waiting for first byte (length)
    RX_WAIT_MSGTYPE,    // Waiting for message type
    RX_WAIT_DATA,       // Waiting for data bytes
    RX_WAIT_CHECKSUM    // Waiting for checksum
};

// ============================================================================
// INTERNAL STRUCTURES
// ============================================================================

struct SlaveStatus {
    bool     online;
    uint32_t responseCount;
    uint32_t timeoutCount;
    uint32_t lastResponseUs;    // Response time of last successful poll
};

struct MasterStats {
    uint32_t broadcastCount;
    uint32_t pollCount;
    uint32_t responseCount;
    uint32_t timeoutCount;
    uint32_t inputCmdCount;
    uint32_t checksumErrors;
    uint32_t exportBytesSent;
    uint32_t pollCycles;
    uint32_t changesDetected;
    uint32_t framesSkipped;
    uint32_t expectedTimeouts;  // Expected timeouts (not errors)
};

// ============================================================================
// CHANGE DETECTION PARSER
// ============================================================================
// 
// Parses DCS-BIOS export stream to detect changes. This is isolated from
// the main DCSBIOSBridge parser to avoid interference.
//
// DCS-BIOS Export Format:
//   [0x55 0x55 0x55 0x55] [AddrLo AddrHi] [CountLo CountHi] [Data...]
//
// We track all 16-bit values at even addresses 0x0000-0x7FFE (32KB state).

enum RS485ParseState : uint8_t {
    RS485_PARSE_WAIT_FOR_SYNC,
    RS485_PARSE_ADDRESS_LOW, 
    RS485_PARSE_ADDRESS_HIGH,
    RS485_PARSE_COUNT_LOW, 
    RS485_PARSE_COUNT_HIGH,
    RS485_PARSE_DATA_LOW, 
    RS485_PARSE_DATA_HIGH
};

static RS485ParseState rs485_parseState = RS485_PARSE_WAIT_FOR_SYNC;
static uint8_t  rs485_syncByteCount = 0;
static uint16_t rs485_parseAddress = 0;
static uint16_t rs485_parseCount = 0;
static uint16_t rs485_parseData = 0;

// Change tracking - 32KB for addresses 0x0000-0x7FFE (16-bit values)
static uint16_t rs485_prevExport[0x4000];
static bool rs485_prevInitialized = false;

// Change queue - pending changes to broadcast
struct RS485Change { 
    uint16_t address; 
    uint16_t value; 
};
static RS485Change rs485_changeQueue[RS485_CHANGE_QUEUE_SIZE];
static volatile uint8_t rs485_changeQueueHead = 0;
static volatile uint8_t rs485_changeQueueTail = 0;
static volatile uint8_t rs485_changeCount = 0;
static bool rs485_frameHasChanges = false;

// ============================================================================
// INTERNAL STATE
// ============================================================================

static RS485State rs485_state = RS485State::IDLE;
static SlaveStatus rs485_slaves[RS485_MAX_SLAVES];
static MasterStats rs485_stats = {0};

// Polling control
static uint8_t rs485_currentPollAddr = 0;
static uint8_t rs485_minPollAddr = RS485_MIN_POLL_ADDR;
static uint8_t rs485_maxPollAddr = RS485_MAX_POLL_ADDR;
static bool rs485_broadcastPending = false;

// TX state
static uint8_t rs485_txExportData[RS485_TX_BUFFER_SIZE];
static size_t rs485_txExportLen = 0;
static size_t rs485_txExportIdx = 0;
static uint8_t rs485_txChecksum = 0;

// RX state
static uint8_t rs485_rxBuffer[RS485_INPUT_BUFFER_SIZE];
static size_t rs485_rxLen = 0;
static size_t rs485_rxExpected = 0;
static uint8_t rs485_rxMsgType = 0;

// Timing
static uint32_t rs485_opStartUs = 0;
static uint32_t rs485_lastPollCompleteUs = 0;
static uint32_t rs485_lastBroadcastMs = 0;

// Slave tracking
static uint8_t rs485_consecutiveTimeouts[RS485_MAX_SLAVES] = {0};
static uint32_t rs485_lastResponseTime[RS485_MAX_SLAVES] = {0};
static bool rs485_offlineReported[RS485_MAX_SLAVES] = {false};

// Expected timeout tracking
// Arduino slaves miss polls after TX due to their blocking loop() processing
static uint8_t rs485_expectTimeoutAfterData = 0;
static uint8_t rs485_skipTimeoutsAfterBroadcast = 0;

// Flags
static bool rs485_initialized = false;
static bool rs485_enabled = true;

// UART
static const uart_port_t RS485_UART_NUM = UART_NUM_1;

// ============================================================================
// CHANGE DETECTION FUNCTIONS
// ============================================================================

static void rs485_initPrevValues() {
    // Initialize all values to 0xFFFF - this will never match real DCS-BIOS
    // values (which are 0x0000-0xFFFE), forcing a broadcast on first frame
    for (size_t i = 0; i < 0x4000; ++i) {
        rs485_prevExport[i] = 0xFFFFu;
    }
    rs485_prevInitialized = true;
    debugPrint("[RS485] Change tracking initialized\n");
}

static void rs485_queueChange(uint16_t address, uint16_t value) {
    // If queue is full, drop oldest entry (ring buffer overflow)
    if (rs485_changeCount >= RS485_CHANGE_QUEUE_SIZE) {
        rs485_changeQueueTail = (rs485_changeQueueTail + 1) % RS485_CHANGE_QUEUE_SIZE;
        rs485_changeCount--;
        rs485_stats.framesSkipped++;
    }
    
    uint8_t head = rs485_changeQueueHead;
    rs485_changeQueue[head].address = address;
    rs485_changeQueue[head].value = value;
    rs485_changeQueueHead = (head + 1) % RS485_CHANGE_QUEUE_SIZE;
    rs485_changeCount++;
    rs485_frameHasChanges = true;
    rs485_stats.changesDetected++;
}

static void rs485_processAddressValue(uint16_t address, uint16_t value) {
    // Only track addresses in valid range (even addresses 0x0000-0x7FFE)
    if (address >= 0x8000) return;
    
    uint16_t index = address >> 1;  // Convert byte address to 16-bit index
    
    // Check if value changed
    if (rs485_prevExport[index] == value) return;
    
    // Update tracking and queue the change
    rs485_prevExport[index] = value;
    rs485_queueChange(address, value);
}

static void rs485_parseChar(uint8_t c) {
    // State machine to parse DCS-BIOS export stream
    switch (rs485_parseState) {
        case RS485_PARSE_WAIT_FOR_SYNC:
            // Waiting for sync - do nothing, sync detection below handles it
            break;
            
        case RS485_PARSE_ADDRESS_LOW:
            rs485_parseAddress = c;
            rs485_parseState = RS485_PARSE_ADDRESS_HIGH;
            break;
            
        case RS485_PARSE_ADDRESS_HIGH:
            rs485_parseAddress |= ((uint16_t)c << 8);
            // Address 0x5555 is used for sync detection escape - restart sync
            if (rs485_parseAddress == 0x5555) {
                rs485_parseState = RS485_PARSE_WAIT_FOR_SYNC;
            } else {
                rs485_parseState = RS485_PARSE_COUNT_LOW;
            }
            break;
            
        case RS485_PARSE_COUNT_LOW:
            rs485_parseCount = c;
            rs485_parseState = RS485_PARSE_COUNT_HIGH;
            break;
            
        case RS485_PARSE_COUNT_HIGH:
            rs485_parseCount |= ((uint16_t)c << 8);
            rs485_parseState = RS485_PARSE_DATA_LOW;
            break;
            
        case RS485_PARSE_DATA_LOW:
            rs485_parseData = c;
            rs485_parseCount--;
            rs485_parseState = RS485_PARSE_DATA_HIGH;
            break;
            
        case RS485_PARSE_DATA_HIGH:
            rs485_parseData |= ((uint16_t)c << 8);
            rs485_parseCount--;
            rs485_processAddressValue(rs485_parseAddress, rs485_parseData);
            rs485_parseAddress += 2;
            rs485_parseState = (rs485_parseCount == 0) ? RS485_PARSE_ADDRESS_LOW : RS485_PARSE_DATA_LOW;
            break;
    }
    
    // Sync sequence detection (runs in parallel with state machine)
    if (c == 0x55) {
        rs485_syncByteCount++;
    } else {
        rs485_syncByteCount = 0;
    }
    
    // Four 0x55 bytes = frame sync
    if (rs485_syncByteCount >= 4) {
        rs485_parseState = RS485_PARSE_ADDRESS_LOW;
        rs485_syncByteCount = 0;
        
        // Frame complete - trigger broadcast if we have changes
        if (rs485_frameHasChanges) {
            rs485_broadcastPending = true;
            rs485_frameHasChanges = false;
        }
    }
}

// ============================================================================
// EXPORT DATA HANDLING
// ============================================================================

static void rs485_prepareExportData() {
    rs485_txExportLen = 0;
    
    // Pack queued changes into DCS-BIOS format
    // Each change: [0x55 0x55 0x55 0x55] [AddrLo AddrHi] [0x02 0x00] [ValLo ValHi]
    // = 10 bytes per change
    
    while (rs485_changeCount > 0 && rs485_txExportLen < (RS485_TX_BUFFER_SIZE - 10)) {
        RS485Change& change = rs485_changeQueue[rs485_changeQueueTail];
        
        // Sync sequence
        rs485_txExportData[rs485_txExportLen++] = 0x55;
        rs485_txExportData[rs485_txExportLen++] = 0x55;
        rs485_txExportData[rs485_txExportLen++] = 0x55;
        rs485_txExportData[rs485_txExportLen++] = 0x55;
        
        // Address (little-endian)
        rs485_txExportData[rs485_txExportLen++] = change.address & 0xFF;
        rs485_txExportData[rs485_txExportLen++] = (change.address >> 8) & 0xFF;
        
        // Count = 2 bytes (little-endian)
        rs485_txExportData[rs485_txExportLen++] = 0x02;
        rs485_txExportData[rs485_txExportLen++] = 0x00;
        
        // Value (little-endian)
        rs485_txExportData[rs485_txExportLen++] = change.value & 0xFF;
        rs485_txExportData[rs485_txExportLen++] = (change.value >> 8) & 0xFF;
        
        // Advance queue
        rs485_changeQueueTail = (rs485_changeQueueTail + 1) % RS485_CHANGE_QUEUE_SIZE;
        rs485_changeCount--;
    }
    
    rs485_stats.exportBytesSent += rs485_txExportLen;
}

// ============================================================================
// INPUT COMMAND PROCESSING
// ============================================================================

static void rs485_processInputCommand(const uint8_t* data, size_t len) {
    if (len == 0) return;
    
    // Copy to null-terminated buffer
    char cmdBuf[RS485_INPUT_BUFFER_SIZE];
    size_t cmdLen = (len >= sizeof(cmdBuf)) ? sizeof(cmdBuf) - 1 : len;
    memcpy(cmdBuf, data, cmdLen);
    cmdBuf[cmdLen] = '\0';
    
    // Strip trailing newline/carriage return
    while (cmdLen > 0 && (cmdBuf[cmdLen-1] == '\n' || cmdBuf[cmdLen-1] == '\r')) {
        cmdBuf[--cmdLen] = '\0';
    }
    
    // Parse "CONTROL_NAME VALUE" format
    char* space = strchr(cmdBuf, ' ');
    if (!space) {
        #if !RS485_DEBUG_ERRORS_ONLY
        debugPrintf("[RS485] Malformed cmd from slave %d: %s\n", rs485_currentPollAddr, cmdBuf);
        #endif
        return;
    }
    
    *space = '\0';
    const char* label = cmdBuf;
    const char* value = space + 1;
    
    #if RS485_DEBUG_VERBOSE
    debugPrintf("[RS485] INPUT: %s = %s (slave %d)\n", label, value, rs485_currentPollAddr);
    #endif
    
    rs485_stats.inputCmdCount++;
    
    // Forward to DCS-BIOS via CockpitOS transport
    sendCommand(label, value, false);
}

// ============================================================================
// RESPONSE HANDLERS
// ============================================================================

static void rs485_handleResponse() {
    uint8_t idx = rs485_currentPollAddr - 1;
    
    if (idx < RS485_MAX_SLAVES) {
        // Mark slave as online
        if (rs485_offlineReported[idx]) {
            debugPrintf("[RS485] Slave %d ONLINE\n", rs485_currentPollAddr);
            rs485_offlineReported[idx] = false;
        }
        
        rs485_slaves[idx].online = true;
        rs485_slaves[idx].responseCount++;
        rs485_slaves[idx].lastResponseUs = micros() - rs485_opStartUs;
        rs485_consecutiveTimeouts[idx] = 0;
        rs485_lastResponseTime[idx] = millis();
    }
    
    rs485_stats.responseCount++;
    
    // Process input command if present
    if (rs485_rxLen > 0 && rs485_rxMsgType == RS485_MSGTYPE_POLL) {
        rs485_processInputCommand(rs485_rxBuffer, rs485_rxLen);
        
        // EMPIRICAL: Arduino slave misses next N polls after sending data
        // because its loop() is busy processing when the poll arrives
        #if RS485_EXPECTED_TIMEOUTS_AFTER_TX > 0
        rs485_expectTimeoutAfterData = RS485_EXPECTED_TIMEOUTS_AFTER_TX;
        #endif
    }
}

static void rs485_handleTimeout() {
    // Check if this is an EXPECTED timeout (not an error)
    
    // 1. Expected timeout after slave transmitted data
    if (rs485_expectTimeoutAfterData > 0) {
        rs485_expectTimeoutAfterData--;
        rs485_stats.expectedTimeouts++;
        rs485_stats.responseCount++;  // Count as success - it's expected
        return;
    }
    
    // 2. Expected timeout after broadcast (slaves processing data)
    if (rs485_skipTimeoutsAfterBroadcast > 0) {
        rs485_skipTimeoutsAfterBroadcast--;
        rs485_stats.expectedTimeouts++;
        rs485_stats.responseCount++;
        return;
    }
    
    // This is a REAL timeout - slave didn't respond
    uint8_t idx = rs485_currentPollAddr - 1;
    
    if (idx < RS485_MAX_SLAVES) {
        rs485_slaves[idx].timeoutCount++;
        rs485_consecutiveTimeouts[idx]++;
        
        // Check if slave should be marked offline
        uint32_t timeSinceResponse = millis() - rs485_lastResponseTime[idx];
        bool wasNeverSeen = (rs485_lastResponseTime[idx] == 0);
        bool timedOut = (timeSinceResponse > RS485_OFFLINE_THRESHOLD_MS);
        
        if ((timedOut || wasNeverSeen) && !rs485_offlineReported[idx]) {
            rs485_slaves[idx].online = false;
            rs485_offlineReported[idx] = true;
            
            if (!wasNeverSeen) {
                debugPrintf("[RS485] Slave %d OFFLINE (no response for %lu ms)\n", 
                           rs485_currentPollAddr, timeSinceResponse);
            }
        }
    }
    
    rs485_stats.timeoutCount++;
}

static void rs485_advanceToNextSlave() {
    rs485_currentPollAddr++;
    
    if (rs485_currentPollAddr > rs485_maxPollAddr) {
        rs485_currentPollAddr = rs485_minPollAddr;
        rs485_stats.pollCycles++;
        
        // Check for pending broadcasts at end of poll cycle
        if (rs485_changeCount > 0) {
            rs485_broadcastPending = true;
        }
    }
    
    rs485_lastPollCompleteUs = micros();
    rs485_state = RS485State::IDLE;
}

// ============================================================================
// BROADCAST STATE MACHINE
// ============================================================================

static void rs485_startBroadcast() {
    rs485_prepareExportData();
    
    if (rs485_txExportLen == 0) {
        rs485_broadcastPending = false;
        rs485_state = RS485State::IDLE;
        return;
    }
    
    rs485_opStartUs = micros();
    rs485_broadcastPending = false;
    
    // Calculate XOR checksum
    rs485_txChecksum = RS485_ADDR_BROADCAST;
    rs485_txChecksum ^= RS485_MSGTYPE_POLL;
    rs485_txChecksum ^= (uint8_t)rs485_txExportLen;
    for (size_t i = 0; i < rs485_txExportLen; i++) {
        rs485_txChecksum ^= rs485_txExportData[i];
    }
    
    // Send address byte
    uint8_t addr = RS485_ADDR_BROADCAST;
    uart_write_bytes(RS485_UART_NUM, (const char*)&addr, 1);
    rs485_state = RS485State::BROADCAST_MSGTYPE;
    rs485_stats.broadcastCount++;
    rs485_lastBroadcastMs = millis();
    
    // EMPIRICAL: Slaves miss N polls after receiving broadcast
    #if RS485_EXPECTED_TIMEOUTS_AFTER_BCAST > 0
    rs485_skipTimeoutsAfterBroadcast = RS485_EXPECTED_TIMEOUTS_AFTER_BCAST;
    #endif
}

static void rs485_processBroadcastTx() {
    switch (rs485_state) {
        case RS485State::BROADCAST_MSGTYPE: {
            uint8_t msgtype = RS485_MSGTYPE_POLL;
            uart_write_bytes(RS485_UART_NUM, (const char*)&msgtype, 1);
            rs485_state = RS485State::BROADCAST_LENGTH;
            break;
        }
        
        case RS485State::BROADCAST_LENGTH: {
            uint8_t len = (uint8_t)rs485_txExportLen;
            uart_write_bytes(RS485_UART_NUM, (const char*)&len, 1);
            rs485_txExportIdx = 0;
            rs485_state = RS485State::BROADCAST_DATA;
            break;
        }
        
        case RS485State::BROADCAST_DATA: {
            // Non-blocking write - check TX buffer space
            size_t txFree = 0;
            uart_get_tx_buffer_free_size(RS485_UART_NUM, &txFree);
            
            while (rs485_txExportIdx < rs485_txExportLen && txFree > 1) {
                uart_write_bytes(RS485_UART_NUM, 
                                (const char*)&rs485_txExportData[rs485_txExportIdx], 1);
                rs485_txExportIdx++;
                txFree--;
            }
            
            if (rs485_txExportIdx >= rs485_txExportLen) {
                rs485_state = RS485State::BROADCAST_CHECKSUM;
            }
            break;
        }
        
        case RS485State::BROADCAST_CHECKSUM: {
            uart_write_bytes(RS485_UART_NUM, (const char*)&rs485_txChecksum, 1);
            rs485_state = RS485State::BROADCAST_WAIT_COMPLETE;
            break;
        }
        
        case RS485State::BROADCAST_WAIT_COMPLETE: {
            // Wait for TX to complete
            uart_wait_tx_done(RS485_UART_NUM, 1);
            
            #if RS485_POST_BROADCAST_DELAY_US > 0
            delayMicroseconds(RS485_POST_BROADCAST_DELAY_US);
            #endif
            
            rs485_state = RS485State::IDLE;
            break;
        }
        
        default:
            break;
    }
}

// ============================================================================
// POLL STATE MACHINE
// ============================================================================

static void rs485_startPoll(uint8_t addr) {
    rs485_currentPollAddr = addr;
    rs485_opStartUs = micros();
    
    // Send address byte (first byte of poll packet)
    uart_write_bytes(RS485_UART_NUM, (const char*)&addr, 1);
    rs485_state = RS485State::POLL_MSGTYPE;
    rs485_stats.pollCount++;
}

static void rs485_processPollTx() {
    switch (rs485_state) {
        case RS485State::POLL_MSGTYPE: {
            uint8_t msgtype = RS485_MSGTYPE_POLL;
            uart_write_bytes(RS485_UART_NUM, (const char*)&msgtype, 1);
            rs485_state = RS485State::POLL_LENGTH;
            break;
        }
        
        case RS485State::POLL_LENGTH: {
            // Poll packets have length=0 and NO checksum
            uint8_t len = 0;
            uart_write_bytes(RS485_UART_NUM, (const char*)&len, 1);
            rs485_state = RS485State::POLL_WAIT_COMPLETE;
            break;
        }
        
        case RS485State::POLL_WAIT_COMPLETE: {
            // Wait for TX to complete before switching to RX
            uart_wait_tx_done(RS485_UART_NUM, 1);
            
            // Reset RX state
            rs485_rxLen = 0;
            rs485_rxExpected = 0;
            rs485_rxMsgType = 0;
            
            // Start RX timeout from NOW
            rs485_opStartUs = micros();
            rs485_state = RS485State::RX_WAIT_LENGTH;
            break;
        }
        
        default:
            break;
    }
}

// ============================================================================
// RESPONSE STATE MACHINE
// ============================================================================

static void rs485_processRx() {
    size_t available = 0;
    uart_get_buffered_data_len(RS485_UART_NUM, &available);
    
    // Check for timeout if no data available
    if (available == 0) {
        uint32_t elapsed = micros() - rs485_opStartUs;
        
        // Use DUAL TIMEOUTS like Arduino library:
        // - Short timeout (1ms) when waiting for first byte (device not present)
        // - Long timeout (5ms) when waiting for rest of message (incomplete)
        uint32_t timeout;
        if (rs485_state == RS485State::RX_WAIT_LENGTH) {
            timeout = RS485_TIMEOUT_NO_DEVICE_US;
        } else {
            timeout = RS485_TIMEOUT_INCOMPLETE_US;
        }
        
        if (elapsed > timeout) {
            rs485_handleTimeout();
            rs485_advanceToNextSlave();
        }
        return;
    }
    
    // Data available - process it
    uint8_t byte;
    
    switch (rs485_state) {
        case RS485State::RX_WAIT_LENGTH: {
            uart_read_bytes(RS485_UART_NUM, &byte, 1, 0);
            rs485_rxExpected = byte;
            
            if (rs485_rxExpected == 0) {
                // Zero-length response = slave has no data
                rs485_rxLen = 0;
                rs485_handleResponse();
                rs485_advanceToNextSlave();
            } else {
                // Has data - wait for msgtype
                rs485_state = RS485State::RX_WAIT_MSGTYPE;
            }
            break;
        }
        
        case RS485State::RX_WAIT_MSGTYPE: {
            uart_read_bytes(RS485_UART_NUM, &byte, 1, 0);
            rs485_rxMsgType = byte;
            rs485_rxLen = 0;
            
            // Decrement expected count after reading MsgType
            // (Original working behavior - keep this!)
            rs485_rxExpected--;
            
            if (rs485_rxExpected == 0) {
                rs485_state = RS485State::RX_WAIT_CHECKSUM;
            } else {
                rs485_state = RS485State::RX_WAIT_DATA;
            }
            break;
        }
        
        case RS485State::RX_WAIT_DATA: {
            // Read available data bytes (non-blocking)
            while (available > 0 && rs485_rxLen < rs485_rxExpected) {
                if (rs485_rxLen >= sizeof(rs485_rxBuffer)) {
                    // Buffer overflow - stop reading
                    break;
                }
                uart_read_bytes(RS485_UART_NUM, &byte, 1, 0);
                rs485_rxBuffer[rs485_rxLen++] = byte;
                available--;
            }
            
            if (rs485_rxLen >= rs485_rxExpected) {
                rs485_state = RS485State::RX_WAIT_CHECKSUM;
            }
            break;
        }
        
        case RS485State::RX_WAIT_CHECKSUM: {
            uart_read_bytes(RS485_UART_NUM, &byte, 1, 0);
            
            // NOTE: Arduino slaves send hardcoded 0x72 as checksum
            // Arduino master doesn't validate it ("TODO: check checksum here")
            // We validate for robustness but don't reject on mismatch
            if (byte != RS485_SLAVE_CHECKSUM) {
                rs485_stats.checksumErrors++;
                #if !RS485_DEBUG_ERRORS_ONLY
                debugPrintf("[RS485] Checksum warning from slave %d: got 0x%02X, expected 0x%02X\n",
                           rs485_currentPollAddr, byte, RS485_SLAVE_CHECKSUM);
                #endif
            }
            
            rs485_handleResponse();
            rs485_advanceToNextSlave();
            break;
        }
        
        default:
            break;
    }
}

// ============================================================================
// PUBLIC API
// ============================================================================

bool RS485Master_init() {
    if (rs485_initialized) return true;
    
    debugPrintln("[RS485] Initializing RS-485 Master...");
    rs485_initPrevValues();
    
    // Configure UART
    uart_config_t uart_config = {
        .baud_rate = RS485_BAUD,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .rx_flow_ctrl_thresh = 0,
        .source_clk = UART_SCLK_DEFAULT,
    };
    
    esp_err_t err = uart_driver_install(RS485_UART_NUM, 256, 256, 0, NULL, 0);
    if (err != ESP_OK) {
        debugPrintf("[RS485] UART driver install failed: %d\n", err);
        return false;
    }
    
    err = uart_param_config(RS485_UART_NUM, &uart_config);
    if (err != ESP_OK) {
        debugPrintf("[RS485] UART param config failed: %d\n", err);
        return false;
    }
    
    err = uart_set_pin(RS485_UART_NUM, RS485_TX_PIN, RS485_RX_PIN, RS485_EN_PIN, UART_PIN_NO_CHANGE);
    if (err != ESP_OK) {
        debugPrintf("[RS485] UART set pin failed: %d\n", err);
        return false;
    }
    
    // Use ESP32's native RS-485 half-duplex mode
    // This automatically handles direction control via EN pin
    err = uart_set_mode(RS485_UART_NUM, UART_MODE_RS485_HALF_DUPLEX);
    if (err != ESP_OK) {
        debugPrintf("[RS485] RS-485 mode failed: %d\n", err);
        return false;
    }
    
    // Initialize slave tracking
    for (int i = 0; i < RS485_MAX_SLAVES; i++) {
        rs485_slaves[i] = {false, 0, 0, 0};
        rs485_consecutiveTimeouts[i] = 0;
        rs485_lastResponseTime[i] = 0;
        rs485_offlineReported[i] = false;
    }
    
    // Reset queues
    rs485_changeQueueHead = rs485_changeQueueTail = rs485_changeCount = 0;
    
    // Initialize state
    rs485_initialized = true;
    rs485_enabled = true;
    rs485_state = RS485State::IDLE;
    rs485_currentPollAddr = rs485_minPollAddr;
    rs485_broadcastPending = false;
    rs485_lastPollCompleteUs = micros();
    rs485_lastBroadcastMs = 0;
    rs485_expectTimeoutAfterData = 0;
    rs485_skipTimeoutsAfterBroadcast = 0;
    
    debugPrintf("[RS485] Init OK: %d baud, TX=%d, RX=%d, EN=%d\n",
                RS485_BAUD, RS485_TX_PIN, RS485_RX_PIN, RS485_EN_PIN);
    debugPrintf("[RS485] Poll range: %d-%d, Timeouts: %d/%d us\n", 
                rs485_minPollAddr, rs485_maxPollAddr,
                RS485_TIMEOUT_NO_DEVICE_US, RS485_TIMEOUT_INCOMPLETE_US);
    
    return true;
}

void RS485Master_loop() {
    if (!rs485_initialized || !rs485_enabled) return;
    
    // Don't poll unless DCS-BIOS is active
    if (!simReady()) return;
    
    // Periodic status print
    #if RS485_STATUS_INTERVAL_MS > 0
    static uint32_t lastStatusPrint = 0;
    if (millis() - lastStatusPrint > RS485_STATUS_INTERVAL_MS) {
        lastStatusPrint = millis();
        
        uint32_t totalPolls = rs485_stats.pollCount;
        uint32_t totalResp = rs485_stats.responseCount;
        float responseRate = totalPolls > 0 ? 100.0f * totalResp / totalPolls : 0;
        
        debugPrintf("[RS485] Polls=%lu Resp=%lu (%.1f%%) TO=%lu ExpTO=%lu Bcast=%lu Chg=%lu Cmd=%lu\n",
            totalPolls, totalResp, responseRate,
            rs485_stats.timeoutCount, rs485_stats.expectedTimeouts,
            rs485_stats.broadcastCount, rs485_stats.changesDetected,
            rs485_stats.inputCmdCount);
    }
    #endif
    
    // Main state machine
    switch (rs485_state) {
        case RS485State::IDLE: {
            // Decide: broadcast or poll?
            bool canBroadcast = rs485_broadcastPending && rs485_changeCount > 0;
            
            #ifdef RS485_DISABLE_BROADCASTS
            canBroadcast = false;
            rs485_changeCount = 0;
            #endif
            
            #if RS485_MIN_BROADCAST_INTERVAL_MS > 0
            if (canBroadcast && (millis() - rs485_lastBroadcastMs < RS485_MIN_BROADCAST_INTERVAL_MS)) {
                canBroadcast = false;
            }
            #endif
            
            if (canBroadcast) {
                rs485_startBroadcast();
            } else {
                rs485_broadcastPending = false;
                rs485_startPoll(rs485_currentPollAddr);
            }
            break;
        }
        
        // Broadcast TX states
        case RS485State::BROADCAST_MSGTYPE:
        case RS485State::BROADCAST_LENGTH:
        case RS485State::BROADCAST_DATA:
        case RS485State::BROADCAST_CHECKSUM:
        case RS485State::BROADCAST_WAIT_COMPLETE:
            rs485_processBroadcastTx();
            break;
        
        // Poll TX states
        case RS485State::POLL_MSGTYPE:
        case RS485State::POLL_LENGTH:
        case RS485State::POLL_WAIT_COMPLETE:
            rs485_processPollTx();
            break;
        
        // RX states
        case RS485State::RX_WAIT_LENGTH:
        case RS485State::RX_WAIT_MSGTYPE:
        case RS485State::RX_WAIT_DATA:
        case RS485State::RX_WAIT_CHECKSUM:
            rs485_processRx();
            break;
        
        default:
            // Invalid state - reset to IDLE
            rs485_state = RS485State::IDLE;
            break;
    }
}

void RS485Master_feedExportData(const uint8_t* data, size_t len) {
    if (!rs485_initialized) return;
    
    #ifdef RS485_DISABLE_BROADCASTS
    (void)data; (void)len;
    return;
    #endif
    
    if (!rs485_prevInitialized) {
        rs485_initPrevValues();
    }
    
    // Parse export stream for changes
    for (size_t i = 0; i < len; i++) {
        rs485_parseChar(data[i]);
    }
}

void RS485Master_forceFullSync() {
    rs485_initPrevValues();  // Reset all tracking to 0xFFFF
    rs485_broadcastPending = true;
    debugPrint("[RS485] Forced full sync\n");
}

void RS485Master_setPollingRange(uint8_t minAddr, uint8_t maxAddr) {
    rs485_minPollAddr = constrain(minAddr, 1, RS485_MAX_SLAVES);
    rs485_maxPollAddr = constrain(maxAddr, rs485_minPollAddr, RS485_MAX_SLAVES);
    rs485_currentPollAddr = rs485_minPollAddr;
    debugPrintf("[RS485] Poll range: %d-%d\n", rs485_minPollAddr, rs485_maxPollAddr);
}

void RS485Master_setEnabled(bool enabled) {
    rs485_enabled = enabled;
    debugPrintf("[RS485] %s\n", enabled ? "Enabled" : "Disabled");
}

bool RS485Master_isSlaveOnline(uint8_t address) {
    if (address < 1 || address > RS485_MAX_SLAVES) return false;
    return rs485_slaves[address - 1].online;
}

uint8_t RS485Master_getOnlineSlaveCount() {
    uint8_t count = 0;
    for (uint8_t i = rs485_minPollAddr; i <= rs485_maxPollAddr; i++) {
        if (rs485_slaves[i - 1].online) count++;
    }
    return count;
}

const MasterStats* RS485Master_getStats() {
    return &rs485_stats;
}

void RS485Master_printStatus() {
    debugPrintln("\n========== RS-485 MASTER STATUS ==========");
    
    float responseRate = rs485_stats.pollCount > 0 
        ? 100.0f * rs485_stats.responseCount / rs485_stats.pollCount 
        : 0;
    
    debugPrintf("Polls: %lu, Responses: %lu (%.1f%%)\n",
                rs485_stats.pollCount, rs485_stats.responseCount, responseRate);
    debugPrintf("Timeouts: %lu real, %lu expected\n", 
                rs485_stats.timeoutCount, rs485_stats.expectedTimeouts);
    debugPrintf("Broadcasts: %lu, Changes: %lu, Bytes: %lu\n",
                rs485_stats.broadcastCount, rs485_stats.changesDetected, 
                rs485_stats.exportBytesSent);
    debugPrintf("Input commands: %lu, Checksum warnings: %lu\n",
                rs485_stats.inputCmdCount, rs485_stats.checksumErrors);
    debugPrintf("Poll cycles: %lu, Queue overflows: %lu\n",
                rs485_stats.pollCycles, rs485_stats.framesSkipped);
    
    // Per-slave status
    debugPrintln("Slave status:");
    for (uint8_t i = rs485_minPollAddr; i <= rs485_maxPollAddr; i++) {
        SlaveStatus& s = rs485_slaves[i - 1];
        if (s.responseCount > 0 || s.timeoutCount > 0) {
            debugPrintf("  [%d] %s - Resp: %lu, TO: %lu, LastRTT: %lu us\n",
                       i, s.online ? "ONLINE" : "OFFLINE",
                       s.responseCount, s.timeoutCount, s.lastResponseUs);
        }
    }
    
    debugPrintln("==========================================\n");
}

#endif // RS485_MASTER_ENABLED
