/**
 * @file RS485Config.h
 * @brief RS-485 Master Configuration for CockpitOS
 * @version 2.0 - Complete rewrite with bare-metal UART and ISR-driven RX
 *
 * To enable RS-485 master mode, add to Config.h:
 *   #define RS485_MASTER_ENABLED 1
 *
 * ==========================================================================
 * OPERATING MODES
 * ==========================================================================
 *
 * RS485_SMART_MODE selects the fundamental operating mode:
 *
 *   ┌─────────────────────────────────────────────────────────────────────┐
 *   │ SMART_MODE=1 (default) - Intelligent Filtered Broadcasting         │
 *   ├─────────────────────────────────────────────────────────────────────┤
 *   │ • Parses DCS-BIOS stream, extracts address/value pairs             │
 *   │ • Filters by DcsOutputTable (only addresses your slaves need)      │
 *   │ • Change detection reduces bandwidth by 100-1000x                  │
 *   │ • Reconstructs valid DCS-BIOS frames for broadcast                 │
 *   │ • Best for production with known panel configurations              │
 *   │ • Uses: 32KB RAM for change tracking + change queue                │
 *   └─────────────────────────────────────────────────────────────────────┘
 *
 *   ┌─────────────────────────────────────────────────────────────────────┐
 *   │ SMART_MODE=0 - Raw Relay Mode (Arduino-compatible)                 │
 *   ├─────────────────────────────────────────────────────────────────────┤
 *   │ • Raw byte relay, exactly like Arduino Mega master                 │
 *   │ • NO parsing, NO filtering - bytes in, bytes out                   │
 *   │ • Works with ANY sim, ANY aircraft, ANY address                    │
 *   │ • Use for debugging or when you don't know addresses yet           │
 *   │ • Uses: 512 bytes RAM (minimal!)                                   │
 *   └─────────────────────────────────────────────────────────────────────┘
 *
 * ==========================================================================
 * ARCHITECTURE: Bare-Metal UART with ISR-Driven RX
 * ==========================================================================
 *
 * This implementation uses direct hardware register access for maximum
 * performance and minimum latency:
 *
 *   • periph_module_enable() for UART clock
 *   • uart_ll_* functions for direct register manipulation
 *   • esp_intr_alloc() for RX interrupt with FIFO threshold of 1
 *   • No ESP-IDF uart_driver overhead
 *   • No blocking calls in the hot path
 *   • RISC-V memory barriers for ESP32-C3/C6 cache coherency
 *
 * ==========================================================================
 */

#ifndef RS485_CONFIG_H
#define RS485_CONFIG_H

// ============================================================================
// OPERATING MODE
// ============================================================================
// 1 = SMART MODE: Parse + filter by DcsOutputTable + change detect + rebuild frames
//     Best bandwidth, requires CockpitOS label set configuration
//
// 0 = RELAY MODE: Raw byte pump like Arduino Mega master
//     Maximum compatibility, works without any configuration
//
#ifndef RS485_SMART_MODE
#define RS485_SMART_MODE        1
#endif

// ============================================================================
// SMART MODE OPTIONS (only apply when SMART_MODE=1)
// ============================================================================
#if RS485_SMART_MODE

// Change detection (delta compression)
// 1 = Only broadcast changed values (recommended - huge bandwidth savings)
// 0 = Broadcast all filtered values every frame (rarely useful)
#ifndef RS485_CHANGE_DETECT
#define RS485_CHANGE_DETECT     1
#endif

// Change queue size (address/value pairs)
// Each entry = 4 bytes RAM, each change on wire = ~10 bytes
#ifndef RS485_CHANGE_QUEUE_SIZE
#define RS485_CHANGE_QUEUE_SIZE 128
#endif

// Maximum bytes per broadcast chunk
// Larger = more efficient, smaller = more responsive polling
#ifndef RS485_MAX_BROADCAST_CHUNK
#define RS485_MAX_BROADCAST_CHUNK 64
#endif

#endif // RS485_SMART_MODE

// ============================================================================
// RELAY MODE OPTIONS (only apply when SMART_MODE=0)
// ============================================================================
#if !RS485_SMART_MODE

// Ring buffer size for raw export data
// 512 bytes = ~2 full DCS-BIOS frames
#ifndef RS485_RAW_BUFFER_SIZE
#define RS485_RAW_BUFFER_SIZE   512
#endif

// Maximum bytes per broadcast in relay mode
#ifndef RS485_RELAY_CHUNK_SIZE
#define RS485_RELAY_CHUNK_SIZE  128
#endif

#endif // !RS485_SMART_MODE

// ============================================================================
// HARDWARE PINS
// ============================================================================
//
// OPTION 1: Built-in RS485 transceiver (Waveshare ESP32-S3-RS485-CAN, etc.)
//   TX = GPIO17, RX = GPIO18, DE = GPIO21
//   Set RS485_DE_PIN to the board's direction control pin
//
// OPTION 2: External MAX485 with manual direction control
//   ESP32 TX -> MAX485 DI
//   ESP32 RX <- MAX485 RO
//   ESP32 GPIO -> MAX485 DE+RE (tied together)
//   Set RS485_DE_PIN to the GPIO controlling DE/RE
//
// OPTION 3: Auto-direction RS485 module
//   These boards automatically switch TX/RX direction.
//   Only TX and RX pins needed - no direction control!
//   Set RS485_DE_PIN to -1 (auto-direction mode)
//

#ifndef RS485_TX_PIN
#define RS485_TX_PIN            17
#endif

#ifndef RS485_RX_PIN
#define RS485_RX_PIN            18
#endif

// Direction control pin:
//   >= 0 : GPIO number for manual DE control (directly driven, not via UART hardware)
//   -1   : Auto-direction hardware (no pin needed)
#ifndef RS485_DE_PIN
#define RS485_DE_PIN            -1
#endif

// UART number (1 or 2 - UART0 is typically used for USB/debug)
#ifndef RS485_UART_NUM
#define RS485_UART_NUM          1
#endif

// ============================================================================
// PROTOCOL SETTINGS
// ============================================================================

#ifndef RS485_BAUD
#define RS485_BAUD              250000  // Must match all devices on bus
#endif

// Poll timeout (microseconds) - how long to wait for slave response
#ifndef RS485_POLL_TIMEOUT_US
#define RS485_POLL_TIMEOUT_US   2000
#endif

// Maximum microseconds between polls (controls broadcast chunk timing)
#ifndef RS485_MAX_POLL_INTERVAL_US
#define RS485_MAX_POLL_INTERVAL_US 2000
#endif

// ============================================================================
// SLAVE DISCOVERY & POLLING
// ============================================================================

// Maximum slave address to poll (valid range: 1-127)
// Set to your actual highest slave address for faster polling
#ifndef RS485_MAX_SLAVE_ADDRESS
#define RS485_MAX_SLAVE_ADDRESS 32
#endif

// Discovery scan interval (how often to probe for new slaves)
// Every N poll cycles, scan one unknown address
#ifndef RS485_DISCOVERY_INTERVAL
#define RS485_DISCOVERY_INTERVAL 50
#endif

// ============================================================================
// BUFFER SIZES
// ============================================================================

// Buffer for slave input commands (switch/encoder strings from slaves)
#ifndef RS485_INPUT_BUFFER_SIZE
#define RS485_INPUT_BUFFER_SIZE 64
#endif

// RX ring buffer size (ISR writes, loop reads)
#ifndef RS485_RX_BUFFER_SIZE
#define RS485_RX_BUFFER_SIZE    256
#endif

// ============================================================================
// DEBUG OPTIONS
// ============================================================================

// Log every poll/response (VERY verbose - for debugging only)
#ifndef RS485_DEBUG_VERBOSE
#define RS485_DEBUG_VERBOSE     0
#endif

// Log only errors (suppresses normal status messages)
#ifndef RS485_DEBUG_ERRORS_ONLY
#define RS485_DEBUG_ERRORS_ONLY 0
#endif

// Status print interval (milliseconds, 0 = disabled)
#ifndef RS485_STATUS_INTERVAL_MS
#define RS485_STATUS_INTERVAL_MS 10000
#endif

#endif // RS485_CONFIG_H
