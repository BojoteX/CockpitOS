
// ============================================================================
// 
//
//
//
// *** DO NOT EDIT THIS FILE! *** Run Setup-START.py instead ***
//
//
//
//
// ============================================================================

// Config.h - Configuration file for CockpitOS

#pragma once          

// ==============================================================================================================
// IMPORTANT: Before compiling, make sure to run the auto-generator script for the LABEL SET you intend to use.
// Simply navigate to the CockpitOS/src/LABELS directory, enter the desired LABEL SET folder, and run the
// "generate_data.py" script located there. After running the auto-generator, that set will become the default.
// ==============================================================================================================

// Versioning for internal use
#define VERSION_CURRENT        "R.1.2.1_dev_02-28-26" // Just to troubleshoot instalations

// Your personal Wi-Fi network credentials should be stored in .credentials/wifi.h. If file wifi.h not found or does not exists yet, we use defaults ("TestNetwork" / "TestingOnly")
#if __has_include(".credentials/wifi.h")
  #include ".credentials/wifi.h"                      // We store out credentials for Wi-Fi here (if file does NOT exists or is not created we use defaults above)
#else
  #define WIFI_SSID                     "TestNetwork" // Use a hotspot for local testing and debugging, but for production use your regular WiFi if you plan to enable USE_DCSBIOS_WIFI
  #define WIFI_PASS                     "TestingOnly" // Make sure your Wi-Fi router supports WPA2-PSK (AES/CCMP), otherwise, device will not connect *** THIS IS VERY IMPORTANT ***. ESP32s will Connect to 2.4 GHz and WPA2-PSK (AES/CCMP) capable routers ONLY so make sure yours supports these requirements.
#endif

//
#define MODE_DEFAULT_IS_HID                         0 // Is HID mode default? (This should almost always be 0). Only enable if you want your device to send Input buttons/axes at the OS level. This is so you can use the device with other simulators (Inputs only)

// Is this an RS-485 Master? leave to 0 for normal operation.
#define RS485_MASTER_ENABLED                        0 // Set as RS-485 Master. Polls slaves. Forwards data, you still need to choose a transport above (WiFi, Serial, USB etc)

// Here is where you tell the firmware which 'transport' will be used to Communicate with the simulator (only ONE can be selected). 
// Bluetooth BLE, Pure Native USB, WIFI, Serial (CDC/Socat) or as an RS485 slave. ** Only ONE ** can be active 
#define USE_DCSBIOS_BLUETOOTH                       0 // *INTERNAL USE ONLY* (Not included in Open Source version of CockpitOS) (Works on ALL ESP32s except S2s and some P4s).
#define USE_DCSBIOS_WIFI                            0 // WiFi DCS transport (Works on all ESP32 except H2s abd P4s that lack WiFi radios) 
#define USE_DCSBIOS_USB                             1 // Completely bypasses socat and uses USB to connect to DCS. You need to run the CockpitOS Companion app on the host PC for this to work. (Works on S2s, S3s & P4s Only). S3s & P4s require Tools menu "USB Mode" set to USB-OTG (TinyUSB)
#define USE_DCSBIOS_SERIAL                          0 // LEGACY - Requires socat for this to work. (ALL ESP32 Devices supported). Also used for Stream Replay
#define RS485_SLAVE_ENABLED                         0 // Set as RS-485 Slave, you need to also run a master RS485 on a separate device

// RS485 *** [ Slave ] *** (Only if RS485_SLAVE_ENABLED is set to 1)
#define RS485_SLAVE_ADDRESS                         2 // This is the Slave addres ID! Only use when RS485_SLAVE_ENABLED (above) is set to 1. Choose a device address between (1-126) each slave should have a unique address
#define RS485_TX_PRE_DE_DELAY_US                   40 // AVR slave sends a phantom 0x00 byte (~40us) with DE low before responding — without this delay the ESP32 responds before the AVR master exits its TXC ISR, causing UDR overrun

// RS485 *** [ Master ] *** (Option only work when RS485_MASTER_ENABLED is set to 1)
#define RS485_SMART_MODE                            0 // If enabled, filters by DcsOutputTable (only addresses your slaves need). see selected_panels.txt in your panel LABEL SET. 
#define RS485_MAX_SLAVE_ADDRESS                    32 // Maximum slave address to poll (valid range: 1-127).        

// RS485 *** General Setting *** 
#define RS485_TX_WARMUP_DELAY_US                    0 // Manual DE: delay after DE assert before TX
#define RS485_TX_WARMUP_AUTO_DELAY_US               0 // Auto-direction: delay before TX (internal RX→TX switch)

// RS485 *** Advanced CPU Core management *** 
#define RS485_USE_TASK                              1 // 0 = runs in loop() (best for WiFi). 1 = dedicated FreeRTOS task (best for USB/Serial/BLE)
#define RS485_TASK_CORE                             0 // Only relevant/used when RS485_USE_TASK is set to 1 (see above). 0 = Core 0 (ideal when no WiFi). 1 = Core 1 (shares with loop). Ignored on single-core chips

// *** READ THIS *** (Advanced users only)
// TinyUSB + Wi-Fi enabled at the same time consume a LOT of memory, so if you decide to enable debugging (below) on S2 devices keep that in mind as compiles will most likely fail if both the WiFi stack (for debug or normal operation) is enabled along USB-OTG (TinyUSB). To avoid, simply use an S3 device or stick to the stack capabilities (e.g) Debug via Serial if using USB or Debug via WiFi if using WiFi as transport.  

// For production, ALL THESE should be set to 0. Use for debugging only.
#define DEBUG_ENABLED                               0 // Use it ONLY when identifying issues or troubleshooting. Not required when using VERBOSE modes below
#define DEBUG_PERFORMANCE                           0 // Shows profiling for specific tasks and memory usage for debug and troubleshooting.
#define VERBOSE_MODE                                0 // Verbose will output to both WiFi & Serial (Uses a LOT of Memory, might fail compile on S2 devices).
#define VERBOSE_MODE_SERIAL_ONLY                    0 // Verbose will only output to Serial. 
#define VERBOSE_MODE_WIFI_ONLY                      0 // Verbose will only output to WiFi.
#define VERBOSE_PERFORMANCE_ONLY                    0 // This will output perf snapshots ONLY, make sure you pick VERBOSE_MODE_SERIAL_ONLY or VERBOSE_MODE_WIFI_ONLY so that we know where to output those snapshot ONLY messages.
#define DEBUG_PERFORMANCE_SHOW_TASKS                0 // Includes the current task list with the snapshot. Not really needed.
#define DEBUG_LISTENERS_AT_STARTUP                  0 // Debug Listeners for ADVANCED troubleshooting! usually not needed.
#define RS485_DEBUG_VERBOSE                         0 // 1 = Log every poll/response (VERY verbose). 0 = Normal operation
#define RS485_STATUS_INTERVAL_MS                60000 // How many milliseconds between each stats banner (60000 = 60 secs = 1 min)
#define PERFORMANCE_SNAPSHOT_INTERVAL_SECONDS      60 // Interval between snapshots (in seconds)

// Key scanning
#define DEBUG_ENABLED_FOR_PCA_ONLY                  0  // Use it ONLY when mapping Port/bit/mask in PCA9xxx devices
#define DEBUG_ENABLED_FOR_HC165_ONLY                0  // Use it ONLY when mapping bits in HC165 devices
#define DEBUG_ENABLED_FOR_TM1637_ONLY               0  // Use ONLY when mapping TM1637 keys

// Panel specific Axis config features 
#define MIDDLE_AXIS_THRESHOLD                      64 // Adjust if your Middle Axis won't stick to center (optimal should be 32-64) but noisy axes require 128-256
#define UPPER_AXIS_THRESHOLD                      128 // Adjust if your Upper Axis won't stick to max (optimal should be 32-64) but noisy axes require 128-256
#define LOWER_AXIS_THRESHOLD                      256 // Adjust if your Lower Axis won't stick to min (optimal should be 32-64) but noisy axes require 128-256
#define CENTER_DEADZONE_INNER                     256 // Entry threshold — easy to enter
#define CENTER_DEADZONE_OUTER                     384 // Exit threshold — must move further to escape
#define AX_DEFAULT_MIN                            768 // Assumed worst min for an axis (it will expand as you move the knob and it will be NVS saved). Use 4095 for ABSOLUTE learning from scratch
#define AX_DEFAULT_MAX                           3327 // Assumed worst max for an axis (it will expand as you move the knob and it will be NVS saved). Use 0 for ABSOLUTE learning from scratch

// Advanced config, these settings have been carefully tuned for performance and stability, 
#define TEST_LEDS                                   0 // Interactive menu (via serial console) to test LEDs individually
#define IS_REPLAY                                   0 // Simulate a loopback DCS stream to check your panel is working and debug via Serial
#define USE_WIRE_FOR_I2C                            1 // If set to 1 uses the Arduino compatible I2C Wire Library (slow). Use 0 for Faster alternative
#define PCA_FAST_MODE                               1 // Set to 1 to enable 400kHz PCA Bus FAST MODE
#define SERIAL_RX_BUFFER_SIZE                    4096 // This is the INCOMING buffer for DCS Data (in bytes) when using CDC / Serial. Must exceed largest DCS-BIOS frame (Apache: 1954B)
#define SERIAL_TX_TIMEOUT                           5 // in ms (Used for CDC receive stream timeouts)
#define HID_SENDREPORT_TIMEOUT                      5 // in ms (Only used with ESP32 Arduino Core HID.SendReport implementation)
#define CDC_TIMEOUT_RX_TX                           5 // in ms (Only used with CDC/Serial health checks)
#define STARTUP_WATCHDOG_TIMEOUT_MS             30000 // Startup watchdog - enters bootloader if main loop not reached within timeout (30 seconds)
#define DCS_UPDATE_RATE_HZ                         30 // DCSBIOS Loop update rate (used for DCS Keepalives, if enabled)
#define HID_REPORT_RATE_HZ                        250 // HID report sending rate in Hz. (used for HID Keepalives, if enabled)
#define POLLING_RATE_HZ                           250 // Panel/buttons update rate in Hz (125, 250, 500 Hz) during main loop. Leave at 250
#define DISPLAY_REFRESH_RATE_HZ                    60 // General refresh rate used for displays.  
#define DCS_KEEP_ALIVE_ENABLED                      0 // Should we enable DCSBIOS Keepalives? should ONLY used for testing
#define HID_KEEP_ALIVE_ENABLED                      0 // Should we enable HID Keepalives? should ONLY used for testing
#define MAX_TRACKED_RECORDS                       512 // default safety cap, DO NOT change
#define MAX_GROUPS                                128 // default safety cap, DO NOT change
#define VALUE_THROTTLE_MS                          50 // How long (ms) to skip sending the same value again (debouncing)
#define ANY_VALUE_THROTTLE_MS                      33 // How long (ms) to skip sending different values (prevents spamming the USB endpoint, while debouncing at the same time)
#define CUSTOM_RESPONSE_THROTTLE_MS               100 // Min delay (ms) between press and deferred release for custom momentaries with releaseValue != 0
#define SELECTOR_DWELL_MS                         100 // Wait time (in ms) for stable selector value. Used by our dwell-time fitering logic
#define DCS_GROUP_MIN_INTERVAL_US                (1000000UL / DCS_UPDATE_RATE_HZ) // min spacing/separation between selector positions
#define HID_REPORT_MIN_INTERVAL_US               (1000000UL / HID_REPORT_RATE_HZ) // min spacing/separation between reports
#define DCS_KEEP_ALIVE_MS                        (1000 / DCS_UPDATE_RATE_HZ) // send PING 0 (ASCII command) every x ms (when using keep-alives)
#define HID_KEEP_ALIVE_MS                        (1000 / HID_REPORT_RATE_HZ) // send HID command every x ms (when using keep-alives)
#define MAX_SELECTOR_GROUPS                       128 // Max supported selector groups
#define MAX_PCA_GROUPS                            128 // Max PCA selector groups
#define MAX_PCA9555_INPUTS                         64 // Max PCA input mappings
#define MAX_PCAS                                    8 // Max PCA9555 chips (0x20–0x27)
#define MAX_PENDING_UPDATES                       220 // Do not modify Unless doing heavy customizations
#define STREAM_TIMEOUT_MS                        1000 // ms without activity → consider dead
#define MAX_REGISTERED_DISPLAY_BUFFERS             64 // Do not modify Unless doing heavy customizations
#define MAX_VALIDATED_SELECTORS                    32 // Tune to match maximum selectors you need to track
#define MISSION_START_DEBOUNCE                    500 // ms to wait before panel sync
#define GAMEPAD_REPORT_SIZE                        64 // Must match the HID descriptor, you should NEVER have to change this.
#define SERVO_UPDATE_FREQ_MS                       20 // For Analog servo instruments. Update rate in ms (as per servo specs)
#define SKIP_ANALOG_FILTERING                       0 // Applies to HID Only, Set to 1 to skip all filtering for Min latency
#define ADVANCED_TM1637_INPUT_FILTERING             0 // Enable it if you see ghosts with TM1637 inputs
#define SUPRESS_REBOOT_VIA_CDC                      0 // Enabling this sets Serial.enableReboot(false) so device can NOT be reset via CDC
#define SEND_HID_AXES_IN_DCS_MODE                   0 // Sends HID Axes even if DCS Mode is active
#define SCAN_WIFI_NETWORKS                          0 // For debugging and see what networks the device sees (this outputs to Serial interface ONLY, as it can't output to WiFi if it has not connected yet)
#define UDP_MAX_SIZE                             1460 // Max size for UDP packets (safe for DCS-BIOS UDP communication, which is usually well below this limit)
#define DCSBIOS_USE_LITE_VERSION                    1 // Set to 1 to use a LITE (local) version of the DCSBIOS Library. 0 Uses the Original unmodified Library (you'll need to install it)

// Serial Debug Ring Buffer
#define SERIAL_DEBUG_USE_RINGBUFFER                 0 // Should be use a ring buffer for Serial Debug messages? not really necessary
#if SERIAL_DEBUG_USE_RINGBUFFER                    
  #define SERIAL_RINGBUF_SIZE                      64 // How many slots in our buffer
  #define SERIAL_MSG_MAXLEN                        64 // Max size for each slot
#else
  #define SERIAL_RINGBUF_SIZE                       0 // How many slots in our buffer
  #define SERIAL_MSG_MAXLEN                      1024 // Max size for each slot
#endif

// WiFi Debug Ring Buffer 
#define WIFI_DEBUG_USE_RINGBUFFER                   1 // Should be use a ring buffer for WiFi Debug messages? helps when using WiFi DCS Mode. If WiFi is not used, this value is ignored anyway. Also, if using CDC + WiFi Debug, this is REQUIRED to avoid CDC stalls
#if WIFI_DEBUG_USE_RINGBUFFER
  #define WIFI_DBG_SEND_RINGBUF_SIZE               16 // How many slots in our buffer
  #define WIFI_DBG_MSG_MAXLEN                      64 // Max size for each slot
#else
  #define WIFI_DBG_SEND_RINGBUF_SIZE                0 // How many slots in our buffer
  #define WIFI_DBG_MSG_MAXLEN            UDP_MAX_SIZE // Max size for each slot
#endif

// DCS Commands USB Send Ring Buffer (outgoing packets) - *MANDATORY* this one is REQUIRED to be set to send via USB pipe for transport (due to 64 byte report size limitation)
#define DCS_USB_RINGBUF_SIZE                     32  // Number of packets buffered (tune as needed) 32 is optimal, 64 for slow devices (hosts) so we make queue deep
#define DCS_USB_PACKET_MAXLEN   GAMEPAD_REPORT_SIZE  // Max USB packet size safe for DCS-BIOS (to match HID report size)

// DCS UDP/USB Receive Ring Buffer (incoming packets) - *MANDATORY* when using USB mode, optional in WiFi UDP mode.
#define MAX_UDP_FRAMES_PER_DRAIN                  1  // Max number to hold in buffer before parsing (increase for bursty processing) 1 is deterministic, best.

#if USE_DCSBIOS_USB
  #define DCS_USE_RINGBUFFER                      1  // Should ALWAYS be 1 when USE_DCSBIOS_USB. DO NOT CHANGE 
  #define DCS_UDP_RINGBUF_SIZE                   32  // Number of USB packets buffered (tune as needed) 64 is optimal
  #define DCS_UDP_PACKET_MAXLEN GAMEPAD_REPORT_SIZE  // Should ALWAYS be 64 when USE_DCSBIOS_USB (to match HID report size)
#else // Used for incoming DCS stream via WiFi UDP (if enabled) 
  #if USE_DCSBIOS_WIFI || USE_DCSBIOS_BLUETOOTH
    #define DCS_USE_RINGBUFFER                    1  // Enforces WiFi/BLE use of a ring buffer for the incoming DCS Stream data (otherwise it will crash)
    #define DCS_UDP_RINGBUF_SIZE                 32  // Number of UDP packets buffered (reduced from 64: larger slots need fewer entries)
    #define DCS_UDP_PACKET_MAXLEN               128  // Match full UDP frame size — eliminates multi-chunk ring buffer splits and the cross-core race they cause
  #else 
    #define DCS_USE_RINGBUFFER                    0  // No need for it as Wi-Fi/BLE for DCS-BIOS is not active.
    #define DCS_UDP_RINGBUF_SIZE                  0  // Number of BLE packets buffered (tune as needed)
    #define DCS_UDP_PACKET_MAXLEN      UDP_MAX_SIZE  // Max BLE packet size (safe for Incoming BLE from DCS-BIOS)
  #endif
#endif

// Misc buffer sizes (Do not modify) this has been tweaked for max performance/througput.
#define TASKLIST_LINE_GENERAL_TMP_BUFFER        128 // DO NOT EXCEED 128, used by tasklist individual line printing
#define DEBUGPRINTF_GENERAL_TMP_BUFFER          256 // Buffer size for DEBUG out Serial messages when using DebugPrintf
#define SERIAL_DEBUG_BUFFER_SIZE                256 // Buffer size for DEBUG out Serial messages when using serialDebugPrintf
#define WIFI_DEBUG_BUFFER_SIZE                  256 // Buffer size for DEBUG out WiFi messages when using wifiDebugPrintf
#define UDP_TMPBUF_SIZE                UDP_MAX_SIZE // UDP Out Temp buffer
#define PERF_TMPBUF_SIZE                       1024 // Temp Buffer size for Performance Append logic
#define SERIAL_DEBUG_FLUSH_BUFFER_SIZE         2048 // Big enough for your largest full message (tune as needed)

#define SERIAL_DEBUG_OUTPUT_CHUNK_SIZE           64 // Final Serial.write will use this value to chunk writes
#define DCS_UDP_MAX_REASSEMBLED        UDP_MAX_SIZE // Or whatever max UDP/Frame size you want

// Stringize helpers (undef to override any framework defaults)
#undef _STR
#undef STR
#define _STR(x) #x
#define STR(x)  _STR(x)
// String form for text macros
#define LABEL_SET_STR STR(LABEL_SET)

// Required for Descriptor handling. For custom commercial implementations using your own name (you are free to do so), just by mindful of PID, VID, Manufacturer and the actual USB_PRODUCT string. No need for attribution, you can use this software as per the included LICENSE
#undef USB_VID
#undef USB_PID
#define USB_VID		                           0xCAFE // If you change this, make sure you also update the Python script settings.ini file
#define USB_PID		                           AUTOGEN_USB_PID
#undef USB_SERIAL
#undef USB_PRODUCT
#undef USB_MANUFACTURER
#define USB_SERIAL                           LABEL_SET_STR
#define USB_PRODUCT                          USB_SERIAL
#define USB_MANUFACTURER                     "CockpitOS"
#define USB_LANG_ID                          0x0409  // English (US)

#if USE_DCSBIOS_WIFI && !DCS_USE_RINGBUFFER
  #error "Invalid config: DCS_USE_RINGBUFFER must be 1 when USE_DCSBIOS_WIFI is enabled."
#endif

// Automatically enables what we'll be using, no need to edit.
#if (ARDUINO_USB_CDC_ON_BOOT == 1)
  #define CONFIG_TINYUSB_CDC_ENABLED                1
  #define CONFIG_TINYUSB_CDC_MAX_PORTS              2  
#else
  #define CONFIG_TINYUSB_CDC_ENABLED                1
  #define CONFIG_TINYUSB_CDC_MAX_PORTS              2
#endif

// Advanced TinyUSB Config Options (undef first to override framework defaults).
#undef CFG_TUSB_DEBUG
#undef CONFIG_TINYUSB_CDC_RX_BUFSIZE
#undef CONFIG_TINYUSB_CDC_TX_BUFSIZE
#undef CONFIG_TINYUSB_HID_BUFSIZE
#undef CONFIG_TINYUSB_MSC_ENABLED
#undef CONFIG_TINYUSB_HID_ENABLED
#undef CONFIG_TINYUSB_MIDI_ENABLED
#undef CONFIG_TINYUSB_VIDEO_ENABLED
#undef CONFIG_TINYUSB_CUSTOM_CLASS_ENABLED
#undef CONFIG_TINYUSB_DFU_RT_ENABLED
#undef CONFIG_TINYUSB_DFU_ENABLED
#undef CONFIG_TINYUSB_VENDOR_ENABLED
#undef CONFIG_TINYUSB_NCM_ENABLED
#define CFG_TUSB_DEBUG                             0  // Enabled TinyUSB debugging
#define CONFIG_TINYUSB_CDC_RX_BUFSIZE             64
#define CONFIG_TINYUSB_CDC_TX_BUFSIZE             64
#define CONFIG_TINYUSB_HID_BUFSIZE                64
#define CONFIG_TINYUSB_MSC_ENABLED                0
#define CONFIG_TINYUSB_HID_ENABLED                1
#define CONFIG_TINYUSB_MIDI_ENABLED               0
#define CONFIG_TINYUSB_VIDEO_ENABLED              0
#define CONFIG_TINYUSB_CUSTOM_CLASS_ENABLED       0
#define CONFIG_TINYUSB_DFU_RT_ENABLED             0
#define CONFIG_TINYUSB_DFU_ENABLED                0
#define CONFIG_TINYUSB_VENDOR_ENABLED             0
#define CONFIG_TINYUSB_NCM_ENABLED                0

// --- Sanity guard: only one transport can be enabled at a time ---
#if ( (USE_DCSBIOS_BLUETOOTH + USE_DCSBIOS_WIFI + USE_DCSBIOS_USB + USE_DCSBIOS_SERIAL + RS485_SLAVE_ENABLED) != 1 )
  #error "Invalid config: Exactly ONE transport must be enabled"
#endif

#if RS485_MASTER_ENABLED && RS485_SLAVE_ENABLED
  #error "❌ Cannot be both RS485 Master and Slave - pick one role"
#endif

#if RS485_MASTER_ENABLED && !(USE_DCSBIOS_BLUETOOTH || USE_DCSBIOS_WIFI || USE_DCSBIOS_USB || USE_DCSBIOS_SERIAL)
  #error "❌ RS485_MASTER_ENABLED requires a transport (WiFi, USB, Serial, or Bluetooth)"
#endif

#if (ARDUINO_USB_CDC_ON_BOOT == 1)
  #error "❌ Invalid config: Set 'USB CDC On Boot' to 'Disabled' (see Tools menu in Arduino IDE)."
#endif

// Works across all boards of the same chip family
#if defined(CONFIG_IDF_TARGET_ESP32C3)
  #define ESP_FAMILY_C3 1
  #define DEVICE_HAS_HWSERIAL 1
#elif defined(CONFIG_IDF_TARGET_ESP32C6)
  #define ESP_FAMILY_C6 1
  #define DEVICE_HAS_HWSERIAL 1
#elif defined(CONFIG_IDF_TARGET_ESP32H2)
  #define ESP_FAMILY_H2 1
  #define DEVICE_HAS_HWSERIAL 1
#elif defined(CONFIG_IDF_TARGET_ESP32P4)
  #define ESP_FAMILY_P4 1
  #define DEVICE_HAS_HWSERIAL 1
#elif defined(CONFIG_IDF_TARGET_ESP32S2)
  #define ESP_FAMILY_S2 1
  #define DEVICE_HAS_HWSERIAL 0 // No HW CDC
#elif defined(CONFIG_IDF_TARGET_ESP32S3)
  #define ESP_FAMILY_S3 1
  #define DEVICE_HAS_HWSERIAL 1
#elif defined(CONFIG_IDF_TARGET_ESP32C2)
  #define ESP_FAMILY_C2 1
  #define DEVICE_HAS_HWSERIAL 1
#elif defined(CONFIG_IDF_TARGET_ESP32C5)
  #define ESP_FAMILY_C5 1  
  #define DEVICE_HAS_HWSERIAL 1
#elif defined(CONFIG_IDF_TARGET_ESP32)
  #define ESP_FAMILY_CLASSIC 1
  #define DEVICE_HAS_HWSERIAL 0
#else
  #define ESP_FAMILY_UNKNOWN 1
  #define DEVICE_HAS_HWSERIAL 0
#endif

// --- Wi-Fi capability guard ---
// ESP32-H2: no Wi-Fi (BLE + 802.15.4 only) | ESP32-P4: no Wi-Fi / no BT (application MCU)
#if (defined(ESP_FAMILY_H2) || defined(ESP_FAMILY_P4))
  #define DEVICE_HAS_WIFI 0
#else
  #define DEVICE_HAS_WIFI 1
#endif

#if VERBOSE_MODE_WIFI_ONLY && DEVICE_HAS_WIFI
  #define DEBUG_USE_WIFI 1
#else
  #define DEBUG_USE_WIFI 0
#endif

#if VERBOSE_PERFORMANCE_ONLY
  #undef DEBUG_PERFORMANCE
  #define DEBUG_PERFORMANCE 0
#endif

#if USE_DCSBIOS_WIFI && !DEVICE_HAS_WIFI
  #error "❌ USE_DCSBIOS_WIFI is not supported on this chip (no Wi-Fi radio). ESP32-H2 and ESP32-P4 cannot use Wi-Fi."
#endif

#if DEBUG_USE_WIFI && !DEVICE_HAS_WIFI
  #error "❌ DEBUG_USE_WIFI is not supported on this chip (no Wi-Fi radio). Use Serial/USB debugging instead."
#endif

#if USE_DCSBIOS_USB
  // Check that we are on a TinyUSB-capable family
  #if !(defined(ESP_FAMILY_S2) || defined(ESP_FAMILY_S3) || defined(ESP_FAMILY_P4))
    #error "❌ USE_DCSBIOS_USB is only supported on ESP32-S2 / ESP32-S3 / ESP32-P4 devices."
  #endif
  // Check that we are in TinyUSB mode
  #if (ARDUINO_USB_MODE != 0)
    #error "❌ You need to enable USB-OTG (TinyUSB). See Tools menu, 'USB Mode' option. This is required if you compile this program with the USE_DCSBIOS_USB option selected."
  #endif
#endif

// --- BLE allowed chips ---
#if USE_DCSBIOS_BLUETOOTH

  #if !__has_include("src/Core/Private/BLEManager.cpp")
      #error "The Open source version of CockpitOS does NOT include BLE support. This is reserved for private use only. Not available upon request or as a paid feature."
  #endif

  #if !( defined(ESP_FAMILY_CLASSIC) || defined(ESP_FAMILY_S3) || \
         defined(ESP_FAMILY_C2)      || defined(ESP_FAMILY_C3) || \
         defined(ESP_FAMILY_C5)      || defined(ESP_FAMILY_C6) || \
         defined(ESP_FAMILY_H2) )
    #error "❌ BLE is not supported on ESP32-S2 or ESP32-P4. Choose another mode"
  #endif
#endif

// Define the Built-in LED if compiling with a board that does not define it. Only if you get errors about LED_BUILTIN not defined.
#ifndef LED_BUILTIN
  #if ESP_FAMILY_CLASSIC
    #define LED_BUILTIN  -1 // Default LED pin
  #else
    #define LED_BUILTIN -1 // Default LED pin
  #endif
#endif

// ============================================================================
//  ESP32 DEVICE CAPABILITY MATRIX
// ============================================================================
//
//  Chip     | Arch   | Cores | WiFi | BLE | USB-OTG | RTC GPIO | Deep-sleep wake
//  ---------|--------|-------|------|-----|---------|----------|----------------
//  Classic  | Xtensa |   2   |  Y   |  Y  |    N    |    Y     | EXT0 / EXT1
//  S2       | Xtensa |   1   |  Y   |  N  |    Y    |    Y     | EXT0 / EXT1
//  S3       | Xtensa |   2   |  Y   |  Y  |    Y    |    Y     | EXT0 / EXT1
//  C2       | RISC-V |   1   |  Y   |  Y  |    N    |    N     | GPIO
//  C3       | RISC-V |   1   |  Y   |  Y  |    N    |    N     | GPIO
//  C5       | RISC-V |   1   |  Y   |  Y  |    N    |    N     | GPIO
//  C6       | RISC-V |   1   |  Y   |  Y  |    N    |    N     | GPIO
//  H2       | RISC-V |   1   |  N   |  Y  |    N    |    N     | EXT1 / GPIO
//  P4       | RISC-V |   2   |  N   |  N  |    Y    |    N     | GPIO
//
//  CockpitOS transport support:
//
//  Transport       | Allowed chips                    | Guard
//  ----------------|----------------------------------|-------------------------------
//  USB  (TinyUSB)  | S2, S3, P4                       | #error at line ~337
//  WiFi (UDP)      | All EXCEPT H2, P4                | #error at line ~327
//  Serial (CDC)    | All                              | (always available)
//  Bluetooth (BLE) | Classic, S3, C2, C3, C5, C6, H2 | #error at line ~356
//  RS485 Slave     | All (UART-based)                 | (no chip restriction)
//
// ============================================================================

#include "src/LABELS/active_set.h"
#if !defined(LABEL_SET)
  #error "You need to run the auto-generator script in the LABELS directory"
#endif